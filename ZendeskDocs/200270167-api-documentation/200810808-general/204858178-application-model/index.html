
<html>
  <head>
    <meta charset='UTF-8'>
    <link rel='stylesheet' href='http://output.jsbin.com/gefofo.css' />
  </head>
  <body>
    <div id='container'>
    
      <h1>Application Model</h1>
      <p>Consider the sample application <strong>Counter</strong>, shown below. This application displays a count, with buttons to increment, decrement, and reset the count. The decrement and reset buttons are only enabled if the count is greater than zero. The count value is displayed in green with a normal font weight unless the count is greater than or equal to 10, in which case the count is displayed in red and bold.</p>
<p><img src="https://support.synchro.io/hc/en-us/article_attachments/201551748/win_counter.png" alt="" /></p>
<p>This is the Synchro code for the <strong>Counter</strong> sample app:</p>
<pre><code>// Counter page
//
var fontStyle = 
{
    normal: { color: "Green", isBold: false },
    highlighted: { color: "Red", isBold: true }
}

exports.View =
{
    title: "Click Counter",
    elements: 
    [
        { control: "text", value: "Count: {count}", color: "{font.color}", font: { size: 24, bold: "{font.isBold}" } },
        { control: "button", caption: "Increment Count", binding: { command: "vary", amount: 1 } },
        { control: "button", caption: "Decrement Count", binding: { command: "vary", amount: -1 }, enabled: "{count}" },
        { control: "button", caption: "Reset Count", binding: "reset", enabled: "{count}" },
    ]
}

exports.InitializeViewModel = function(context, session, params)
{
    var viewModel =
    {
        count: 0,
        font: fontStyle.normal,
    }
    return viewModel;
}

exports.Commands = 
{
    vary: function(context, session, viewModel, params)
    {
        viewModel.count += params.amount;
    },
    reset: function(context, session, viewModel)
    {
        viewModel.count = 0;
    },
}

exports.OnViewModelChange = function(context, session, viewModel, source, changes)
{
    viewModel.font = (viewModel.count &lt; 10) ? fontStyle.normal : fontStyle.highlighted; 
}<br /></code></pre>
<p>Now let's break down what is happening here. Note that for the purpose of this explanation, we will refer to the unit of functionality expressed above as a "page", and the instance of this code running on the Synchro server as the "page module".</p>
<p>The page above provides a view, view model data, view model commands, and view model update notifications. We'll discuss how these elements fit into the application model below.</p>
<p>In our sample, we declare some module variables, as shown below.</p>
<pre><code>var fontStyle = 
{
    normal: { color: "Green", isBold: false },
    highlighted: { color: "Red", isBold: true }
}
</code></pre>
<p>It is important to note that there is <strong>no module state</strong> of any kind (the module may very well even be unloaded and reloaded, and possibly even updated, during any given session). Any local module variables should be used as if they were static, as we have done here. The only state available to the page module is provided via the <code>session</code> and <code>viewModel</code> parameters passed to the various callback methods.</p>
<p>When the client requests a page, the first action taken by the Synchro server is to get initial view model data for the page via the page's <code>exports.InitializeViewModel</code> method.</p>
<pre><code>exports.InitializeViewModel = function(context, session, params)
{
    var viewModel =
    {
        count: 0,
        font: fontStyle.normal,
    }
    return viewModel;
}
</code></pre>
<p>The Synchro server then retrieves the view specification for the page via <code>exports.View</code>, and applies any Layout Filtering or (optional) view initialization logic to that view specification.</p>
<pre><code>exports.View =
{
    title: "Click Counter",
    elements: 
    [
        { control: "text", value: "Count: {count}", color: "{font.color}", font: { size: 24, bold: "{font.isBold}" } },
        { control: "button", caption: "Increment Count", binding: { command: "vary", amount: 1 } },
        { control: "button", caption: "Decrement Count", binding: { command: "vary", amount: -1 }, enabled: "{count}" },
        { control: "button", caption: "Reset Count", binding: "reset", enabled: "{count}" },
    ]
}
</code></pre>
<p>Once the Synchro server has the view specification (filtered for the client, as appropriate) and the initial view model data, it sends that information to the client, and the client can then render the view and begin allowing the user to interact with it.</p>
<p>Various user interactions can trigger view model commands. In our example, the user clicking any of the buttons will trigger a command. The view model commands are packaged together and exposed via the <code>exports.Commands</code> object.</p>
<pre><code>exports.Commands = 
{
    vary: function(context, session, viewModel, params)
    {
        viewModel.count += params.amount;
    },
    reset: function(context, session, viewModel)
    {
        viewModel.count = 0;
    },
}
</code></pre>
<p>When view model data is changed by the client, the server is notified via the <code>exports.OnChange</code> method, allowing the page module to take action based on the change, before any commands are executed. The <code>source</code> parameter will contain the value "view" in this case (the view was the source of the change).</p>
<p>When view model data is changed by the execution of a page module command, the <code>exports.OnChange</code> method is also called, in this case with a <code>source</code> parameter value of "command" (a command was the source of the change). It should be noted that the command could simply apply its own post processing, but this call is provided as a convenience to allow centralized handling of view model data changes in one place. For example, in the counter sample we want to set the font based on the count without having to do this from each command that might have modified the count.</p>
<pre><code>exports.OnViewModelChange = function(context, session, viewModel, source, changes)
{
    viewModel.font = (viewModel.count &lt; 10) ? fontStyle.normal : fontStyle.highlighted; 
}
</code></pre>
<p>See the complete list of <a href="/hc/en-us/articles/205668357">Module Entry Points</a> for more details on these and other module functions, including their parameters and operation.</p>
      
    </div>
  </body>
</html>
    
