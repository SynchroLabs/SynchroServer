// Following is code to load Synchro modules that do not (necessarily) exist in physical disk files.
//
// Reference: https://github.com/joyent/node/blob/master/lib/module.js
//
// Here is some higher order cache invalidation thinking...
//
//     http://stackoverflow.com/questions/9210542/node-js-require-cache-possible-to-invalidate
//
var path = require('path');
var Module = require('module');

var logger = require('log4js').getLogger("module-manager");

// -----------------------------------------------------------

// Note: The module loader below loads modules from the provided moduleStore.  It keeps a route map, and uses
//       that to give to processors.  In this way, if a module representing a route is reloaded, new processors
//       will get the reloaded module, while existing processors can finish their transactions using the previous
//       version, to which they still have a reference.  So the server can hum along happily with a restart.
//
//       One limitation of this is that if one of these route modules references another route module (perhaps
//       because they share some common code), when the referenced module is reloaded it will not trigger the 
//       dependent module to be reloaded (the dependent module will have a reference to the old referenced 
//       module until the dependent module itself is reloaded).  This is not ideal.  One solution would be to
//       understand the dependency relationship so we know which dependent modules, if any, also need to be reloaded
//       when we reload a module.
//
//       Another issue is that we currently do not support any kind of route module path or subdirectory notation
//       in the module stores, so everything has to be a the top level.  It would be nice if we could both group
//       our modules into folders, and if we could have a node_modules folder that allowed local packages.  Either
//       of these things, when implemented, probably imply a reworking of the route/mapper (so that we treat actual
//       routes to pages differently potentially than we treat the loading/management of supporting modules).
//       

module.exports = function(moduleStore, appRootPath, appContainer, resourceResolver)
{
    var containerDir = path.resolve(appRootPath, appContainer) + path.sep;

    var appModuleStore = moduleStore.getAppModuleStore(appContainer);

    // This is the route dictionary (routePath: module)
    var routes = {};
    
    // This is the list of files that exist in the module store and may be loaded from it
    var moduleFiles = [];

    var supportModule;
    
    // Is the module referenced by the filename in our container...
    //
    function isContainerModule(filename)
    {
        // Look for file paths under container dir...
        //
        // logger.info("Container dir: " + containerDir + ", filename: " + filename);

        if (filename.lastIndexOf(containerDir, 0) == 0)
        {
            // Except for anything in the node_modules under the container dir...
            //
            if (filename.lastIndexOf(path.resolve(containerDir, "node_modules"), 0) != 0)
            {
                return true;
            }
        }
    }

    // Get path relative to container with normalized separators...
    //
    var platformIndependentPathSep = '/';
    function getModuleStorePath(filename)
    {
        if (filename.lastIndexOf(containerDir, 0) == 0)
        {
            var modulePath = filename.substring(containerDir.length);
            if (path.sep == '\\')
            {
                modulePath = modulePath.replace(/[\\]/g, platformIndependentPathSep);
            }
            return modulePath;
        }
    }

    // Is the module referenced by the filename a top-level route (in our container)...
    //
    function isRouteModule(filename)
    {
        if ((path.dirname(filename) + path.sep) == containerDir)
        {
            var moduleName = path.basename(filename);
            if (moduleFiles.indexOf(moduleName) >= 0) // !!! use "routes"?
            {
                return true;
            }
        }
        return false;
    }    
    
    // Node.js is *very* excited about associating every loaded module with a physical file on disk.
    // In order to work around this, we monkey-patch _resolveFilename to return the "virtual" filename
    // for modules that we will later be able to load (in the extension loader below).
    //
    // This is required because the file may not actually exist at the file system location indicated, for
    // example when a remote module store (Azure, AWS, etc) is being used.
    //
    Module._resolveFilename = (function (original)
    {
        return function (request, parent)
        {
            if (parent.filename) // Check to see if this is relative path that resolves to a module file
            {
                var filename = path.resolve(path.dirname(parent.filename), request);

                if (isContainerModule(filename))
                {
                    logger.info("File is in this container: " + filename);

                    if (path.extname(filename) == "")
                    {
                        filename = filename + ".js";
                    }           
                    return filename;
                }
            }
            return original.apply(this, arguments)
        }
    })(Module._resolveFilename);
    
    // This is a monkey-patching of the extension loader that allows us to load our own js modules.
    //
    Module._extensions['.js'] = (function (original)
    {
        return function (module, filename)
        {
            // logger.info("Module loader - extension loader for file: " + filename);

            if (isContainerModule(filename))
            {
                logger.info("Loading container file: " + filename);

                var modulePath = getModuleStorePath(filename);
                var moduleSource = appModuleStore.getModuleSource(modulePath);

                // When a module is loaded by Node, it is wrapped in this function:
                //
                //    (function (exports, require, module, __filename, __dirname) { -- your module code goes here --    
                //    });
                //
                // This happens as part of NativeModule.wrap() - see: https://github.com/joyent/node/blob/master/src/node.js
                //
                // Below we take advantage of this to jam in the Synchro module reference.  It is tempting to add a newline, 
                // but that would interfere with the line numbering of the file, which is important for debugging/breakpoints.
                //
                if (isRouteModule(filename))
                {
                    module.supportModule = supportModule;
                    moduleSource = " var Synchro = module.supportModule; " + moduleSource;
                }
                module._compile(moduleSource, filename);
            }
            else
            {
                return original.apply(this, arguments)
            }
        }
    })(Module._extensions['.js']);

    function isRouteModuleName(moduleName)
    {
        // Top level modules only...
        //
        return (moduleName.indexOf('/') == -1);
    }

    function loadModule(moduleName)
    {
        var filename = path.resolve(containerDir, moduleName);
        var synchroModule = require(filename);

        if (isRouteModuleName(moduleName))
        {
            var routePath = path.basename(moduleName, path.extname(moduleName));
            logger.info("Found and loaded route processor for: " + routePath);
            routes[routePath] = synchroModule;            
        }
    }

    function loadAppRoutes()
    {
        var moduleNames = appModuleStore.listModules();
        moduleFiles = moduleNames;
        for (var i = 0; i < moduleNames.length; i++) 
        {
            if (isRouteModuleName(moduleNames[i]))
            {
                logger.info("Loading route module: " + moduleNames[i]);
                loadModule(moduleNames[i]);
            }
            else
            {
                logger.info("Not loading supporting module as route: " + moduleNames[i]);
            }
        }        
    }

    // !!! We're going to need some mechanism to deal with modules being added/deleted from Studio, which will call in to here
    //     to refresh the state of the running API processor (presumably).
    //
    var moduleManager = 
    {
        loadRoutes: function(apiProcessor)
        {
            supportModule = require('./app-services')(apiProcessor, resourceResolver);

            loadAppRoutes();

            var appDefinition = appModuleStore.getAppDefinition();
            return appDefinition;
        },

        reloadModule: function(moduleName, source)
        {
            if (source)
            {
                appModuleStore.putModuleSource(moduleName, source);
            }

            // NOTE: There's no easy way to figure out which other modules might be impacted by the change to the
            //       module being reloaded, so we're just going to clean up the whole Synchro app and reload it.

            // Delete all currently loaded modules that were loaded from this container...
            //
            for (var cachedModule in require.cache) 
            {
                if (require.cache.hasOwnProperty(cachedModule)) 
                {
                    if (cachedModule.indexOf(containerDir, 0) == 0)
                    {
                        console.log("Uncaching module: " + cachedModule);
                        delete require.cache[cachedModule];
                    }
                }
            }

            // Reload all the routes
            //
            loadAppRoutes();
        },

        getModule: function(routePath)
        {
            return routes[routePath];
        }
    }

    return moduleManager;
}
