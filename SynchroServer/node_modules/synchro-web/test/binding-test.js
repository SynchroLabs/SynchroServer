require('./test');

var assert = require("assert")
require("./assert-helper");

var lodash = require('lodash');

var binding = require('../client/core/binding');
var PropertyValue = binding.PropertyValue;
var bindingContext = require('../client/core/binding-context');
var JToken = require('../client/core/json');

describe("Binding", function () 
{
    describe("canonicalizer", function()
    {
        it("should promote value", function()
        {
            // For an edit control with a default binding attribute of "value" a binding of:
            //
            //     binding: "username"
            //
            var controlSpec = {"binding": "username"};
            var originalControlSpec = lodash.cloneDeep(controlSpec);

            // becomes
            //
            //     binding: { value: "username" }
            //
            var expectedBindingSpec = {"value": "username"};

            var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, "value");
            assert(bindingSpec);
            assert(lodash.isEqual(bindingSpec, expectedBindingSpec));

            // Verify that we didn't corrupt the original object
            assert(lodash.isEqual(controlSpec, originalControlSpec));
        });

        it("should promote implicit command", function()
        {
            // For commands:
            //
            //     binding: "doSomething"
            //
            var controlSpec = {"binding": "doSomething"};
            var originalControlSpec = lodash.cloneDeep(controlSpec);

            // becomes
            //
            //     binding: { onClick: "doSomething" }
            //
            // becomes
            //
            //     binding: { onClick: { command: "doSomething" } }
            //
            var expectedBindingSpec = {"onClick": {"command": "doSomething"} };

            var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, "onClick", ["onClick"]);
            assert(lodash.isEqual(bindingSpec, expectedBindingSpec));

            // Verify that we didn't corrupt the original object
            assert(lodash.isEqual(controlSpec, originalControlSpec));
        });

        it("should promote explicit command", function()
        {
            // Also (default binding atttribute is 'onClick', which is also in command attributes list):
            //
            //     binding: { command: "doSomething" value: "theValue" }
            //
            var controlSpec = {"binding": {"command": "doSomething", "value": "theValue"} };
            var originalControlSpec = lodash.cloneDeep(controlSpec);

            // becomes
            //
            //     binding: { onClick: { command: "doSomething", value: "theValue" } }
            //
            var expectedBindingSpec = {"onClick": {"command": "doSomething", "value": "theValue"} };

            var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, "onClick", ["onClick"]);
            assert(lodash.isEqual(bindingSpec, expectedBindingSpec));

            // Verify that we didn't corrupt the original object
            assert(lodash.isEqual(controlSpec, originalControlSpec));
        });

        it("should promote multiple commands", function()
        {
            // For multiple commands with implicit values...
            //
            //     binding: { onClick: "doClickCommand", onSelect: "doSelectCommand" }
            //
            var controlSpec = {"binding": {"onClick": "doClickCommand", "onSelect": "doSelectCommand"} };
            var originalControlSpec = lodash.cloneDeep(controlSpec);
        
            // becomes
            //
            //     binding: { onClick: { command: "doClickCommand" }, onSelect: { command: "doSelectCommand" } }
            //
            var expectedBindingSpec = {"onClick": {"command": "doClickCommand" }, "onSelect": {"command": "doSelectCommand"} };
        
            var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, "onClick", ["onClick", "onSelect"]);
            assert(lodash.isEqual(bindingSpec, expectedBindingSpec));

            // Verify that we didn't corrupt the original object
            assert(lodash.isEqual(controlSpec, originalControlSpec));
        });
    });

    describe("property value", function()
    {
        it("should expand value", function()
        {
            var viewModel = new JToken(
            {
                "serial": 0,
                "title": "Colors",
                "colors":
                [
                    { "name": "Red",   "color": "red",   "value": "0xff0000" },
                    { "name": "Green", "color": "green", "value": "0x00ff00" },
                    { "name": "Blue",  "color": "blue",  "value": "0x0000ff" }
                ]
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("The {title} are {colors[0].name}, {colors[1].name}, and {colors[2].name}", bindingCtx);

            assert.equal("The Colors are Red, Green, and Blue", propVal.expand().getValue());
        });

        it("should update model", function()
        {
            var viewModel = new JToken(
            {
                "serial": 0,
                "title": "Colors",
                "colors":
                [
                    { "name": "Red",   "color": "red",   "value": "0xff0000" },
                    { "name": "Green", "color": "green", "value": "0x00ff00" },
                    { "name": "Blue",  "color": "blue",  "value": "0x0000ff" }
                ]
            });
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The {title} are {colors[0].name}, {colors[1].name}, and {colors[2].name}", bindingCtx);
        
            assert.equal("The Colors are Red, Green, and Blue", propVal.expand().getValue());
            assert(viewModel.selectToken("colors.1").replace(new JToken({"name": "Greenish", "color": "green", "value": "0x00ff00" })));

            var bindingContexts = propVal.getBindingContexts();
            for (var i = 0; i < bindingContexts.length; i++)
            {
                bindingContexts[i].rebind();
            }

            assert.equal("The Colors are Red, Greenish, and Blue", propVal.expand().getValue());
        });

        it("should update model one-time token", function()
        {
            var viewModel = new JToken(
            {
                "serial": 0,
                "title": "Colors",
                "colors":
                [
                    { "name": "Red",   "color": "red",   "value": "0xff0000" },
                    { "name": "Green", "color": "green", "value": "0x00ff00" },
                    { "name": "Blue",  "color": "blue",  "value": "0x0000ff" }
                ]
            });
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The {title} are {colors[0].name}, {colors[1].name}, and {^colors[2].name}", bindingCtx);

            assert.equal("The Colors are Red, Green, and Blue", propVal.expand().getValue());
        
            assert(viewModel.selectToken("colors.1").replace(new JToken({"name": "Greenish", "color": "green", "value": "0x00ff00" })));
            assert(viewModel.selectToken("colors.2").replace(new JToken({"name": "Blueish", "color": "blue", "value": "0x0000ff" })));

            var bindingContexts = propVal.getBindingContexts();
            for (var i = 0; i < bindingContexts.length; i++)
            {
                bindingContexts[i].rebind();
            }

            assert.equal("The Colors are Red, Greenish, and Blue", propVal.expand().getValue());
        });

        it("should expand int token", function()
        {
            var viewModel = new JToken({"serial": 420});
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("{serial}", bindingCtx);
            var expandedPropValToken = propVal.expand().getValue();
        
            assert(typeof expandedPropValToken === 'number');
            assert.equal(420, expandedPropValToken);
        });

        it("should expand float token", function()
        {
            var viewModel = new JToken({"serial": 13.69});
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("{serial}", bindingCtx);
            var expandedPropValToken = propVal.expand().getValue();
        
            assert(typeof expandedPropValToken === 'number');
            assert.equal(13.69, expandedPropValToken);
        });

        it("should expand bool token", function()
        {
            var viewModel = new JToken({"serial": true});
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("{serial}", bindingCtx);
            var expandedPropValToken = propVal.expand().getValue();
        
            assert(typeof expandedPropValToken === 'boolean');
            assert.equal(true, expandedPropValToken);
        });

        it("should expand bool token negated", function()
        {
            var viewModel = new JToken({"serial": true});
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("{!serial}", bindingCtx);
            var expandedPropValToken = propVal.expand().getValue();
        
            assert(typeof expandedPropValToken === 'boolean');
            assert.equal(false, expandedPropValToken);
        });

        it("should expand string token", function()
        {
            var viewModel = new JToken({"serial": "foo"});
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("{serial}", bindingCtx);
            var expandedPropValToken = propVal.expand().getValue();
        
            assert(typeof expandedPropValToken === 'string');
            assert.equal("foo", expandedPropValToken);
        });

        it("should expand string token negated", function()
        {
            var viewModel = new JToken({"serial": "foo"});
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("{!serial}", bindingCtx);
            var expandedPropValToken = propVal.expand().getValue();
        
            // When we negate a string, the type is coerced (converted) to bool, then inverted...
            assert(typeof expandedPropValToken === 'boolean');
            assert.equal(false, expandedPropValToken);
        });

        it("should escape curly braces", function()
        {
            var viewModel = new JToken();
            var bindingCtx = new bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("This is how you indicate a token: {{serial}}", bindingCtx);
            assert.equal("This is how you indicate a token: {serial}", propVal.expand().getValue());

            propVal = new PropertyValue("Open {{ only", bindingCtx);
            assert.equal("Open { only", propVal.expand().getValue());

            propVal = new PropertyValue("Close }} only", bindingCtx);
            assert.equal("Close } only", propVal.expand().getValue());

            propVal = new PropertyValue("{{{{Double}}}}", bindingCtx);
            assert.equal("{{Double}}", propVal.expand().getValue());
        });

        it("should test containsBindingToken", function()
        {
            assert(!PropertyValue.containsBindingTokens(""));
            assert(!PropertyValue.containsBindingTokens("{{foo}}"));
            assert(!PropertyValue.containsBindingTokens("Foo {{bar}} baz"));
            assert(PropertyValue.containsBindingTokens("{bar}"));
            assert(PropertyValue.containsBindingTokens("Foo {bar} baz"));
            assert(PropertyValue.containsBindingTokens("Foo {bar} {baz}"));
        });

        it("should format as int, no spec", function()
        {
            var viewModel = new JToken({"serial": 69});
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The number is: {serial}", bindingCtx);
        
            assert.equal("The number is: 69", propVal.expand().getValue());
        });

        it("should format as float, no spec", function()
        {
            var viewModel = new JToken({"serial": 13.69});
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The number is: {serial}", bindingCtx);
        
            assert.equal("The number is: 13.69", propVal.expand().getValue());
        });

        it("should format as percentage", function()
        {
            var viewModel = new JToken(
            {
                "intVal": 13,
                "doubleVal": 0.69139876,
                "strVal": "threeve"
            });
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The int percentage is {intVal:P}, the double is: {doubleVal:P2}, and the str is {strVal:P2}", bindingCtx);

            assert.equal("The int percentage is 1,300.00%, the double is: 69.14%, and the str is threeve", propVal.expand().getValue());
        });

        it("should format as decimal", function()
        {
            var viewModel = new JToken(
            {
                "intVal": -13420,
                "doubleVal": 69.139876,
                "strVal": "threeve"
            });
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The int val is {intVal:D}, the double val is: {doubleVal:D4}, and the str val is {strVal:D2}", bindingCtx);
        
            assert.equal("The int val is -13420, the double val is: 0069, and the str val is threeve", propVal.expand().getValue());
        });

        it("should format as number", function()
        {
            var viewModel = new JToken(
            {
                "intVal": -13420,
                "doubleVal": 69.139876,
                "strVal": "threeve"
            });
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The int val is {intVal:N}, the double val is: {doubleVal:N4}, and the str val is {strVal:N2}", bindingCtx);
        
            assert.equal("The int val is -13,420.00, the double val is: 69.1399, and the str val is threeve", propVal.expand().getValue());
        });

        it("should format as hex", function()
        {
            var viewModel = new JToken(
            {
                "intVal": 254,
                "doubleVal": 254.139876,
                "strVal": "threeve"
            });
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The int val is {intVal:x}, the double val is: {doubleVal:X4}, and the str val is {strVal:X2}", bindingCtx);
        
            assert.equal("The int val is fe, the double val is: 00FE, and the str val is threeve", propVal.expand().getValue());
        });

        it("should format as fixed-point", function()
        {
            var viewModel = new JToken(
            {
                "intVal": -13420,
                "doubleVal": 254.139876,
                "strVal": "threeve"
            });
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The int val is {intVal:F2}, the double val is: {doubleVal:F4}, and the str val is {strVal:F2}", bindingCtx);
        
            assert.equal("The int val is -13420.00, the double val is: 254.1399, and the str val is threeve", propVal.expand().getValue());
        });

        it("should format as exponential", function()
        {
            var viewModel = new JToken(
            {
                "intVal": -69,
                "doubleVal": 69.123456789,
                "strVal": "threeve"
            });
        
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The int val is {intVal:E2}, the double val is: {doubleVal:e4}, and the str val is {strVal:e2}", bindingCtx);
        
            // .NET uses the "e+001" notation and iOS uses "e1" notation.  They both use locale-aware built-in formatters for this,
            // so we elected not to try to force them to be consistent with each other.  The Web client uses e+1, which is also fine.
            //
            assert.equal("The int val is -6.90E+1, the double val is: 6.9123e+1, and the str val is threeve", propVal.expand().getValue());
        });

        it("should format number parsed from string", function()
        {
            var viewModel = new JToken({"strVal": "13"});
    
            var bindingCtx = bindingContext.createRootBindingContext(viewModel);
        
            var propVal = new PropertyValue("The numeric value is {strVal:F2}", bindingCtx);
        
            assert.equal("The numeric value is 13.00", propVal.expand().getValue());
        });

        it("should eval to string result", function()
        {
            var viewModel = new JToken(
            {
                "strVal": "hello"
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("eval({strVal} + ' world')", bindingCtx);

            assert.equal("hello world", propVal.expand().getValue());
        });

        it("should eval to numeric result", function()
        {
            var viewModel = new JToken(
            {
                "strVal": "hello",
                "intVal": 10
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("eval({strVal}.length + {intVal})", bindingCtx);

            assert.equal(15, propVal.expand().getValue());
        });

        it("should eval to boolean result", function()
        {
            var viewModel = new JToken(
            {
                "intVal": 10
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("eval({intVal} == 10)", bindingCtx);

            assert.equal(true, propVal.expand().getValue());
        });

        it("should eval bool param", function()
        {
            var viewModel = new JToken(
            {
                "boolVal": true
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("eval(false || {boolVal})", bindingCtx);

            assert.equal(true, propVal.expand().getValue());
        });

        it("should eval null param", function()
        {
            var viewModel = new JToken(
            {
                "nullVal": null
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("eval(null === {nullVal})", bindingCtx);

            assert.equal(true, propVal.expand().getValue());
        });

        it("should eval to string version of unsupported param type", function()
        {
            var viewModel = new JToken(
            {
                "colors":
                [
                    { "name": "Red",   "color": "red",   "value": "0xff0000" },
                    { "name": "Green", "color": "green", "value": "0x00ff00" },
                    { "name": "Blue",  "color": "blue",  "value": "0x0000ff" }
                ]
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("eval({colors})", bindingCtx);

            // Unsupport JValue type will be converted to string in the Synchro way (array will get converted to string value representing
            // length of the array).
            //
            assert.equal("3", propVal.expand().getValue());
        });

        it("should eval to null result", function()
        {
            var viewModel = new JToken(
            {
                "intVal": 10
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("eval(null)", bindingCtx);

            assert.equal(null, propVal.expand().getValue());
        });

        it("should eval to string version of unsupported result type", function()
        {
            var viewModel = new JToken(
            {
                "intVal": 10
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("eval(['foo', 'bar'])", bindingCtx);

            // Expected result is toString() of actual result when not of support type (Boolean, Number, String, Null)
            assert.equal("foo,bar", propVal.expand().getValue());
        });

        it("should eval to error with bad script", function()
        {
            var viewModel = new JToken(
            {
                "intVal": 10
            });

            var bindingCtx = bindingContext.createRootBindingContext(viewModel);

            var propVal = new PropertyValue("eval()foo)", bindingCtx);

            assert.equal("Unexpected token )", propVal.expand().getValue());
        });

    });
});
