// 'request' should work in the browser - per: https://github.com/request/request/issues/455
//
var request = require('request');

var logger = require('log4js').getLogger("transport");

var Transport = function(uri)
{
    this.uri = uri;
    this.sessionId;
    this.responseHandler;
    this.requestFailureHandler;
}

Transport.uriFromHostString = function(host, scheme)
{
    if (!scheme)
    {
        scheme = 'http';
    }
    var uri = host;
    if (!host.match(/^https?:\/\/.*/))
    {
        uri = scheme + "://" + host;
    }
    return uri;
}

Transport.prototype.setDefaultHandlers = function(responseHandler, requestFailureHandler)
{
    this.responseHandler = responseHandler;
    this.requestFailureHandler = requestFailureHandler;
}

Transport.prototype.sendMessage = function(sessionId, requestObject, responseHandler, requestFailureHandler)
{
    logger.info("Request:", requestObject);

    if (sessionId != null)
    {
        this.sessionId = sessionId;
    }

    if (responseHandler == null)
    {
        responseHandler = this.responseHandler;
    }
    if (requestFailureHandler == null)
    {
        requestFailureHandler = this.requestFailureHandler;
    }

    var options =
    { 
        url: this.uri,
        method: 'POST',
        json: requestObject,
        headers: {
          'synchro-api-session-id': this.sessionId
        },
        timeout: 60000 // 60 seconds - matches iOS default timeout
    };

    var doc = window.document;
    request(options, function (err, response, body)
    {
        if (response && ((response.statusCode < 200) || (response.statusCode >= 300)))
        {
            err = new Error("Non-success status received on response: " + response.statusCode);
            err.statusCode = response.statusCode; // !!! err.Data[statusCode] ?
        }

        if (!window || (doc != window.document))
        {
            // This can happen on a browser refresh where there is a pending long-poll outstanding.  The
            // request fails when the new document is loaded.  In this case we don't want to throw up an
            // error message box.  Note that you won't see the log message below in the Chrome console, since
            // that log event is attached to an obsolete (non-current) document/window.
            //
            // Note: It seems like comparing the window.document is correct, but at least in Chrome, when
            //       we encounter this situation the window object is null (kinda makes sense if you squint,
            //       since you don't have a window).
            //
            logger.info("Error response to non-current page");
        }
        else if (err)
        {
            requestFailureHandler(requestObject, err);
        }
        else
        {
            responseHandler(body);
        }
    });
}

Transport.prototype.getAppDefinition = function(callback)
{
    var requestObject = 
    {
        "Mode": "AppDefinition",
        "TransactionId": 0
    }

    this.sendMessage(
        null,
        requestObject,
        function (response)
        {
            callback(response.App);
        },
        function (err)
        { 
            callback(null);
        }
    );
}

module.exports = Transport;
