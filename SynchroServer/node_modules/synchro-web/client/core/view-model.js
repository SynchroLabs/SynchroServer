var logger = require('log4js').getLogger("view-model");

var JToken = require('./json');
var bindingContext = require('./binding-context');
var binding = require('./binding');
var ValueBinding = binding.ValueBinding;
var PropertyBinding = binding.PropertyBinding;

var ViewModel = function()
{
    this._rootObject = new JToken({});
    this._rootBindingContext = bindingContext.createRootBindingContext(this._rootObject);
    this._updatingView = false;

    this._valueBindings = [];
    this._propertyBindings = [];
}

ViewModel.prototype.getRootBindingContext = function ()
{
    return this._rootBindingContext;
}

// Only used by BindingContext - "internal"?
//
ViewModel.prototype.getRootObject = function ()
{ 
    return this._rootObject;
}

ViewModel.prototype.createAndRegisterValueBinding = function (bindingContext, getValue, setValue)
{
    var valueBinding = new ValueBinding(this, bindingContext, getValue, setValue);
    this._valueBindings.push(valueBinding);
    return valueBinding;
}

ViewModel.prototype.unregisterValueBinding = function(valueBinding)
{
    this._valueBindings.splice(this._valueBindings.indexOf(valueBinding), 1 );
}

ViewModel.prototype.createAndRegisterPropertyBinding = function (bindingContext, value, setValue)
{
    var propertyBinding = new PropertyBinding(bindingContext, value, setValue);
    this._propertyBindings.push(propertyBinding);
    return propertyBinding;
}

ViewModel.prototype.unregisterPropertyBinding = function (propertyBinding)
{
    this._propertyBindings.splice(this._propertyBindings.indexOf(propertyBinding), 1 );
}

// Tokens in the view model have a "ViewModel." prefix (as the view model itself is a child node of a larger
// JSON response).  We need to prune that off so future SelectToken operations will work when applied to the
// root binding context (the context associated with the "ViewModel" JSON object).
//
ViewModel.getTokenPath = function(token)
{
    var path = token.getPath();

    if (path.indoexOf("ViewModel.") == 0)
    {
        path = path.slice("ViewModel.".length);
    }

    return path;
}

ViewModel.prototype.initializeViewModelData = function(viewModel)
{
    if (viewModel == null)
    {
        viewModel = new JToken({});
    }
    this._rootObject = viewModel;
    this._rootBindingContext = new bindingContext.createRootBindingContext(this._rootObject);

    // Clear bindings
    this._valueBindings = [];
    this._propertyBindings = [];;
}

ViewModel.prototype.setViewModelData = function(viewModel)
{
    if (viewModel == null)
    {
        viewModel = new JToken({});
    }
    this._rootObject = viewModel;
    this._rootBindingContext = new bindingContext.createRootBindingContext(this._rootObject);

    // Update bindings (setting BindingRoot to a new value will cause rebind)
    //
    for (var i = 0; i < this._valueBindings.length; i++)
    {
        this._valueBinding[i].getBindingContext().setBindingRoot(_rootBindingContext.getBindingRoot());
    }
    for (var i = 0; i < this._propertyBindings.length; i++)
    {
        var bindingContexts = this._propertyBindings[i].getBindingContexts();
        for (var j = 0; j < bindingsContexts; j++)
        {
            bindingContexts[i].setBindingRoot(_rootBindingContext.getBindingRoot());
        }
    }
}

// Internal class
//
// This object represents a binding update (the path of the bound item and an indication of whether rebinding is required)
//
var BindingUpdate = function(bindingPath, rebindRequired)
{
    this._bindingPath = bindingPath;
    this._rebindRequired = rebindRequired;
}

BindingUpdate.prototype.getBindingPath = function()
{
    return this._bindingPath;
}

BindingUpdate.prototype.isRebindRequired = function()
{
    return this._rebindRequired;
}

// If bindingUpdates is provided, any binding other than an optionally specified sourceBinding
// that is impacted by a token in bindingUpdates will have its view updated.  If no bindingUpdates
// is provided, all bindings will have their view updated.  
//
// If bindingUpdates is provided, any binding impacted by a path for which rebinding is indicated
// will be rebound.
//
// Usages:
//    On new view model - no params - update view for all bindings, no rebind needed
//    On update view model - pass list containing all updates 
//    On update view (from ux) - pass list containing the single update, and the sourceBinding (that triggered the update)
//
ViewModel.prototype.updateViewFromViewModel = function(bindingUpdates, sourceBinding)
{
    bindingUpdates = bindingUpdates || null;
    sourceBinding = sourceBinding || null;

    this._updatingView = true;

    for (var i = 0; i < this._valueBindings.length; i++)
    {
        var valueBinding = this._valueBindings[i];

        if (valueBinding.getBindingContext() != sourceBinding)
        {
            var isUpdateRequired = (bindingUpdates == null);
            var isBindingDirty = false;
            if (bindingUpdates != null)
            {
                for (var j = 0; j < bindingUpdates.length; j++)
                {
                    var update = bindingUpdates[j];

                    if (valueBinding.getBindingContext().isBindingUpdated(update.getBindingPath(), update.isRebindRequired()))
                    {
                        isUpdateRequired = true;
                        if (update.isRebindRequired())
                        {
                            isBindingDirty = true;
                            break;
                        }
                    }
                }
            }

            if (isBindingDirty)
            {
                logger.debug("Rebind value binding with path: %s", valueBinding.getBindingContext().getBindingPath());
                valueBinding.getBindingContext().rebind();
            }

            if (isUpdateRequired)
            {
                valueBinding.updateViewFromViewModel();
            }
        }
    }

    for (var i = 0; i < this._propertyBindings.length; i++)
    {
        var isUpdateRequired = (bindingUpdates == null);

        var propertyBinding = this._propertyBindings[i];

        var bindingContexts = propertyBinding.getBindingContexts();

        for (var j = 0; j < bindingContexts.length; j++)
        {
            var propBinding = bindingContexts[j];

            var isBindingDirty = false;
            if (bindingUpdates != null)
            {
                for (var k = 0; k < bindingUpdates.length; k++)
                {
                    var update = bindingUpdates[k];

                    if (propBinding.isBindingUpdated(update.getBindingPath(), update.isRebindRequired()))
                    {
                        isUpdateRequired = true;
                        if (update.isRebindRequired())
                        {
                            isBindingDirty = true;
                            break;
                        }
                    }
                }
            }

            if (isBindingDirty)
            {
                logger.debug("Rebind property binding with path: %s", propBinding.getBindingPath());
                propBinding.rebind();
            }
        }

        if (isUpdateRequired)
        {
            propertyBinding.updateViewFromViewModel();
        }
    }

    this._updatingView = false;
}

ViewModel.prototype.updateViewModelData = function(viewModelDeltas, updateView)
{
    if (typeof updateView === 'undefined')
    {
        updateView = true;
    }

    bindingUpdates = [];

    logger.debug("Processing view model updates: %s", viewModelDeltas);

    if (JToken.isArray(viewModelDeltas))
    {
        // Removals are generally reported as removals from the end of the list with increasing indexes.  If
        // we process them in this way, the first removal will change the list positions of remaining items
        // and cause subsequent removals to be off (typically to fail).  And we don't really want to rely
        // on ordering in the first place.  So what we are going to do is track all of the removals, and then
        // actually remove them at the end.
        //
        var removals = [];

        var viewModelDeltasArray = viewModelDeltas.getValue();
        for (var i = 0; i < viewModelDeltasArray.length; i++)
        {
            var viewModelDelta = viewModelDeltasArray[i];
            var path = viewModelDelta.get("path").getValue();
            var changeType = viewModelDelta.get("change").getValue();

            logger.debug("View model item change (%s) for path: %s", changeType, path);
            if (changeType == "object")
            {
                // For "object" changes, this just means that an existing object had a property added/updated/removed or
                // an array had items added/updated/removed.  We don't need to actually do any updates for this notification,
                // we just need to make sure any bound elements get their views updated appropriately.
                //
                bindingUpdates.push(new BindingUpdate(path, false));
            }
            else if (changeType == "update")
            {
                var vmItemValue = this._rootObject.selectToken(path);
                if (vmItemValue != null)
                {
                    logger.debug("Updating view model item for path: %s to value: %s", path, viewModelDelta.get("value"));

                    var rebindRequired = JToken.updateTokenValue(vmItemValue, viewModelDelta.get("value"));
                    bindingUpdates.push(new BindingUpdate(path, rebindRequired));
                }
                else
                {
                    logger.error("VIEW MODEL SYNC WARNING: Unable to find existing value when processing update, something went wrong, path: %s", path);
                }
            }
            else if (changeType == "add")
            {
                logger.debug("Adding bound item for path: %s with value: %s", path, viewModelDelta.get("value"));
                bindingUpdates.push(new BindingUpdate(path, true));

                // First, double check to make sure the path doesn't actually exist
                var vmItemValue = this._rootObject.selectToken(path, false);
                if (vmItemValue == null)
                {
                    if (/\]$/.test(path)) // .EndsWith("]")
                    {
                        // This is an array element...
                        var parentPath = path.substring(0, path.lastIndexOf("["));
                        var parentToken = this._rootObject.selectToken(parentPath);
                        if ((parentToken != null) && JToken.isArray(parentToken))
                        {
                            parentToken.append(viewModelDelta.get("value"));
                        }
                        else
                        {
                            logger.error("VIEW MODEL SYNC WARNING: Attempt to add array member, but parent didn't exist or was not an array, parent path: %s", parentPath);
                        }
                    }
                    else if (/[.]/.test(path)) // .Contains("."))
                    {
                        // This is an object property...
                        var parentPath = path.substring(0, path.lastIndexOf("."));
                        var attributeName = path.substring(path.lastIndexOf(".") + 1);
                        var parentToken = this._rootObject.selectToken(parentPath);
                        if ((parentToken != null) && JToken.isObject(parentToken))
                        {
                            parentToken.set(attributeName, viewModelDelta.get("value"));
                        }
                        else
                        {
                            logger.error("VIEW MODEL SYNC WARNING: Attempt to add object property, but parent didn't exist or was not an object, parent path: %s", parentPath);
                        }
                    }
                    else
                    {
                        // This is a root property...
                        this._rootObject.set(path, viewModelDelta.get("value"));
                    }
                }
                else
                {
                    logger.error("VIEW MODEL SYNC WARNING: Found existing value when processing add, something went wrong, path: %s", path);
                }
            }
            else if (changeType == "remove")
            {
                logger.debug("Removing bound item for path: %s", path);
                bindingUpdates.push(new BindingUpdate(path, true));

                var vmItemValue = this._rootObject.selectToken(path);
                if (vmItemValue != null)
                {
                    logger.debug("Removing bound token for path: %s", vmItemValue.getPath());
                    // Just track this removal for now - we'll remove it at the end
                    removals.push(vmItemValue);
                }
                else
                {
                    logger.error("VIEW MODEL SYNC WARNING: Attempt to remove object property or array element, but it wasn't found, path: %s", path);
                }
            }
        }

        // Remove all tokens indicated as removed
        for (var i = 0; i < removals.length; i++)
        {
            removals[i].remove();
        }

        logger.debug("View model after processing updates: %s", this._rootObject);
    }

    if (updateView)
    {
        this.updateViewFromViewModel(bindingUpdates);
    }
}

// This is called when a value change is triggered from the UX, specifically when the control calls
// the UpdateValue member of it's ValueBinding.  We will change the value, record the change, and
// update any binding that depends on this value.  This is the mechanism that allows for "client side
// dynamic binding".
//
ViewModel.prototype.updateViewModelFromView = function (bindingContext, getValue)
{ 
    if (this._updatingView)
    {
        // When we update the view from the view model, the UX generates a variety of events to indicate
        // that values changed (text changed, list contents changed, selection changed, etc).  We don't 
        // want those events to trigger a view model update (and mark as dirty), so we bail here.  This 
        // check is not sufficient (by itself), since some of these events can be posted and will show up
        // asynchronously, so we do some other checks, but this is quick and easy and catches most of it.
        //
        return;
    }

    var newValue = getValue();
    var currentValue = bindingContext.getValue();
    if (newValue === currentValue)
    {
        // Only record changes and update dependant UX objects for actual value changes - some programmatic 
        // changes to set the view to the view model state will trigger otherwise unidentifiable change events,
        // and this check will weed those out (if they got by the _updatingView check above).
        //
        return;
    }

    // Update the view model
    //
    var rebindRequired = bindingContext.setValue(newValue);

    // Find the ValueBinding that triggered this update and mark it as dirty...
    //
    for (var i = 0; i < this._valueBindings.length; i++)
    {
        if (this._valueBindings[i].getBindingContext() == bindingContext)
        {
            // logger.Debug("Marking dirty - binding with path: {0}", bindingContext.BindingPath);
            this._valueBindings[i].setIsDirty(true);
        }
    }

    // Process all of the rest of the bindings (rebind and update view as needed)...
    //
    var bindingUpdates = [];
    bindingUpdates.push(new BindingUpdate(bindingContext.getBindingPath(), rebindRequired));
    this.updateViewFromViewModel(bindingUpdates, bindingContext);
}

ViewModel.prototype.isDirty = function()
{
    for (var i = 0; i < this._valueBindings.length; i++) 
    {
        if (this._valueBindings[i].isDirty())
        {
            return true;
        }
    }
    return false;
}

ViewModel.prototype.collectChangedValues = function()
{
    var vmDeltas = {};

    for (var i = 0; i < this._valueBindings.length; i++) 
    {
        var valueBinding = this._valueBindings[i];

        if (valueBinding.isDirty())
        {
            var path = valueBinding.getBindingContext().getBindingPath();
            var value = valueBinding.getBindingContext().getValue();
            if (value != null)
            {
                logger.debug("Changed view model item - path: %s - value: %s", path, value);
                vmDeltas[path] = value;
            }
            else
            {
                logger.info("No binding context value for element at path: %s, change ignored", path);
            }
            valueBinding.setIsDirty(false);
        }
    }

    return vmDeltas;
}

module.exports = ViewModel;
