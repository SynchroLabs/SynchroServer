var logger = require('log4js').getLogger("state-manager");

var ViewModel = require('./view-model');
var JToken = require('./json');
var PropertyValue = require('./binding').PropertyValue;

var StateManager = function(appManager, app, transport, deviceMetrics)
{
    this._viewModel = new ViewModel();

    this._appManager = appManager;
    this._app = app;
    this._appDefinition = app.getAppDefinition();
    this._transport = transport;
    this._transport.setDefaultHandlers(this.processResponseAsync.bind(this), this.processRequestFailure.bind(this));

    this._deviceMetrics = deviceMetrics;

    this._transactionNumber = 1;

    this._path = null;
    this._instanceId = null;
    this._instanceVersion = null;
    this._isBackSupported = false;

    this._onProcessPageView = null;
    this._onProcessMessageBox = null;
    this._onProcessLaunchUrl = null;
}

StateManager.prototype.getNewTransactionId = function() 
{ 
    return this._transactionNumber++; 
}

StateManager.prototype.isBackSupported = function()
{
    return this._isBackSupported;
}

StateManager.prototype.isOnMainPath = function()
{
    return ((this._path != null) && (this._appDefinition != null) && (this._path == this._appDefinition.get("main")));
}

StateManager.prototype.getViewModel = function()
{ 
    return this._viewModel; 
}

StateManager.prototype.getDeviceMetrics = function()
{ 
    return this._deviceMetrics; 
}

StateManager.prototype.setProcessingHandlers = function(onProcessPageView, onProcessMessageBox, onProcessLaunchUrl)
{
    this._onProcessPageView = onProcessPageView;
    this._onProcessMessageBox = onProcessMessageBox;
    this._onProcessLaunchUrl = onProcessLaunchUrl;
}

StateManager.prototype.getPackageDeviceMetrics = function()
{
    var deviceMetrics =
    {
        "clientName": this._deviceMetrics.getClientName(),
        "clientVersion": this._deviceMetrics.getClientVersion(),
        "os": this._deviceMetrics.getOS(),
        "osName": this._deviceMetrics.getOSName(),
        "deviceName": this._deviceMetrics.getDeviceName(),
        "deviceType": this._deviceMetrics.getDeviceType(), // .ToString(),
        "deviceClass": this._deviceMetrics.getDeviceClass(), //.ToString(),
        "userAgent": this._deviceMetrics.getUserAgent(), //.ToString(),
        "naturalOrientation": this._deviceMetrics.getNaturalOrientation(), //.ToString(),
        "widthInches": this._deviceMetrics.getWidthInches(),
        "heightInches": this._deviceMetrics.getHeightInches(),
        "widthDeviceUnits": this._deviceMetrics.getWidthDeviceUnits(),
        "heightDeviceUnits": this._deviceMetrics.getHeightDeviceUnits(),
        "deviceScalingFactor": this._deviceMetrics.getDeviceScalingFactor(),
        "widthUnits": this._deviceMetrics.getWidthUnits(),
        "heightUnits": this._deviceMetrics.getHeightUnits(),
        "scalingFactor": this._deviceMetrics.getScalingFactor()
    }
    return deviceMetrics;
}

StateManager.prototype.getPackageViewMetrics = function(orientation)
{
    // Always Landscape 
    var viewMetrics =
    {
        "orientation": this._deviceMetrics.getCurrentOrientation(), //.ToString(),
        "widthInches": this._deviceMetrics.getViewWidthInches(),
        "heightInches": this._deviceMetrics.getViewHeightInches(),
        "widthUnits": this._deviceMetrics.getViewWidthUnits(),
        "heightUnits": this._deviceMetrics.getViewHeightUnits()
    }
    return viewMetrics;
}

StateManager.prototype.messageBox = function(title, message, buttonLabel, buttonCommand, onCommand)
{
    var messageBox = 
    {
        "title": title,
        "message": message,
        "options":
        [
            {
                "label": buttonLabel,
                "command": buttonCommand
            }
        ]
    };

    this._onProcessMessageBox(messageBox, function(command)
    {
        onCommand(command);
    });
}

StateManager.prototype.processRequestFailure = function(request, exception) // JToken / Error?
{
    logger.warn("Got request failure for request: %s", request);

    var self = this;
    this.messageBox("Connection Error", "Error connecting to application server", "Retry", "retry", function(command)
    {
        logger.debug("Retrying request after user confirmation (%s)...", command);
        self._transport.sendMessage(self._app.getSessionId(), request);
    });
}

// Since the messageBox implementation on the web client is pluggable, we want to fully expand all possible token-encoded
// values before we call the messageBox implementation (since they shoudn't need to know about tokens).  We do that here.
//
StateManager.prototype.expandMessageBox = function(messageBox)
{
    var bindingContext = this._viewModel && this._viewModel.getRootBindingContext();

    if (messageBox["title"])
    {
        messageBox["title"] = PropertyValue.expandAsString(messageBox["title"], bindingContext);
    }

    if (messageBox["message"])
    {
        messageBox["message"] = PropertyValue.expandAsString(messageBox["message"], bindingContext);
    }

    if (messageBox["options"])
    {
        for (var i = 0; i < messageBox["options"].length; i++)
        {
            var option = messageBox["options"][i];
            if (option["label"])
            {
                option["label"] = PropertyValue.expandAsString(option["label"], bindingContext);
            }
            if (option["command"])
            {
                option["command"] = PropertyValue.expandAsString(option["command"], bindingContext);
            }
        }
    }
}

StateManager.prototype.processResponseAsync = function(responseAsJSON) // JToken
{
    logger.info("Got response: %s", JSON.stringify(responseAsJSON));

    if (responseAsJSON["NewSessionId"] != null)
    {
        var newSessionId = responseAsJSON["NewSessionId"];
        if (this._app.getSessionId() != null)
        {
            // Existing client SessionId was replaced by server.  Do we care?  Should we do something (maybe clear any
            // other client session state, if there was any).
            //
            logger.debug("Client session ID of: %s was replaced with new session ID: %s", this._app.getSessionId(), newSessionId);
        }
        else
        {
            logger.debug("Client was assigned initial session ID of: %s", newSessionId);
        }

        // SessionId was created/updated by server.  Record it and save state.
        //
        this._app.setSessionId(newSessionId);
        // !!! await this._appManager.saveState();
    }

    if (responseAsJSON["Error"] != null)
    {
        var jsonError = responseAsJSON["Error"];
        logger.warn("Response contained error: %s", jsonError["message"]);
        if (jsonError["name"] == "SyncError")
        {
            if (responseAsJSON["InstanceId"] == null)
            {
                // This is a sync error indicating that the server has no instance (do to a corrupt or
                // re-initialized session).  All we can really do here is re-initialize the app (clear
                // our local state and do a Page request for the app entry point).  
                //
                logger.error("ERROR - corrupt server state - need app restart");

                var self = this;
                this.messageBox("Synchronization Error", "Server state was lost, restarting application", "Restart", "restart", function (command)
                {
                    logger.warn("Corrupt server state, restarting application...");
                    self.sendAppStartPageRequestAsync();
                });

            }
            else if (this._instanceId == responseAsJSON["InstanceId"])
            {
                // The instance that we're on now matches the server instance, so we can safely ignore
                // the sync error (the request that caused it was sent against a previous instance).
            }
            else
            {
                // We got a sync error, and the current instance on the server is different that our
                // instance.  It's possible that the response with the new (correct) instance is still
                // coming, but unlikey (it would mean it had async/wait user code after page navigation,
                // which it should not, or that it somehow got sent out of order with respect to this
                // error response, perhaps over a separate connection that was somehow delayed, but 
                // will eventually complete).
                //
                // The best option in this situation is to request a Resync with the server...
                //
                logger.warn("ERROR - client state out of sync - need resync");
                this.sendResyncInstanceRequestAsync();
            }
        }
        else
        {
            // Some other kind of error (ClientError, ClientVersionError, or UserCodeError).
            //
            var userMessage = jsonError["userMessage"];
            var userMessageCaption = jsonError["userMessageCaption"] || "Synchro";

            if (userMessage != null)
            {
                // The server indicated a message to be displayed to the end user, so do that...
                //
                this.messageBox(userMessageCaption, userMessage, "Close", "close", function(command)
                {
                });
            }
            else
            {
                // Error with no specified user-appropriate message. 
                //
                // !!! Maybe we should allow the user to choose an option/button to click to get more details?
                //
                this.messageBox("Application Error", "The application experienced an error.  Please contact your administrator.", "Close", "close", function (command)
                {
                });
            }
        }

        return;
    }

    var updateRequired = false;

    if (responseAsJSON["App"] != null) // This means we have a new app
    {
        // Note that we already have an app definition from the MaaasApp that was passed in.  The App in this
        // response was triggered by a request at app startup for the current version of the app metadata 
        // fresh from the endpoint (which may have updates relative to whatever we stored when we first found
        // the app at this endpoint and recorded its metadata).
        //
        // !!! Do we want to update our stored app defintion (in MaaasApp, via the AppManager)?  Maybe only if changed?
        //
        this._appDefinition = responseAsJSON["App"];
        logger.info("Got app definition for: %s - %s", this._appDefinition["name"], this._appDefinition["description"]);
        this.sendAppStartPageRequestAsync();
        return;
    }
    else if ((responseAsJSON["ViewModel"] != null) && (responseAsJSON["View"] != null)) // ViewModel and View - means we have a new page/screen
    {
        this._instanceId = responseAsJSON["InstanceId"];
        this._instanceVersion = responseAsJSON["InstanceVersion"];

        var jsonViewModel = responseAsJSON["ViewModel"];

        this._viewModel.initializeViewModelData(new JToken(jsonViewModel));

        this._path = responseAsJSON["Path"];
        logger.info("Got ViewModel for new view - path: '%s', instanceId: %s, instanceVersion: %s", this._path, this._instanceId, this._instanceVersion);

        this._isBackSupported = responseAsJSON["Back"];

        var jsonPageView = responseAsJSON["View"];
        this._onProcessPageView(jsonPageView);

        // If the view model is dirty after rendering the page, then the changes are going to have been
        // written by new view controls that produced initial output (such as location or sensor controls).
        // We need to signal than a viewModel "Update" is required to get these changes to the server.
        //
        updateRequired = this._viewModel.isDirty();
    }
    else if (responseAsJSON["ViewModel"] != null) // ViewModel without View (resync)
    {
        var responseInstanceId = responseAsJSON["InstanceId"];
        if (responseInstanceId == this._instanceId)
        {
            this._instanceVersion = responseAsJSON["InstanceVersion"];

            var jsonViewModel = new JToken(responseAsJSON["ViewModel"]);

            this._viewModel.setViewModelData(jsonViewModel);

            logger.info("Got ViewModel resync for existing view - path: '%s', instanceId: %s, instanceVersion: %s", this._path, this._instanceId, this._instanceVersion);
            this._viewModel.updateViewFromViewModel();
        }
        else if (responseInstanceId < this._instanceId)
        {
            // Resync response was for a previous instance, so we can safely ignore it (we've moved on).
        }
        else
        {
            // Incorrect instance id on resync - For this to happen, we'd have to get a resync for a "future" instance (meaning one for which
            // we haven't seen the initial view/viewModel).  This should never happen, but if it does, it's not clear how to recover from it.
            // Requesting an "instance" resync might very well result in just hitting this case again repeatedy.  The only potential way out of
            // this (if it ever does happen) is to request the "big" resync.
            //
            logger.warn("ERROR - instance id mismatch (response instance id > local instance id), updates not applied - app resync requested");
            this.sendResyncRequestAsync();
            return;
        }
    }
    else // Updating existing page/screen
    {
        var responseInstanceId = responseAsJSON["InstanceId"];
        if (responseInstanceId == this._instanceId)
        {
            var responseInstanceVersion = responseAsJSON["InstanceVersion"];

            // You can get a new view on a view model update if the view is dynamic and was updated
            // based on the previous command/update.
            //
            var viewUpdatePresent = (responseAsJSON["View"] != null);

            if (responseAsJSON["ViewModelDeltas"] != null)
            {
                logger.info("Got ViewModelDeltas for path: '%s' with instanceId: %s and instanceVersion: %s", this._path, responseInstanceId, responseInstanceVersion);

                if ((this._instanceVersion + 1) == responseInstanceVersion)
                {
                    this._instanceVersion++;

                    var jsonViewModelDeltas = new JToken(responseAsJSON["ViewModelDeltas"]);
                    // logger.Debug("ViewModel deltas: {0}", jsonViewModelDeltas);

                    // If we don't have a new View, we'll update the current view as part of applying
                    // the deltas.  If we do have a new View, we'll skip that, since we have to
                    // render the new View and do a full update anyway (below).
                    //
                    this._viewModel.updateViewModelData(jsonViewModelDeltas, !viewUpdatePresent);
                }
                else
                {
                    // Instance version was not one more than current version on view model update
                    //
                    logger.warn("ERROR - instance version mismatch, updates not applied - need resync");
                    this.sendResyncInstanceRequestAsync();
                    return;
                }
            }

            if (viewUpdatePresent)
            {
                if (this._instanceVersion == responseInstanceVersion)
                {
                    // Render the new page and bind/update it
                    //
                    this._path = responseAsJSON["Path"];
                    var jsonPageView = new JToken(responseAsJSON["View"]);
                    this._onProcessPageView(jsonPageView);
                    updateRequired = this._viewModel.isDirty();
                }
                else
                {
                    // Instance version was not correct on view update
                    //
                    logger.warn("ERROR - instance version mismatch on view update - need resync");
                    this.sendResyncInstanceRequestAsync();
                    return;
                }
            }
        }
        else if (responseInstanceId < this._instanceId)
        {
            // Response was for a previous instance, so we can safely ignore it (we've moved on).
        }
        else
        {
            // Incorrect instance id
            //
            logger.warn("ERROR - instance id mismatch (response instance id > local instance id), updates not applied - need resync");
            this.sendResyncInstanceRequestAsync();
            return;
        }
    }

    // Commands
    //
    if (responseAsJSON["MessageBox"] != null)
    {
        var self = this;
        logger.info("Launching message box...");
        var jsonMessageBox = responseAsJSON["MessageBox"];
        this.expandMessageBox(jsonMessageBox);
        this._onProcessMessageBox(jsonMessageBox, function (command)
        {
            logger.info("Message box completed with command: '%s'", command);
            self.sendCommandRequestAsync(command);
        });
    }
    else if (responseAsJSON["LaunchUrl"] != null)
    {
        var jsonLaunchUrl = responseAsJSON["LaunchUrl"];
        this._onProcessLaunchUrl(jsonLaunchUrl["primaryUrl"], jsonLaunchUrl["secondaryUrl"]);
    }

    if (responseAsJSON["NextRequest"] != null)
    {
        logger.debug("Got NextRequest, composing and sending it now...");
        var requestObject = responseAsJSON["NextRequest"]; // !!! .DeepClone();

        if (updateRequired)
        {
            logger.debug("Adding pending viewModel updates to next request (after request processing)");
            addDeltasToRequestObject(requestObject);
        }

        this._transport.sendMessage(this._app.getSessionId(), requestObject);
    }
    else if (updateRequired)
    {
        logger.debug("Sending pending viewModel updates (after request processing)");
        this.sendUpdateRequestAsync();
    }
}

StateManager.prototype.startApplicationAsync = function()
{
    logger.info("Loading Synchro application definition for app at: %s", this._app.getEndpoint());
    var requestObject =
    {
        "Mode": "AppDefinition",
        "TransactionId": 0
    };
    this._transport.sendMessage(null, requestObject);
}

StateManager.prototype.sendAppStartPageRequestAsync = function()
{
    this._path = this._appDefinition["main"];

    logger.info("Request app start page at path: '%s'", this._path);

    var requestObject =
    {
        "Mode": "Page",
        "Path": this._path,
        "TransactionId": this.getNewTransactionId(),
        "DeviceMetrics": this.getPackageDeviceMetrics(), // Send over device metrics (these won't ever change, per session)
        "ViewMetrics": this.getPackageViewMetrics(this._deviceMetrics.getCurrentOrientation()) // Send over view metrics
    };

    this._transport.sendMessage(this._app.getSessionId(), requestObject);
}

StateManager.prototype.sendResyncInstanceRequestAsync = function()
{
    logger.info("Sending resync for path: '%s'", this._path);

    var requestObject =
    {
        "Mode": "Resync",
        "Path": this._path,
        "TransactionId": this.getNewTransactionId(),
        "InstanceId": this._instanceId,
        "InstanceVersion": this._instanceVersion
    };

    this._transport.sendMessage(this._app.getSessionId(), requestObject);
}

StateManager.prototype.addDeltasToRequestObject = function(requestObject)
{
    var vmDeltas = this._viewModel.collectChangedValues();

    var keys = Object.keys(vmDeltas);
    if (keys.length > 0)
    {
        var deltas = [];
        for (var i = 0; i < keys.length; i++)
        {
            deltas.push(
            {
                "path": keys[i],
                "value": JSON.parse(vmDeltas[keys[i]].toJson()) // Was .deepClone in .NET - here we JSON round-trip to produce a JavaScript object
            });
        }

        requestObject["ViewModelDeltas"] = deltas;

        return true;
    }

    return false;
}

StateManager.prototype.sendUpdateRequestAsync = function()
{
    logger.debug("Process update for path: '%s'", this._path);

    // We check dirty here, even though addDeltas is a noop if there aren't any deltas, in order
    // to avoid generating a new transaction id when we're not going to do a new transaction.
    //
    if (this._viewModel.isDirty())
    {
        var requestObject =
        {
            "Mode": "Update",
            "Path": this._path,
            "TransactionId": this.getNewTransactionId(),
            "InstanceId": this._instanceId,
            "InstanceVersion": this._instanceVersion
        };

        if (this.addDeltasToRequestObject(requestObject))
        {
            // Only going to send the updates if there were any changes...
            this._transport.sendMessage(this._app.getSessionId(), requestObject);
        }
    }
}

StateManager.prototype.sendCommandRequestAsync = function(command, parameters)
{
    logger.info("Sending command: '%s' for path: '%s'", command, this._path);

    parameters == parameters || null;

    var requestObject =
    {
        "Mode": "Command",
        "Path": this._path,
        "TransactionId": this.getNewTransactionId(),
        "InstanceId": this._instanceId,
        "InstanceVersion": this._instanceVersion,
        "Command": command

    };

    if (parameters != null)
    {
        requestObject["Parameters"] = parameters;
    }

    this.addDeltasToRequestObject(requestObject);

    this._transport.sendMessage(this._app.getSessionId(), requestObject);
}

StateManager.prototype.sendBackRequestAsync = function()
{
    logger.info("Sending 'back' for path: '%s'", this._path);

    var requestObject =
    {
        "Mode": "Back",
        "Path": this._path,
        "TransactionId": this.getNewTransactionId(),
        "InstanceId": this._instanceId,
        "InstanceVersion": this._instanceVersion
    };

    this._transport.sendMessage(this._app.getSessionId(), requestObject);
}

StateManager.prototype.sendViewUpdateAsync = function(orientation)
{
    logger.info("Sending ViewUpdate for path: '%s'", this._path);

    // Send the updated view metrics 
    var requestObject =
    {
        "Mode": "ViewUpdate",
        "Path": this._path,
        "TransactionId": this.getNewTransactionId(),
        "InstanceId": this._instanceId,
        "InstanceVersion": this._instanceVersion,
        "ViewMetrics": this.getPackageViewMetrics(orientation)
    };

    this._transport.sendMessage(this._app.getSessionId(), requestObject);
}

// If your app has a session, but no other state, such as on recovery from tombstoning, you 
// can call this method instead of startApplicationAsync().  The server will respond with the
// full state required to resume your app.
//
// This method should only be called in a restart from tombstoning state.  For example, if a 
// user had navigated into the app and then shut it down via the operating system, when they 
// restart they do not expect to return to where they were (as they would with this method), 
// they expect to return to the entry sreen of the app.
//
StateManager.prototype.sendResyncRequestAsync = function()
{
    logger.info("Sending resync (no path/instance)");

    var requestObject =
    {
        "Mode": "Resync",
        "TransactionId": this.getNewTransactionId()
    };

    this._transport.sendMessage(this._app.getSessionId(), requestObject);
}

module.exports = StateManager;
