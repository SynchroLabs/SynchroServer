var logger = require('log4js').getLogger("web-page-view");

var lodash = require('lodash');

var PageView = require('./page-view');
var WebControlWrapper = require('../controls/web-control-wrapper');
var PropertyValue = require('./binding').PropertyValue;

var WebPageView = function(stateManager, viewModel, page, contentControl, doBackMenuCallback) //  page is "document" and contentControl is div container for app
{
    this.base = PageView;
    this.base(stateManager, viewModel, doBackMenuCallback);

    this._rootControlWrapper = new WebControlWrapper(this, this._stateManager, this._viewModel, this._viewModel.getRootBindingContext(), contentControl);

    window.onpopstate = this.onPopState.bind(this);

    this._navStack = [];
    this._lastPoppedTo = null;
    this._visitTriggeredGo = false;
}
WebPageView.prototype = Object.create(PageView.prototype);

WebPageView.prototype.onPopState = function(event)
{
    // This gets called when the user navigates within our page system - and in some browsers (Safari), when the page initially loads.
    // If the user hits "Back" and the Synchro page supports back, we make that work here.  However, the user may also go back more
    // than one history position (via the history dropdown in the browser), or they may go forward one or more positions.  Those cases
    // are not supported by Synchro, so we warn the user and undo the attempted navigation attempts.
    //

    if (this._visitTriggeredGo)
    {
        logger.info("onPopState was triggered by page visit history.go() call, resetting and ignoring");
        this._visitTriggeredGo = false;
        return;
    }

    if (event.state && (event.state.index != undefined))
    {
        var currentIndex = this._navStack.length - 1;

        if (event.state.index == (currentIndex - 1))
        {
            // Normal "back" navigation
            //
            logger.info("Back navigation attempted");
            if (this.goBack())
            {
                logger.info("goBack done");
                this._navStack.pop();
                this._lastPoppedTo = this._navStack[this._navStack.length -1];
            }
            else
            {
                logger.error("Back not supported or failed");
            }
        }
        else if (event.state.index < (currentIndex - 1))
        {
            // Multiple "back" navigation
            //
            // If we go back more than one page, push the necessary pages from navStack to get back to where we were (and warn the user
            // that multiple back navigation is not supported)
            //
            logger.info("Multiple back navigation attempted, history.go(%d)", currentIndex  - event.state.index);
            alert("Navigating backward more than one page via the browser is not supported.\n\nAttempted navigation cancelled.");
            history.go(currentIndex - event.state.index);
        }
        else if (event.state.index > currentIndex)
        {
            // Forward navigation (maybe be multiple forward navigation)
            //
            // If we go forward, do a history.go() to get back to where we were (and warn the user that forward navigation is not supported)
            //
            logger.info("Forward navigation attempted, history.go(%d)", currentIndex - event.state.index);
            alert("Navigating forward via the browser is not supported.\n\nAttempted navigation cancelled.");
            history.go(currentIndex - event.state.index);
        }
        else // event.state.index == currentIndex
        {
            logger.info("Got onpopstate with index equal to current index (this happens when we block invalid nav by doing a history.go() to get back to where we started)")
        }
    }
    else
    {
        logger.info("Got onpopstate event with no index, state was:", event.state);
    }
}

WebPageView.prototype.visitingPage = function()
{
    var path = this._stateManager._path;

    if (this._lastPoppedTo && (path == this._lastPoppedTo.path))
    {
        // A page was popped off of the browser history and our navStack by the Back button (onpopstate), and the page we got is that page...
        //
        logger.info("Page being loaded was page last popped to, no nav action required");
        this._lastPoppedTo = null;
    }
    else
    {
        if (this._navStack.length == 0)
        {
            if (history.state && (history.state.index > 0))
            {
                // If we have an empty nav stack and we have a state.index that is > 0, then that means someone navigated from outside of
                // this page (either forward or backward) to a location inside of this page other than the topmost location.  We have to
                // move up the browser history to the top of our app section.
                //
                logger.info("Navigated from outside of page to non-topmost location, moving to top of history for page");
                this._visitTriggeredGo = true;
                history.go(history.state.index * -1);
            }
            else
            {
                // We're on the top page
                //
                if ((history.state == null) || !location.hash)
                {
                    // If page has no state or no hash, then we update the state and hash
                    logger.info("No state and/or location.hash, adding hash and replacing state for path:", path);
                    history.replaceState({ index: 0, path: path }, this._pageTitle, "#" + path);
                }
                this._navStack.push({ path: path, title: this._pageTitle });
            }
        }
        else
        {
            // Our nav stack is not empty.  See if we are navigating back (to a path on the navStack) or forward (to a new path)
            //
            var navStackPos = lodash.findIndex(this._navStack, { path: path });
            if (navStackPos == -1)
            {
                // Navigating to a new page
                //
                logger.info("Navigating to a new page - new path: %s, current location.hash: %s", path, location.hash);
                history.pushState({ index: this._navStack.length, path: path }, this._pageTitle, "#" + path);
                this._navStack.push({ path: path, title: this._pageTitle });
            }
            else
            {
                // Navigating back to a page on the stack
                //

                // If _lastPoppedTo is set and didn't match the path, it means we're popping past it below...
                this._lastPoppedTo = null; 

                var diff = navStackPos - this._navStack.length + 1;
                logger.info("Popping back to previous page via go(%d) for path: %s, navStack:", diff, path, this._navStack);
                this._navStack.length = navStackPos + 1; // Truncate - leave the page that we're navigating to on the navStack, remove anything below that
                this._visitTriggeredGo = true;
                history.go(diff);
            }
        }
    }
}

// From the original code - these abstract functions will be implemented by the derived class
//
/*
public abstract ControlWrapper CreateRootContainerControl(JObject controlSpec);
public abstract void ClearContent();
public abstract void SetContent(ControlWrapper content);
*/

WebPageView.prototype.createRootContainerControl = function(controlSpec)
{
    return WebControlWrapper.createControl(this._rootControlWrapper, this._viewModel.getRootBindingContext(), controlSpec);
}

WebPageView.prototype.clearContent = function()
{
    logger.info("Clear content");

    var contentControl = this._rootControlWrapper._control; // <div>
    contentControl.innerHTML = '';
}

WebPageView.prototype.setContent = function(content) // content is ControlWrapper
{
    this.visitingPage();

    logger.info("Set content for page: %s at path: %s", this._pageTitle, this._stateManager._path);

    var contentControl = this._rootControlWrapper._control; // <div>
    if (content != null)
    {
        contentControl.appendChild(content._control);
    }
}

// !!! This is a terrible implementation of processMessageBox that uses the browser alert() and confirm() modal popups.
//     Ideally, you want something that looks nice, has an optional title, and supports a variable number of custom-labelled
//     buttons.  This is something that needs to be pluggable so that the app developer can use their own web UX framework
//     to do this (maybe we could do a sample implementation using a web UX framework of our choosing to show how).
//
WebPageView.prototype.processMessageBox = function(messageBox, onCommand) // onCommand is CommandHandler
{
    logger.info("MessageBox:", JSON.stringify(messageBox, null, 4));

    var title = messageBox["title"] ? PropertyValue.expandAsString(messageBox["title"], this._viewModel.getRootBindingContext()) : null; 
    var message = PropertyValue.expandAsString(messageBox["message"], this._viewModel.getRootBindingContext());

    // Each messageBox[option] represents a button, and has a 'label' attribute and optional 'command' attribute (either of which
    // may contain tokens, so will need to have expandAsString called on them).
    //
    if (messageBox.options && messageBox.options.length > 1)
    {
        // Multiple options
        //
        // !!! Confirm will give us "Ok" and "Cancel" and those may or may not map to the first two commands.  This will have to do
        //     until we have a custom dialog that supports the option labels/commands.
        //
        if (confirm((title ? title + "\n\n" : "") + message))
        {
            // OK
            if (messageBox.options[0].command)
            {
                onCommand(PropertyValue.expandAsString(messageBox.options[0].command), this._viewModel.getRootBindingContext());
            }
        }
        else
        {
            // Cancel
            if (messageBox.options[1].command)
            {
                onCommand(PropertyValue.expandAsString(messageBox.options[1].command), this._viewModel.getRootBindingContext());
            }
        }
    }
    else
    {
        // No options, or single option
        //
        alert((title ? title + "\n\n" : "") + message);
        if (messageBox.options && (messageBox.options.length == 1) && messageBox.options[0].command)
        {
            onCommand(PropertyValue.expandAsString(messageBox.options[0].command), this._viewModel.getRootBindingContext());
        }
    }
}

WebPageView.prototype.processLaunchUrl = function(primaryUrl, secondaryUrl)
{
    // !!! There doesn't seem to be great way to determine if a scheme is supported.  Maybe we just say the browser only
    //     supports http/https (others?).
    //
    logger.info("Launch URL:", primaryUrl);
    window.open(primaryUrl, '_blank');
}

module.exports = WebPageView;
