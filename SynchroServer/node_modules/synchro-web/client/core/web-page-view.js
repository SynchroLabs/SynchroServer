var logger = require('log4js').getLogger("web-page-view");

var PageView = require('./page-view');
var WebControlWrapper = require('../controls/web-control-wrapper');
var PropertyValue = require('./binding').PropertyValue;

var WebPageView = function(stateManager, viewModel, page, contentControl, doBackMenuCallback) //  page is "document" and contentControl is div container for app
{
    this.base = PageView;
    this.base(stateManager, viewModel, doBackMenuCallback);

    this._rootControlWrapper = new WebControlWrapper(this, this._stateManager, this._viewModel, this._viewModel.getRootBindingContext(), contentControl);
}
WebPageView.prototype = Object.create(PageView.prototype);

// From the original code - these abstract functions will be implemented by the derived class
//
/*
public abstract ControlWrapper CreateRootContainerControl(JObject controlSpec);
public abstract void ClearContent();
public abstract void SetContent(ControlWrapper content);
*/

WebPageView.prototype.createRootContainerControl = function(controlSpec)
{
    return WebControlWrapper.createControl(this._rootControlWrapper, this._viewModel.getRootBindingContext(), controlSpec);
}

WebPageView.prototype.clearContent = function()
{
    logger.info("Clear content");
    var contentControl = this._rootControlWrapper._control; // <div>
    contentControl.innerHTML = '';
}

WebPageView.prototype.setContent = function(content) // content is ControlWrapper
{
    logger.info("Set content");
    var contentControl = this._rootControlWrapper._control; // <div>

    if (content != null)
    {
        contentControl.appendChild(content._control);
    }
}

// !!! This is a terrible implementation of processMessageBox that uses the browser alert() and confirm() modal popups.
//     Ideally, you want something that looks nice, has an optional title, and supports a variable number of custom-labelled
//     buttons.  This is something that needs to be pluggable so that the app developer can use their own web UX framework
//     to do this (maybe we could do a sample implementation using a web UX framework of our choosing to show how).
//
WebPageView.prototype.processMessageBox = function(messageBox, onCommand) // onCommand is CommandHandler
{
    logger.info("MessageBox:", JSON.stringify(messageBox, null, 4));

    var title = messageBox["title"] ? PropertyValue.expandAsString(messageBox["title"], this._viewModel.getRootBindingContext()) : null; 
    var message = PropertyValue.expandAsString(messageBox["message"], this._viewModel.getRootBindingContext());

    // Each messageBox[option] represents a button, and has a 'label' attribute and optional 'command' attribute (either of which
    // may contain tokens, so will need to have expandAsString called on them).
    //
    if (messageBox.options && messageBox.options.length > 1)
    {
        // Multiple options
        //
        // !!! Confirm will give us "Ok" and "Cancel" and those may or may not map to the first two commands.  This will have to do
        //     until we have a custom dialog that supports the option labels/commands.
        //
        if (confirm((title ? title + "\n\n" : "") + message))
        {
            // OK
            if (messageBox.options[0].command)
            {
                onCommand(PropertyValue.expandAsString(messageBox.options[0].command), this._viewModel.getRootBindingContext());
            }
        }
        else
        {
            // Cancel
            if (messageBox.options[1].command)
            {
                onCommand(PropertyValue.expandAsString(messageBox.options[1].command), this._viewModel.getRootBindingContext());
            }
        }
    }
    else
    {
        // No options, or single option
        //
        alert((title ? title + "\n\n" : "") + message);
        if (messageBox.options && (messageBox.options.length == 1) && messageBox.options[0].command)
        {
            onCommand(PropertyValue.expandAsString(messageBox.options[0].command), this._viewModel.getRootBindingContext());
        }
    }
}

WebPageView.prototype.processLaunchUrl = function(primaryUrl, secondaryUrl)
{
    // !!! There doesn't seem to be great way to determine if a scheme is supported.  Maybe we just say the browser only
    //     supports http/https (others?).
    //
    logger.info("Launch URL:", primaryUrl);
    window.open(primaryUrl, '_blank');
}

module.exports = WebPageView;
