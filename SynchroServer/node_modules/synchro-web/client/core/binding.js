var logger = require('log4js').getLogger("binding");

var JToken = require('./json');
var TokenConverter = require('./token-converter');

var lodash = require('lodash');

// Static function: getCanonicalBindingSpec
//
// Binding is specified in the "binding" attribute of an element.  For example, binding: { value: "foo" } will bind the "value"
// property of the control to the "foo" value in the current binding context.  For controls that can call commands, the command
// handlers are bound similarly, for example, binding: { onClick: "someCommand" } will bind the onClick action of the control to
// the "someCommand" command.
//
// A control type may have a default binding attribute, so that a simplified syntax may be used, where the binding contains a
// simple value to be bound to the default binding attribute of the control.  For example, an edit control might use binding: "username"
// to bind the default attribute ("value") to username.  A button might use binding: "someCommand" to bind the default attribute ("onClick")
// to someCommand.
//
// This function extracts the binding value, and if the default/shorthand notation is used, expands it to a fully specified binding object.
//
//     For example, for an edit control with a default binding attribute of "value" a binding of:
//
//       binding: "username"
//
//         becomes
//
//       binding: {value: "username"}
//
//     For commands:
//
//       binding: "doSomething"
//
//         becomes
//
//       binding: { onClick: "doSomething" }
//
//         becomes
//
//       binding: { onClick: { command: "doSomething" } }
//
//     Also (default binding atttribute is 'onClick', which is also in command attributes list):
//
//       binding: { command: "doSomething" value: "theValue" }
//
//         becomes
//
//       binding: { onClick: { command: "doSomething", value: "theValue" } }
//
function getCanonicalBindingSpec(controlSpec, defaultBindingAttribute, commandAttributes)
{
    var bindingObject = null;

    var defaultAttributeIsCommand = false;
    if (commandAttributes)
    {
        defaultAttributeIsCommand = commandAttributes.indexOf(defaultBindingAttribute) != -1;
    }

    var bindingSpec = controlSpec["binding"];

    if (bindingSpec != null)
    {
        if (typeof bindingSpec === 'object')
        {
            // Encountered an object spec, return that (subject to further processing below)
            //
            bindingObject = lodash.cloneDeep(bindingSpec);

            if (defaultAttributeIsCommand && (bindingObject["command"] != null))
            {
                // Top-level binding spec object contains "command", and the default binding attribute is a command, so
                // promote { command: "doSomething" } to { defaultBindingAttribute: { command: "doSomething" } }
                //
                var command = bindingObject;
                bindingObject = {};
                bindingObject[defaultBindingAttribute] = command; 
            }
        }
        else
        {
            // Top level binding spec was not an object (was an array or value), so promote that value to be the value
            // of the default binding attribute
            //
            bindingObject = { };
            bindingObject[defaultBindingAttribute] = lodash.cloneDeep(bindingSpec);
        }

        // Now that we've handled the default binding attribute cases, let's look for commands that need promotion...
        //
        if (commandAttributes != null)
        {
            for (var i = 0; i < commandAttributes.length; i++)
            {
                var commandAttribute = commandAttributes[i];
                // Processing a command (attribute name corresponds to a command)
                //
                if ((bindingObject[commandAttribute] !== undefined) && (typeof bindingObject[commandAttribute] !== 'object'))
                {
                    // If attribute value is simple value type, promote "attributeValue" to { command: "attributeValue" }
                    //
                    bindingObject[commandAttribute] = { "command": bindingObject[commandAttribute] };
                }
            }
        }

        logger.debug("Found binding object: %s", JSON.stringify(bindingObject));
    }
    else
    {
        // No binding spec
        bindingObject = {};
    }

    return bindingObject;
}


// Internal object: BoundAndPossiblyResolvedToken
//
// PropertyValue objects maintain a list of things that provide values to the expanded output.  Some of
// things things are binding contexts that will be evalutated each time the underlying value changes (one-way
// bindings), but some of them will be resolved based on the initial view model contents at the time of
// creation (one-time bindings).  This object accomodates both states and provides a convenient way to determine
// which type of binding it is, and to extract the resolved/expanded value without needing to know which type
// of binding it is.
//
var BoundAndPossiblyResolvedToken = function(bindingContext, oneTime, negated, formatSpec)
{
    this._resolvedValue = null;
    this._bindingContext = bindingContext;

    // OK - The way negation is handled here is pretty crude.  The idea is that in the future we will support
    // complex value converters, perhaps even functions which themselves have more than one token as parameters.
    // So a more generalized concept of a value converter (delegate) passed in here from the parser and used
    // to produce the resolved value would be better.
    //
    this._negated = negated;

    // Here is the list of .NET number format specifiers: http://msdn.microsoft.com/en-us/library/dwhawy9k(v=vs.110).aspx
    //
    // In pratice I think D, E, F, N, P, and X are what we support.
    //
    this._formatSpec = formatSpec; // If present, this is the .NET format specifier (whatever came after the colon)

    if (oneTime)
    {
        // Since we're potentially storing this over time and don't want any underlying view model changes
        // to impact this value, we need to clone it.
        //
        var value = this._bindingContext.getValue();
        if (value)
        {
            this._resolvedValue = value.deepClone();
        }

        if (this._negated)
        {
            this._resolvedValue = new JToken(!TokenConverter.toBoolean(this._resolvedValue));
        }
    }
}

BoundAndPossiblyResolvedToken.prototype.getBindingContext = function()
{
    return this._bindingContext;
}

BoundAndPossiblyResolvedToken.prototype.isResolved = function()
{
    return this._resolvedValue != null;
}

BoundAndPossiblyResolvedToken.prototype.getResolvedValue = function()
{
    if (this._resolvedValue != null)
    {
        return this._resolvedValue;
    }
    else
    {
        var resolvedValue = this._bindingContext.getValue();
        if (this._negated)
        {
            resolvedValue = new JToken(!TokenConverter.toBoolean(resolvedValue));
        }
        return resolvedValue;
    }
}

function addThousandsSep(str)
{
    // !!! Number.toLocaleString is not well supported in browsers (and not at all in Mocha tests), so
    //     we're gonna use this to throw in comma seps for now.
    //

    // Remove leading sign
    var sign = "";
    if (str.match(/^[+-].*/))
    {
        sign = str[0];
        str = str.slice(1);
    }

    // Just separate the whole number side
    var parts = str.split(".");
    var result = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");

    if (parts[1])
    {
        // Add decimal part back in
        result += "." + parts[1];
    }

    return sign + result;
}

function pad(str, digits)
{
    digits -= str.length;
    if (digits > 0)
    {
        for (var i = 0; i < digits; i++)
        {
            str = "0" + str;
        }
    }
    return str;
}

BoundAndPossiblyResolvedToken.prototype.getResolvedValueAsString = function()
{
    if (this._formatSpec != null)
    {
        var numericValue = TokenConverter.toDouble(this.getResolvedValue());
        if (numericValue != null)
        {
            var formatSpecifier = this._formatSpec[0];
            var precision = Number(this._formatSpec[1]) || null;

            switch (formatSpecifier)
            {
                case 'D': // Decimal (int)
                case 'd':
                {
                    numericValue = Math.round(numericValue);
                    var decimalString = String(numericValue);
                    if (numericValue > 0)
                    {
                        decimalString = pad(decimalString, precision);
                    }
                    return decimalString;
                }
                break;

                case 'X': // Hex (uint)
                case 'x':
                {
                    numericValue = Math.round(numericValue);
                    var hexString = pad(numericValue.toString(16), precision);
                    if (formatSpecifier === 'X')
                    {
                        hexString = hexString.toUpperCase();
                    }
                    return hexString;
                }
                break;

                case 'E': // Exponential
                case 'e':
                {
                    if (precision === null)
                    {
                        precision = 2;
                    }
                    var exponentialString = String(numericValue.toExponential(precision));
                    if (formatSpecifier === 'E')
                    {
                        exponentialString = exponentialString.toUpperCase();
                    }
                    return exponentialString;
                }
                break;

                case 'F': // Fixed-point
                case 'f':
                {
                    if (precision === null)
                    {
                        precision = 2;
                    }
                    return String(numericValue.toFixed(precision));
                }
                break;

                case 'N': // Number
                case 'n':
                {
                    if (precision === null)
                    {
                        precision = 2;
                    }
                    return addThousandsSep(numericValue.toFixed(precision));

                }
                break;

                case 'P': // Percent
                case 'p':
                {
                    if (precision === null)
                    {
                        precision = 2;
                    }
                    return addThousandsSep((numericValue * 100).toFixed(precision)) + "%";
                }
                break;
            }
        }
    }

    return TokenConverter.toString(this.getResolvedValue());
}

// Exported object: PropertyValue
//
// Property values consist of a string containing one or more "tokens", where such tokens are surrounded by curly brackets.
// If the token is preceded with ^, then it is a "one-time" binding, otherwise it is a "one-way" (continuously updated)
// binding.  Tokens can be negated (meaning their value will be converted to a boolean, and that value inverted) when 
// preceded with !.  If both one-time binding and negation are specified for a token, the one-time binding indicator must
// appear first.
// 
// Tokens that will resolve to numeric values may be followed by a colon and subsequent format specifier, using the .NET
// Framework 4.5 format specifiers for numeric values.
//
// For example: 
//
//    "The scaling factor is {^scalingFactor:P2}".  
//
// The token is a one-time binding that will resolve to a number and then be formatted as a percentage with two decimal places:
//
//    "The scaling factor is 140.00 %"
//
var PropertyValue = function(tokenString, bindingContext)
{
    var self = this;

    this._isExpression = false;

    this._boundTokens = []; // List of BoundAndPossiblyResolvedToken
    var tokenIndex = 0;

    if (/^eval\(.*\)$/.test(tokenString))
    {
        this._isExpression = true;
        tokenString = /^eval\((.*)\)$/.exec(tokenString)[1];
        logger.debug("Property value string is expression: %s", tokenString);
    }

    this._formatString = tokenString.replace(PropertyValue._braceContentsRE, function(match, openBrace, token, closeBrace)
    {
        if ((openBrace === "{") && (closeBrace === "}"))
        {
            // We found a token....

            // Parse out any format specifier
            //
            var format = null;
            if (token.indexOf(":") >= 0)
            {
                var result = token.split(':');
                token = result[0];
                format = result[1];
            }

            // Parse out and record any one-time binding indicator
            //
            var oneTimeBinding = false;
            if (token.indexOf("^") == 0)
            {
                token = token.slice(1);
                oneTimeBinding = true;
            }

            // Parse out and record negation indicator
            //
            var negated = false;
            if (token.indexOf("!") == 0)
            {
                token = token.slice(1);
                negated = true;
            }

            var boundToken = new BoundAndPossiblyResolvedToken(bindingContext.select(token), oneTimeBinding, negated, format);
            self._boundTokens.push(boundToken);

            // Expressions get var0, var1, etc, whereas format string gets {0}, {1}, etc.
            //
            var replacementToken = self._isExpression ? "var" + tokenIndex : "{" + tokenIndex + "}";
            tokenIndex++;

            return replacementToken;
        }
        else
        {
            if (openBrace === "{{")
            {
                openBrace = "{";
            }
            if (closeBrace === "}}")
            {
                closeBrace = "}";
            }
            return (openBrace ? openBrace : "") + (token ? token : "") + (closeBrace ? closeBrace : "");
        }
    });

    // Not de-escaping any escaped braces (see logic in expand, below)

    logger.debug("PropertyValue - isExpression: %s, formatString: %s", this._isExpression, this._formatString);
}

// Construct and return the unresolved binding contexts (the one-way bindings, excluding the one-time bindings)
//
PropertyValue.prototype.getBindingContexts = function()
{
    var bindingContexts = [];
    for (var i = 0; i < this._boundTokens.length; i++)
    {
        if (!this._boundTokens[i].isResolved())
        {
            bindingContexts.push(this._boundTokens[i].getBindingContext());
        }
    }
    return bindingContexts;
}

// To deal with "escaped" braces (double open braces), our brace contents regex caputes single or double open braces at the
// beginning or end of the token.  One other platforms with negative lookbehind and negative lookahead assertions, we can 
// skip matching, but no suck luck with JavaScript.  So we'll cast a wide net and match any possible token, and if it is delimited
// with double braces on either end, we skip the token replacement.
//
PropertyValue._braceContentsRE = /([{]?[{])?([^{}]*)?([}][}]?)?/g;

// From: https://github.com/joliss/js-string-escape/blob/master/index.js
//
function jsStringEscape(string) 
{
    return ('' + string).replace(/["'\\\n\r\u2028\u2029]/g, function (character) {
        // Escape all characters not included in SingleStringCharacters and
        // DoubleStringCharacters on
        // http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4
        switch (character) 
        {
            case '"':
            case "'":
            case '\\':
                return '\\' + character
            // Four possible LineTerminator characters need to be escaped:
            case '\n':
                return '\\n'
            case '\r':
                return '\\r'
            case '\u2028':
                return '\\u2028'
            case '\u2029':
                return '\\u2029'
        }
    });
}

PropertyValue.prototype.expand = function()
{
    var self = this;

    if (this._isExpression)
    {
        // Set up our bound tokens as JS variables
        //
        var evalStr = "";

        for (var i = 0; i < this._boundTokens.length; i++)
        {
            var resolvedValue = this._boundTokens[i].getResolvedValue();

            if (JToken.isBoolean(resolvedValue) || JToken.isNumber(resolvedValue))
            {
                evalStr += "var var" + i + " = " + resolvedValue.getValue() + ";\n";
            }
            else if (JToken.isNull(resolvedValue))
            {
                evalStr += "var var" + i + " = null;\n";
            }
            else
            {
                // In order to avoid code injection, we escape the string here when putting it into our script...
                //
                evalStr += "var var" + i + " = \"" + jsStringEscape(this._boundTokens[i].getResolvedValueAsString()) + "\";\n";
            }
        }

        evalStr += this._formatString;

        // Exec
        //
        try
        {
            logger.debug("Getting ready to eval: %s", evalStr);

            var result = eval(evalStr);
            logger.debug("Eval result: %s", result);

            if ((result === null) || (typeof result === 'number') || (typeof result === 'boolean') || (typeof result === 'string'))
            {
                return new JToken(result);
            }
            else
            {
                return new JToken(result.toString());
            }
        }
        catch (err)
        {
            logger.error("Exec error: %s", err.message);
            return new JToken(err.message);
        }
    }
    else if (this._formatString === "{0}")
    {
        // If there is a binding containing exactly a single token, then that token may resolve to
        // a value of any type (not just string), and we want to preserve that type, so we process
        // that special case here...
        //
        var token = this._boundTokens[0];
        return token.getResolvedValue();
    }
    else
    {
        // Otherwise we replace all tokens with the string representations of the values.
        //
        var i = 0;
        var result = this._formatString.replace(PropertyValue._braceContentsRE, function(match, openBrace, token, closeBrace)
        {
            // If we have a single-brace wrapped int that matches the position we expect (this skips de-escaped non-tokens)
            //
            if ((openBrace == "{") && (closeBrace == "}") && (Number(token) === i))
            {
                return self._boundTokens[i++].getResolvedValueAsString();
            }
            else
            {
                return match;
            }
        });

        return new JToken(result);
    }
}

// Static member functions

PropertyValue.containsBindingTokens = function(value)
{
    var anyMatch = false;

    value.replace(PropertyValue._braceContentsRE, function(match, openBrace, token, closeBrace)
    {
        if ((openBrace === "{") && (closeBrace === "}") && token)
        {
            anyMatch = true;
        }
        return match;
    });

    return anyMatch;
}

PropertyValue.expand = function(tokenString, bindingContext)
{
    var propertyValue = new PropertyValue(tokenString, bindingContext);
    return propertyValue.expand();
}

PropertyValue.expandAsString = function(tokenString, bindingContext)
{
    return TokenConverter.toString(PropertyValue.expand(tokenString, bindingContext));
}

// Exported object
//
var PropertyBinding = function(bindingContext, value, setViewValue)
{
    this._propertyValue = new PropertyValue(value, bindingContext);
    this._setViewValue = setViewValue;
}

PropertyBinding.prototype.updateViewFromViewModel = function()
{
    var value = this._propertyValue.expand();
    if (this._setViewValue != null)
    {
        this._setViewValue(value);
    }
    return value;
}

PropertyBinding.prototype.getBindingContexts = function()
{
    return this._propertyValue.getBindingContexts();
}

// Exported object
//
var ValueBinding = function(viewModel, bindingContext, getViewValue, setViewValue)
{
    this._viewModel = viewModel;
    this._bindingContext = bindingContext;
    this._getViewValue = getViewValue;
    this._setViewValue = setViewValue;
    this._isDirty = false;
}

ValueBinding.prototype.isDirty = function()
{
    return this._isDirty;
}

ValueBinding.prototype.setIsDirty = function(isDirty)
{
    this._isDirty = isDirty;
}

ValueBinding.prototype.updateViewModelFromView = function()
{
    this._viewModel.updateViewModelFromView(this._bindingContext, this._getViewValue);
}

ValueBinding.prototype.updateViewFromViewModel = function()
{
    if (this._setViewValue)
    {
        this._setViewValue(this._bindingContext.getValue());
    }
}

ValueBinding.prototype.getBindingContext = function()
{
    return this._bindingContext;
}

ValueBinding.prototype.setBindingContext = function(bindingContext)
{
    this._bindingContext = bindingContext;
}

// -- Exports --

// Static functions
//
exports.getCanonicalBindingSpec = getCanonicalBindingSpec;

// Objects
//
exports.PropertyValue = PropertyValue;
exports.ValueBinding = ValueBinding;
exports.PropertyBinding = PropertyBinding;
