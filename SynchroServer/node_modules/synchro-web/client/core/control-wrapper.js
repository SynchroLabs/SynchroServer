var logger = require('log4js').getLogger("control-wrapper");

var TokenConverter = require('./token-converter');
var binding = require('./binding');
var PropertyValue = binding.PropertyValue;
var CommandInstance = require('./command-instance');
var JToken = require('./json');

var ControlWrapper = function(stateManager, viewModel, bindingContext)
{
    this._stateManager = stateManager;
    this._viewModel = viewModel;
    this._bindingContext = bindingContext;
    this._styles = null;

    this._commands = {};         // Dictionary of string, CommandInstance
    this._valueBindings = {};    // Dictionary of string, ValueBinding
    this._propertyBindings = []; // List of PropertyBinding
    this._childControls = [];    // List of ControlWrapper

    this._isVisualElement = true;
}

ControlWrapper.ListSelectionMode =
{
    None: "None",
    Single: "Single",
    Multiple: "Multiple"
}

ControlWrapper.LocationStatus =
{
    Unknown:                 "Unknown",
    DeterminingAvailability: "DeterminingAvailability",
    Available:               "Available",
    NotAvailable:            "NotAvailable",
    PendingApproval:         "PendingApproval",
    NotApproved:             "NotApproved",
    Active:                  "Active",
    Failed:                  "Failed"
}

ControlWrapper.FontFaceType = 
{
    FONT_DEFAULT:   "default",
    FONT_SERIF:     "serif",
    FONT_SANSERIF:  "sanserif",
    FONT_MONOSPACE: "monospace"
}

ControlWrapper.Orientation =
{
    Horizontal: "Horizontal",
    Vertical:   "Vertical"
}

ControlWrapper.processStyles = function(controlSpec)
{
    if (controlSpec["style"])
    {
        return controlSpec["style"].split(/[ ,]/g);
    }
    return null;
}

ControlWrapper.prototype.processStyles = function(controlSpec)
{
    this._styles = ControlWrapper.processStyles(controlSpec);
}

ControlWrapper.prototype.isVisualElement = function()
{
    return this._isVisualElement;
}

ControlWrapper.prototype.getStateManager = function()
{
    return this._stateManager; 
}

ControlWrapper.prototype.getViewModel = function()
{
    return this._viewModel;
} 

ControlWrapper.prototype.getBindingContext = function()
{ 
    return this._bindingContext; 
}

ControlWrapper.prototype.getChildControls = function()
{
    return this._childControls; 
}

ControlWrapper.prototype.setCommand = function(commandName, commandInstance)
{
    this._commands[commandName] = commandInstance;
}

ControlWrapper.prototype.getCommand = function(commandName)
{
    if (this._commands.hasOwnProperty(commandName))
    {
        return this._commands[commandName];
    }
    return null;
}

ControlWrapper.prototype.setValueBinding = function(attribute, valueBinding)
{
    this._valueBindings[attribute] = valueBinding;
}

ControlWrapper.prototype.getValueBinding = function(attribute)
{
    return this._valueBindings[attribute];
}

//
// Value conversion helpers
//

ControlWrapper.getStarCount = function(starString)
{
    var starCnt = 0;
    if ((starString != null) && starString.match(/[*]$/))
    {
        starCnt = 1;
        var valueString = starString.replace("*","");
        if (valueString.length > 0)
        {
            starCnt = Number(valueString);
        }
    }

    return starCnt;
}

// Basic token conversions (these are members just because they're used very frequently in control classes
// and it's convenient to be able to call them via "this")
//

ControlWrapper.prototype.toString = function(token, defaultValue)
{
    defaultValue = defaultValue || "";
    return TokenConverter.toString(token, defaultValue);
}

ControlWrapper.prototype.toBoolean = function(token, defaultValue)
{
    defaultValue = defaultValue || false;
    return TokenConverter.toBoolean(token, defaultValue);
}

ControlWrapper.prototype.toDouble = function(value, defaultValue)
{
    defaultValue = defaultValue || 0;
    return TokenConverter.toDouble(value, defaultValue);
}

// Conversion functions to go from Maaas units or typographic points to device units
//
/*
public double ToDeviceUnits(Double value)
{
    return StateManager.DeviceMetrics.MaaasUnitsToDeviceUnits(value);
}

public double ToDeviceUnits(JToken value)
{
    return ToDeviceUnits(ToDouble(value));
}

public double ToDeviceUnitsFromTypographicPoints(JToken value)
{
    if (StateManager != null)
    {
        return ToDeviceUnits(StateManager.DeviceMetrics.TypographicPointsToMaaasUnits(ToDouble(value)));
    }
    else
    {
        // For test cases where we don't have a StateManager, just return the raw size
        return ToDouble(value);
    }
}
*/

ControlWrapper.prototype.toListSelectionMode = function(value, defaultSelectionMode)
{
    var selectionMode = defaultSelectionMode;
    if (defaultSelectionMode === undefined)
    {
        selectionMode = ControlWrapper.ListSelectionMode.Single
    }

    var selectionModeValue = this.toString(value);
    if (selectionModeValue == "None")
    {
        selectionMode = ControlWrapper.ListSelectionMode.None;
    }
    else if (selectionModeValue == "Single")
    {
        selectionMode = ControlWrapper.ListSelectionMode.Single;
    }
    else if (selectionModeValue == "Multiple")
    {
        selectionMode = ControlWrapper.ListSelectionMode.Multiple;
    }
    return selectionMode;
}

// Silverlight colors
//
// http://msdn.microsoft.com/en-us/library/system.windows.media.colors(v=vs.110).aspx
//
ControlWrapper.colorNames = 
{
    "AliceBlue": 0xFFF0F8FF,
    "AntiqueWhite": 0xFFFAEBD7,
    "Aqua": 0xFF00FFFF,
    "Aquamarine": 0xFF7FFFD4,
    "Azure": 0xFFF0FFFF,
    "Beige": 0xFFF5F5DC,
    "Bisque": 0xFFFFE4C4,
    "Black": 0xFF000000,
    "BlanchedAlmond": 0xFFFFEBCD,
    "Blue": 0xFF0000FF,
    "BlueViolet": 0xFF8A2BE2,
    "Brown": 0xFFA52A2A,
    "BurlyWood": 0xFFDEB887,
    "CadetBlue": 0xFF5F9EA0,
    "Chartreuse": 0xFF7FFF00,
    "Chocolate": 0xFFD2691E,
    "Coral": 0xFFFF7F50,
    "CornflowerBlue": 0xFF6495ED,
    "Cornsilk": 0xFFFFF8DC,
    "Crimson": 0xFFDC143C,
    "Cyan": 0xFF00FFFF,
    "DarkBlue": 0xFF00008B,
    "DarkCyan": 0xFF008B8B,
    "DarkGoldenrod": 0xFFB8860B,
    "DarkGray": 0xFFA9A9A9,
    "DarkGreen": 0xFF006400,
    "DarkKhaki": 0xFFBDB76B,
    "DarkMagenta": 0xFF8B008B,
    "DarkOliveGreen": 0xFF556B2F,
    "DarkOrange": 0xFFFF8C00,
    "DarkOrchid": 0xFF9932CC,
    "DarkRed": 0xFF8B0000,
    "DarkSalmon": 0xFFE9967A,
    "DarkSeaGreen": 0xFF8FBC8F,
    "DarkSlateBlue": 0xFF483D8B,
    "DarkSlateGray": 0xFF2F4F4F,
    "DarkTurquoise": 0xFF00CED1,
    "DarkViolet": 0xFF9400D3,
    "DeepPink": 0xFFFF1493,
    "DeepSkyBlue": 0xFF00BFFF,
    "DimGray": 0xFF696969,
    "DodgerBlue": 0xFF1E90FF,
    "Firebrick": 0xFFB22222,
    "FloralWhite": 0xFFFFFAF0,
    "ForestGreen": 0xFF228B22,
    "Fuchsia": 0xFFFF00FF,
    "Gainsboro": 0xFFDCDCDC,
    "GhostWhite": 0xFFF8F8FF,
    "Gold": 0xFFFFD700,
    "Goldenrod": 0xFFDAA520,
    "Gray": 0xFF808080,
    "Green": 0xFF008000,
    "GreenYellow": 0xFFADFF2F,
    "Honeydew": 0xFFF0FFF0,
    "HotPink": 0xFFFF69B4,
    "IndianRed": 0xFFCD5C5C,
    "Indigo": 0xFF4B0082,
    "Ivory": 0xFFFFFFF0,
    "Khaki": 0xFFF0E68C,
    "Lavender": 0xFFE6E6FA,
    "LavenderBlush": 0xFFFFF0F5,
    "LawnGreen": 0xFF7CFC00,
    "LemonChiffon": 0xFFFFFACD,
    "LightBlue": 0xFFADD8E6,
    "LightCoral": 0xFFF08080,
    "LightCyan": 0xFFE0FFFF,
    "LightGoldenrodYellow": 0xFFFAFAD2,
    "LightGray": 0xFFD3D3D3,
    "LightGreen": 0xFF90EE90,
    "LightPink": 0xFFFFB6C1,
    "LightSalmon": 0xFFFFA07A,
    "LightSeaGreen": 0xFF20B2AA,
    "LightSkyBlue": 0xFF87CEFA,
    "LightSlateGray": 0xFF778899,
    "LightSteelBlue": 0xFFB0C4DE,
    "LightYellow": 0xFFFFFFE0,
    "Lime": 0xFF00FF00,
    "LimeGreen": 0xFF32CD32,
    "Linen": 0xFFFAF0E6,
    "Magenta": 0xFFFF00FF,
    "Maroon": 0xFF800000,
    "MediumAquamarine": 0xFF66CDAA,
    "MediumBlue": 0xFF0000CD,
    "MediumOrchid": 0xFFBA55D3,
    "MediumPurple": 0xFF9370DB,
    "MediumSeaGreen": 0xFF3CB371,
    "MediumSlateBlue": 0xFF7B68EE,
    "MediumSpringGreen": 0xFF00FA9A,
    "MediumTurquoise": 0xFF48D1CC,
    "MediumVioletRed": 0xFFC71585,
    "MidnightBlue": 0xFF191970,
    "MintCream": 0xFFF5FFFA,
    "MistyRose": 0xFFFFE4E1,
    "Moccasin": 0xFFFFE4B5,
    "NavajoWhite": 0xFFFFDEAD,
    "Navy": 0xFF000080,
    "OldLace": 0xFFFDF5E6,
    "Olive": 0xFF808000,
    "OliveDrab": 0xFF6B8E23,
    "Orange": 0xFFFFA500,
    "OrangeRed": 0xFFFF4500,
    "Orchid": 0xFFDA70D6,
    "PaleGoldenrod": 0xFFEEE8AA,
    "PaleGreen": 0xFF98FB98,
    "PaleTurquoise": 0xFFAFEEEE,
    "PaleVioletRed": 0xFFDB7093,
    "PapayaWhip": 0xFFFFEFD5,
    "PeachPuff": 0xFFFFDAB9,
    "Peru": 0xFFCD853F,
    "Pink": 0xFFFFC0CB,
    "Plum": 0xFFDDA0DD,
    "PowderBlue": 0xFFB0E0E6,
    "Purple": 0xFF800080,
    "Red": 0xFFFF0000,
    "RosyBrown": 0xFFBC8F8F,
    "RoyalBlue": 0xFF4169E1,
    "SaddleBrown": 0xFF8B4513,
    "Salmon": 0xFFFA8072,
    "SandyBrown": 0xFFF4A460,
    "SeaGreen": 0xFF2E8B57,
    "SeaShell": 0xFFFFF5EE,
    "Sienna": 0xFFA0522D,
    "Silver": 0xFFC0C0C0,
    "SkyBlue": 0xFF87CEEB,
    "SlateBlue": 0xFF6A5ACD,
    "SlateGray": 0xFF708090,
    "Snow": 0xFFFFFAFA,
    "SpringGreen": 0xFF00FF7F,
    "SteelBlue": 0xFF4682B4,
    "Tan": 0xFFD2B48C,
    "Teal": 0xFF008080,
    "Thistle": 0xFFD8BFD8,
    "Tomato": 0xFFFF6347,
    "Transparent": 0x00FFFFFF,
    "Turquoise": 0xFF40E0D0,
    "Violet": 0xFFEE82EE,
    "Wheat": 0xFFF5DEB3,
    "White": 0xFFFFFFFF,
    "WhiteSmoke": 0xFFF5F5F5,
    "Yellow": 0xFFFFFF00,
    "YellowGreen": 0xFF9ACD32
};

var ColorARGB = function(hexValue)
{
    this.a = parseInt(hexValue.slice(0, 2), 16);
    this.r = parseInt(hexValue.slice(2, 4), 16);
    this.g = parseInt(hexValue.slice(4, 6), 16);
    this.b = parseInt(hexValue.slice(6, 8), 16);
}

ControlWrapper.getColor = function(colorValue)
{
    if (colorValue.indexOf("#") == 0)
    {
        colorValue = colorValue.replace("#", "");

        if (colorValue.match(/^[0-9a-fA-F]*$/))
        {
            if (colorValue.length == 6)
            {
                return new ColorARGB("FF" + colorValue);
            }
            else if (colorValue.length == 8)
            {
                return new ColorARGB(colorValue);
            }
            else
            {
                logger.debug("Incorrect length for hex color specification - must be 6 (RRGGBB) or 8 (AARRGGBB) hex digits, was %d digits", colorValue.length);
            }
        }
        else
        {
            logger.debug("Color specification container non-hex characters - was: #%s", colorValue);
        }
    }
    else if (colorValue.length > 0)
    {
        if (ControlWrapper.colorNames[colorValue])
        {
            return new ColorARGB(ControlWrapper.colorNames[colorValue].toString(16));
        }
        else
        {
            logger.debug("Color name '%s' was not found, please choose a color name from the Microsoft SilverLight color set", colorValue);
        }
    }

    // !!! Should we do something other than return null for an empty/bad color name/spec?
    return null;
}

// For web, we want to highest fidelity to the specified color value (as opposed to converting to ARGB in all cases)
//
ControlWrapper.getColorString = function(colorValue)
{
    if (colorValue.indexOf("#") == 0)
    {
        colorValue = colorValue.replace("#", "");

        if (colorValue.match(/^[0-9a-fA-F]*$/))
        {
            if (colorValue.length == 6)
            {
                // Return # hex rgb intact
                return "#" + colorValue; 
            }
            else if (colorValue.length == 8)
            {
                // Return rgba() color spec
                var color = new ColorARGB(colorValue);
                return "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + color.a/255 + ")"; 
            }
            else
            {
                logger.debug("Incorrect length for hex color specification - must be 6 (RRGGBB) or 8 (AARRGGBB) hex digits, was %d digits", colorValue.length);
            }
        }
        else
        {
            logger.debug("Color specification container non-hex characters - was: #%s", colorValue);
        }
    }
    else if (colorValue.length > 0)
    {
        if (ControlWrapper.colorNames[colorValue])
        {
            // Return color name intact
            return colorValue; 
        }
        else
        {
            logger.debug("Color name '%s' was not found, please choose a color name from the Microsoft SilverLight color set", colorValue);
        }
    }

    return "";
}

ControlWrapper.prototype.processFontAttribute = function(controlSpec, fontSetter)
{
    var self = this;
    this.processElementProperty(controlSpec, "font.face", function(value)
    {
        var faceType = ControlWrapper.FontFaceType.FONT_DEFAULT;
        var faceTypeString = self.toString(value);
        switch (faceTypeString)
        {
            case "Serif":
                faceType = ControlWrapper.FontFaceType.FONT_SERIF;
                break;
            case "SanSerif":
                faceType = ControlWrapper.FontFaceType.FONT_SANSERIF;
                break;
            case "Monospace":
                faceType = ControlWrapper.FontFaceType.FONT_MONOSPACE;
                break;
        }
        fontSetter.setFaceType(faceType);
    });

    // This will handle the simple style "fontsize" attribute (this is the most common font attribute and is
    // very often used by itself, so we'll support this alternate syntax).
    //
    this.processElementProperty(controlSpec, "font.size", "fontsize", function(value)
    {
        if (value != null)
        {
            fontSetter.setSize(self.toDouble(value));
        }
    });

    this.processElementProperty(controlSpec, "font.bold", function(value)
    {
        fontSetter.setBold(self.toBoolean(value));
    });

    this.processElementProperty(controlSpec, "font.italic", function(value)
    {
        fontSetter.setItalic(self.toBoolean(value));
    });
}

// Process a value binding on an element.  If a value is supplied, a value binding to that binding context will be created.
//
ControlWrapper.prototype.processElementBoundValue = function(attributeName, value, getValue, setValue)
{
    if (setValue === undefined)
    {
        setValue = null;
    }

    if (value != null)
    {
        var valueBindingContext = this._bindingContext.select(value);
        var binding = this._viewModel.createAndRegisterValueBinding(valueBindingContext, getValue, setValue);
        this.setValueBinding(attributeName, binding);

        // Immediate content update during configuration. 
        binding.updateViewFromViewModel(); 

        return true;
    }

    return false;
}

ControlWrapper.prototype.attemptStyleBinding = function(style, attributeName, setValue)
{
    // See if [style].[attributeName] is defined, and if so, bind to it
    //
    var styleBinding = style + "." + attributeName;
    var styleBindingContext = this._viewModel.getRootBindingContext().select(styleBinding);
    var value = styleBindingContext.getValue();
    if ((value != null) && JToken.isObject(value))
    {
        var binding = this._viewModel.createAndRegisterPropertyBinding(this._bindingContext, "{$root." + styleBinding + "}", setValue);
        if (setValue == null)
        {
            this._viewModel.unregisterPropertyBinding(binding);
        }
        else
        {
            this._propertyBindings.push(binding);
        }

        // Immediate content update during configuration.
        return binding.updateViewFromViewModel();
    }

    return null;
}

// Process an element property, which can contain a plain value, a property binding token string, or no value at all, 
// in which case one or more "style" attribute values will be used to attempt to find a binding of the attributeName 
// to a style value.  This call *may* result in a property binding to the element property, or it may not. 
// 
// This is "public" because there are cases when a parent element needs to process properties on its children after creation. 
// 
// The returned JToken (if any) represents the bound value as determined at the time of processing the element.  It may return  
// nil in the case that there was no binding, or where there was a binding to an element in the view model that does not currently 
// exist.   
// 
// This function can be used for cases where the element binding is required to be present at processing time (for config elements 
// that are required upon control creation, and that do not support value update during the control lifecycle).  In that case, a 
// nil value may be passed for setValue, which will avoid creating and managing bindings (which should not be necessary since there 
// is no setter), but will still return a resolved value if once can be determined. 
// 
// ControlWrapper.prototype.processElementProperty = function(controlSpec, attributeName, setValue)
// ControlWrapper.prototype.processElementProperty = function(controlSpec, attributeName, altAttributeName, setValue)
//
ControlWrapper.prototype.processElementProperty = function(controlSpec, attributeName, param3, param4)
{
    // Preserving from port: there is a version of this method without the altAttribute name, so if we see a call with
    // only 3 params, we assume it's the version without the altAttributeName...
    // 
    var altAttributeName = param3;
    var setValue = param4;

    if (arguments.length === 3)
    {
        altAttributeName = null;
        setValue = param3;
    }

    controlSpec = new JToken(controlSpec); // !!!

    var value = controlSpec.selectToken(attributeName);
    if ((value == null) && (altAttributeName != null))
    {
        value = controlSpec.selectToken(altAttributeName);
        if ((value != null) && JToken.isObject(value))
        {
            value = null;
        }
    }

    if (value == null)
    {
        if (this._styles != null)
        {
            for (var i = 0; i < this._styles.length; i++)
            {
                var style = this._styles[i];
                var resolvedValue = this.attemptStyleBinding(style, attributeName, setValue);
                if (resolvedValue != null)
                {
                    return resolvedValue;
                }
                else if (altAttributeName != null)
                {
                    resolvedValue = this.attemptStyleBinding(style, altAttributeName, setValue);
                    if (resolvedValue != null)
                    {
                        return resolvedValue;
                    }
                }
            }
        }
    }
    else if (JToken.isString(value) && PropertyValue.containsBindingTokens(value.getValue()))
    {
        // If value contains a binding, create a Binding and add it to metadata
        var binding = this._viewModel.createAndRegisterPropertyBinding(this._bindingContext, value.getValue(), setValue);
        if (setValue == null)
        {
            this._viewModel.unregisterPropertyBinding(binding);
        }
        else
        {
            this._propertyBindings.push(binding);
        }

        // Immediate content update during configuration.
        return binding.updateViewFromViewModel(); 
    }
    else
    {
        if (setValue != null)
        {
            // Otherwise, just set the property value
            setValue(value);
        }
        return value;
    }

    return null;
}

// This helper is used by control update handlers.
//
ControlWrapper.prototype.updateValueBindingForAttribute = function(attributeName)
{
    var binding = this.getValueBinding(attributeName);
    if (binding != null)
    {
        // Update the local ViewModel from the element/control
        binding.updateViewModelFromView();
    }
}

// Process and record any commands in a binding spec
//
ControlWrapper.prototype.processCommands = function(bindingSpec, commands)
{
    for (var i = 0; i < commands.length; i++)
    {
        var command = commands[i];
        var commandSpec = bindingSpec[command];
        if (commandSpec != null)
        {
            // A command spec contains an attribute called "command".  All other attributes are considered parameters.
            //
            var commandInstance = new CommandInstance(commandSpec["command"]);

            var keys = Object.keys(commandSpec);
            for (var j = 0; j < keys.length; j++)
            {
                if (keys[j] != "command")
                {
                    commandInstance.setParameter(keys[j], commandSpec[keys[j]]);
                }
            }
            this.setCommand(command, commandInstance);
        }
    }
}

// When we remove a control, we need to unbind it and its descendants (by unregistering all bindings
// from the view model).  This is important as often times a control is removed when the underlying
// bound values go away, such as when an array element is removed, causing a cooresponding (bound) list
// or list view item to be removed.
//
ControlWrapper.prototype.unregister = function()
{
    var valueBindingKeys = Object.keys(this._valueBindings)
    for (var i = 0; i < valueBindingKeys.length; i++)
    {
        this._viewModel.unregisterValueBinding(this._valueBindings[valueBindingKeys[i]]);
    }

    for (var i = 0; i < this._propertyBindings.length; i++)
    {
        this._viewModel.unregisterPropertyBinding(this._propertyBindings[i]);
    }

    for (var i = 0; i < this._childControls.length; i++)
    {
        this._childControls[i].unregister();
    }
}

// This will create controls from a list of control specifications.  It will apply any "foreach" and "with" bindings
// as part of the process.  It will call the supplied callback to actually create the individual controls.
//
ControlWrapper.prototype.createControls = function(bindingContext, controlList, onCreateControl) //  onCreateControl is callback(BindingContext, JToken) - where JToken contains object 
{
    for (var i = 0; i < controlList.length; i++)
    {
        var element = controlList[i];

        var controlBindingContext = bindingContext;
        var controlCreated = false;
        var bindingSpec = element["binding"];

        if ((bindingSpec != null) && (typeof bindingSpec === 'object'))
        {
            logger.debug("Found binding object");

            var bindingSpecForEach = bindingSpec["foreach"];
            var bindingSpecWith = bindingSpec["with"];

            if (bindingSpecForEach != null)
            {
                // First we create a BindingContext for the "foreach" path (a context to the elements to be iterated)
                var bindingPath = bindingSpecForEach;
                logger.debug("Found 'foreach' binding with path: %s", bindingPath);
                var forEachBindingContext = bindingContext.select(bindingPath);

                // Then we determine the bindingPath to use on each element
                var withPath = "$data";
                if (bindingSpecWith != null)
                {
                    // It is possible to use "foreach" and "with" together - in which case "foreach" is applied first
                    // and "with" is applied to each element in the foreach array.  This allows for path navigation
                    // both up to, and then after, the context to be iterated.
                    //
                    withPath = bindingSpecWith;
                }

                // Then we get each element at the foreach binding, apply the element path, and create the controls
                var bindingContexts = forEachBindingContext.selectEach(withPath);

                for (var j = 0; j < bindingContexts.length; j++)
                {
                    var elementBindingContext = bindingContexts[j];
                    logger.debug("foreach - creating control with binding context: %s", elementBindingContext.getBindingPath());
                    onCreateControl(elementBindingContext, element);
                }
                controlCreated = true;
            }
            else if (bindingSpecWith != null)
            {
                var withBindingPath = bindingSpecWith.getValue();
                logger.debug("Found 'with' binding with path: %s", withBindingPath);
                controlBindingContext = bindingContext.select(withBindingPath);
            }
        }

        if (!controlCreated)
        {
            onCreateControl(controlBindingContext, element);
        }
    }
}

module.exports = ControlWrapper;
