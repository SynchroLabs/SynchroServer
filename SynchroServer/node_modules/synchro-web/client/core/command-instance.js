var logger = require('log4js').getLogger("command-instance");

var JToken = require('./json');
var binding = require('./binding');
var PropertyValue = binding.PropertyValue;

var CommandInstance = function(command)
{
    this._command = command;
    this._parameters = {};
}

CommandInstance.commandNames = 
{
    OnClick:           "onClick",
    OnItemClick:       "onItemClick",
    OnSelectionChange: "onSelectionChange",
    OnToggle:          "onToggle",
    OnUpdate:          "onUpdate",
    OnTap:             "onTap"
}

CommandInstance.prototype.getCommand = function()
{
    return this._command;
}

CommandInstance.prototype.setParameter = function(name, value) // value is JToken
{
    this._parameters[name] = value;
}

// If a parameter is not a string type, then that parameter is passed directly.  This allows for parameters to
// be boolean, numeric, or even objects.  If a parameter is a string, it will be evaluated to see if it has
// any property bindings, and if so, those bindings will be expanded.  This allows for parameters that vary
// based on the current context, for example, and also allows for complex values (such as property bindings
// that refer to a single value of a type other than string, such as an object).
//
CommandInstance.prototype.getResolvedParameters = function(bindingContext)
{
    var obj = {};
    var keys = Object.keys(this._parameters);
    for (var i = 0; i < keys.length; i++)
    {
        var key = keys[i];
        var value = this._parameters[key];

        if ((typeof value === 'string') && PropertyValue.containsBindingTokens(value))
        {
            var token = PropertyValue.expand(value, bindingContext);
            if (token != null)
            {
                value = JSON.parse(token.toJson());
            }
            else
            {
                // Token could not be resolved
                value = null; 
            }
        }

        obj[key] = value;
    }
    return obj;
}

module.exports = CommandInstance;
