var logger = require('log4js').getLogger("binding-context");

var JToken = require('./json');

// Creates the root binding context, from which all other binding contexts will be created
//
var BindingContext = function()
{
    this._bindingRoot = null;

    this._bindingPath = null;
    this._boundToken = null;
    this._isIndex = false;
}

BindingContext.prototype.getBindingRoot = function()
{
    return this._bindingRoot;
}

BindingContext.prototype.setBindingRoot = function(bindingRoot)
{
    if (this._bindingRoot != bindingRoot)
    {
        this._bindingRoot = bindingRoot;
        this.rebind();
    }
}

BindingContext.prototype.attemptToBindTokenIfNeeded = function()
{
    if (this._boundToken == null)
    {
        this._boundToken = this._bindingRoot.selectToken(this._bindingPath);
    }
}

exports.createRootBindingContext = function(bindingRoot)
{
    var bindingContext = new BindingContext();
    bindingContext._bindingRoot = bindingRoot;
    bindingContext._bindingPath = "";
    bindingContext._boundToken = bindingRoot;
    return bindingContext;
}

var BindingTokensRE = /[$]([^.[]*)[.]?/g; // Break on dot or open square bracket, only consume dot

BindingContext.prototype.resolveBinding = function(parentPath, bindingPath)
{
    var self = this;

    // Process path elements:
    //
    //  $root
    //  $parent
    //  $data
    //  $index
    //
    //  The processing below might be overkill.  In practice, any $root path element should be at the beginning
    //  of the token string.  Any $parent element (including more than one) should be at the beginning of the token
    //  string.  Since these strings are literal and never programmatically constructed, it would be nonsensical to
    //  navigate explicilty down some desendant path and then back up to the root or a parent.  Also, since $index
    //  is just a flag (and will cause the bindingContext to find its most immediate array index), it will appear
    //  by itself.  Likewise, $data is nonsensical other than when appearing by itself.
    //
    //  So realistically, the cases of bindingPath that need to be handled are:
    //
    //  $root.some.path ($root at beginning of binding path, no further specials in path)
    //  $parent.$parent.some.path (one or more $parent elements at beginning of binding path, no further specials in path)
    //  $index
    //  $data
    //
    // Token starts with $, separated by dot or square bracket
    //
    this._bindingPath = bindingPath.replace(BindingTokensRE, function(match, pathElement)
    {
        logger.debug("Found binding path element:", pathElement);

        if (pathElement == "root")
        {
            parentPath = "";
        }
        else if (pathElement == "parent")
        {
            if (parentPath.Length != 0)
            {
                // We need to remove the last segment whether it is dot-separated or an array notation
                //
                var lastDot = Math.max(parentPath.lastIndexOf("."), parentPath.lastIndexOf("["));
                if (lastDot == -1)
                {
                    // Remove the only remaining path segment
                    parentPath = "";
                }
                else
                {
                    // Remove the last (rightmost) path segment
                    parentPath = parentPath.slice(0, lastDot);
                }
            }
        }
        else if (pathElement == "data")
        {
            // We're going to treat $data as a noop
        }
        else if (pathElement == "index")
        {
            self._isIndex = true;
        }

        return ""; // Removing the path elements as they are processed
    });

    if ((parentPath.length > 0) && (this._bindingPath.length > 0))
    {
        if (this._bindingPath[0] != '[')
        {
            parentPath += '.';
        }
        this._bindingPath = parentPath + this._bindingPath;
    }
    else if (parentPath.length > 0)
    {
        this._bindingPath = parentPath;
    }
}

function createBindingContext(context, bindingPath)
{
    var bindingContext = new BindingContext();
    bindingContext._bindingRoot = context._bindingRoot;
    bindingContext.resolveBinding(context._bindingPath, bindingPath);
    bindingContext.attemptToBindTokenIfNeeded();
    return bindingContext;
}

function createBindingContextIndexed(context, index, bindingPath)
{
    var bindingContext = new BindingContext();
    bindingContext._bindingRoot = context._bindingRoot;
    bindingContext.resolveBinding(context._bindingPath + "[" + index + "]", bindingPath);
    bindingContext.attemptToBindTokenIfNeeded();
    return bindingContext;
}

//
// Public interface starts here...
//

// Given a path to a changed element, determine if the binding is impacted.
//
BindingContext.prototype.isBindingUpdated = function(updatedElementPath, objectChange)
{
    if (objectChange && (this._bindingPath.indexOf(updatedElementPath) == 0))
    {
        // If this is an object change (meaning the object/array itself changed), then a binding
        // update is required if the path matches or is an ancestor of the binging path.
        //
        return true;
    }
    else if (this._bindingPath == updatedElementPath)
    {
        // If this is a primitive value change, or an object/array contents change (meaning
        // that the object itself did not change), then a binding update is only required if
        // the path matches exactly.
        //
        return true;
    }

    return false;
}

BindingContext.prototype.select = function(bindingPath)
{
    return createBindingContext(this, bindingPath);
}

BindingContext.prototype.selectEach = function(bindingPath)
{
    var bindingContexts = [];

    // !!! This is pretty creepy - we're looking into JToken to access his _value (to see if it is an Array and get its length).
    //
    if ((this._boundToken != null) && Array.isArray(this._boundToken._value))
    {
        for (var i = 0; i < this._boundToken._value.length; i++)
        {
            bindingContexts.push(createBindingContextIndexed(this, i, bindingPath));
        }
    }

    return bindingContexts;
}

BindingContext.prototype.getBindingPath = function()
{
    return this._bindingPath;
}

BindingContext.prototype.getValue = function()
{
    this.attemptToBindTokenIfNeeded();
    if (this._boundToken != null)
    {
        if (this._isIndex)
        {
            // Find first ancestor that is an array and get the position of that ancestor's child
            //
            var child = this._boundToken;
            var parent = child._parent;

            while (parent != null)
            {
                // !!! Again we're peeking inside of the JToken (bad?)
                if (Array.isArray(parent._value))
                {
                    // !!! Returning value instead of JToken
                    return parent._value.indexOf(child);
                }
                else
                {
                    child = parent;
                    parent = child._parent;
                }
            }
        }
        else
        {
            return this._boundToken;
        }
    }

    // Token could not be bound at this time (no corresponding token) - no value returned!
    return null;
}

// Return boolean indicating whether the bound token was changed (and rebinding needs to be triggered)
//
BindingContext.prototype.setValue = function(value)
{
    this.attemptToBindTokenIfNeeded();
    if (this._boundToken != null)
    {
        if (this._isIndex)
        {
            return false;
        }
        else
        {
            var bRefUpdated = JToken.updateTokenValue(this._boundToken, value);
            if (bRefUpdated)
            {
                this._boundToken = value;
            }
            return bRefUpdated;
        }
    }

    // Token could not be bound at this time (no corresponding token) - value not set!
    //
    // !!! This happens when you bind a control to a ViewModel path that is not initialized to a value.  In
    //     this case, any changes to that value will not be recorded (there is no place to record the value
    //     in the local ViewModel).  Maybe it would be better to try to create the ViewModel item locally, or
    //     to have a mechanism for recording the value so it could still be sent (and result in an "Add" coming
    //     back from the server after diff processing).
    //
    logger.info("Unable to store new value {0} for element: {1}, element not initialized by app", value, this._bindingPath);
    return false;
}

BindingContext.prototype.rebind = function()
{
    this._boundToken = this._bindingRoot.selectToken(this._bindingPath);
}


