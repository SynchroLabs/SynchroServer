var logger = require('log4js').getLogger("web-listview-wrapper");

var WebControlWrapper = require('./web-control-wrapper');

var binding = require('../core/binding');
var PropertyValue = binding.PropertyValue;
var CommandInstance = require('../core/command-instance');
var JToken = require('../core/json');

var SelectionMode = require('../core/control-wrapper').ListSelectionMode;

var WebListViewWrapper = function(parent, bindingContext, controlSpec)
{
    this.base = WebControlWrapper;
    this.base(parent, bindingContext, controlSpec);
    logger.info("ListView control created");

    this._selectionChangingProgramatically = false;
    this._localSelection =  null;

    var listview = document.createElement("ul");
    listview.classList.add("synchro-listview");

    this._selectionMode = this.toListSelectionMode(this.processElementProperty(controlSpec, "select", null));

    this._control = listview;

    var self = this;

    // !!! Add support for header and footer elements
    //
    // Note: Header and/or footer may not be present, in which case cooresponding elements would not be present
    //
    // Note: Header and footer child controls / control groups need to be cleaned up (unregistered), either via being
    //       included in _childControls, or explicitly (which woild require _header and _footer to track).
    //
    // We could do:
    //
    // <div>
    //    <div> // header
    //    <ul>
    //        <li>
    //        ..
    //    </ul>
    //    <div> // footer
    // </div>
    //
    // Or:
    //
    // <ul>
    //   <li> // header
    //   <li>
    //   ..
    //   <li> // footer
    // </ul>
    //

    if (controlSpec["header"])
    {
        logger.error("Listview header not yet supported");
    }

    if (controlSpec["footer"])
    {
        logger.error("Listview footer not yet supported");
    }

    var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, "items", WebListViewWrapper.commands);

    this.processCommands(bindingSpec, WebListViewWrapper.commands);

    if (bindingSpec["items"])
    {
        var itemContent = bindingSpec["itemContent"] || "{$data}";

        this.processElementBoundValue(
            "items",
            bindingSpec["items"],
            function() { return self.getListViewContents(listview) }, // !!! ??? Do we need this?  We never get the listview contents
            function(value) { self.setListViewContents(listview, self.getValueBinding("items").getBindingContext(), controlSpec["itemTemplate"]) }
            );
    }

    if (bindingSpec["selection"])
    {
        var selectionItem = bindingSpec["selectionItem"] || "$data";

        this.processElementBoundValue(
            "selection",
            bindingSpec["selection"],
            function() { return self.getListViewSelection(listview, selectionItem) },
            function(value) { self.setListViewSelection(listview, selectionItem, value) }
            );
    }
}
WebListViewWrapper.prototype = Object.create(WebControlWrapper.prototype);

WebListViewWrapper.commands = [ CommandInstance.commandNames.OnItemClick, CommandInstance.commandNames.OnSelectionChange ];

// ListViewItem
//
var WebListViewItemWrapper = function(parent, bindingContext, itemTemplate)
{
    this.base = WebControlWrapper;
    this.base(parent, bindingContext, null); // controlSpec is only used for styles, which this item won't have
    logger.info("ListView item control created");

    this._listView = parent;
    this._selected = false;

    this._control = document.createElement("li");
    this._control.classList.add("synchro-listviewitem");

    var controlWrapper = WebControlWrapper.createControl(this, this._bindingContext, itemTemplate);
    this._control.appendChild(controlWrapper._control);

    this._control.addEventListener("click", this.onClick.bind(this), false);
}
WebListViewItemWrapper.prototype = Object.create(WebControlWrapper.prototype);

WebListViewItemWrapper.prototype.getSelected = function(isSelected)
{
    return this._selected;
}

WebListViewItemWrapper.prototype.setSelected = function(isSelected)
{
    if (isSelected)
    {
        this._control.classList.add("selected");
    }
    else
    {
        this._control.classList.remove("selected");
    }
    this._selected = isSelected;
}

WebListViewItemWrapper.prototype.onClick = function()
{
    logger.info("listview item clicked");
    this._listView.onItemClicked(this);
}
//
// End ListViewItem

WebListViewWrapper.prototype.getListViewContents = function(listview)
{
    // This should never get called (it's not implemented on iOS either)
    logger.error("Get listview contents not implemented");
}

WebListViewWrapper.prototype.setListViewContents = function(listview, bindingContext, itemTemplate)
{
    // listview - DOM elemement
    // bindingContext - BindingContext
    // itemContent - string
    //
    logger.info("Setting listview contents");

    this._selectionChangingProgramatically = true;

    var itemContexts = bindingContext.selectEach("$data");

    var listItems = listview.getElementsByTagName("li");

    if (listItems.length < itemContexts.length)
    {
        // New items are added (to the end of the list)
        //
        for (var index = listItems.length; index < itemContexts.length; index++)
        {
            var itemControl = new WebListViewItemWrapper(this, itemContexts[index], itemTemplate);
            this._childControls.push(itemControl);
            listview.appendChild(itemControl._control);
        }
    }
    else if (listItems.length > itemContexts.length)
    {
        // Items need to be removed (from the end of the list)
        //
        for (var index = listItems.length; index > itemContexts.length; index--)
        {
            var control = listItems[index - 1];
            var wrapper = this.getChildControlWrapper(control);

            // Unregister any bindings for this element or any descendants
            //
            wrapper.unregister();

            // !!! Remove this from _childControls
        }
        listItems.length = itemsContexts.length; // truncate
    }

    var selectionBinding = this.getValueBinding("selection");
    if (selectionBinding)
    {
        // If there is a "selection" value binding, then we update the selection state from that after filling the list.
        //
        selectionBinding.updateViewFromViewModel();
    }
    else if (this._localSelection)
    {
        // If there is not a "selection" value binding, then we use local selection state to restore the selection when
        // re-filling the list.
        //
        this.setListViewSelection(listview, "$data", this._localSelection);
    }

    this._selectionChangingProgramatically = false;
}

// For SelectionMode.Single
//
WebListViewWrapper.prototype.getSelectedItem = function()
{
    for (var i = 0; i < this._childControls.length; i++)
    {
        var child = this._childControls[i];
        if (child.getSelected())
        {
            return child;
        }
    }
    return null;
}

WebListViewWrapper.prototype.getListViewSelection = function(listview, selectionItem)
{
    // listview - DOM elemement
    // selectionItem - string
    //
    logger.info("Getting listview selection");

    if (this._selectionMode == SelectionMode.Multiple)
    {
        var selectedTokens = [];
        for (var i = 0; i < this._childControls.length; i++)
        {
            var child = this._childControls[i];
            if (child.getSelected())
            {
                var itemContext = child.getBindingContext();
                var selectionContext = itemContext.select(selectionItem);
                selectedTokens.push(selectionContext.getValue().deepClone());
            }
        }
        return new JToken(selectedTokens);
    }
    else
    {
        var selectedItem = this.getSelectedItem();
        if (selectedItem)
        {
            var itemContext = selectedItem.getBindingContext();
            var selectionContext = itemContext.select(selectionItem);
            return selectionContext.getValue().deepClone();
        }
        return new JToken(false); // This is a "null" selection
    }
}

WebListViewWrapper.prototype.setListViewSelection = function(listview, selectionItem, selection)
{
    // listview - DOM elemement
    // selectionItem - string
    // selection - JToken
    //
    logger.info("Setting listview selection");

    this._selectionChangingProgramatically = true;

    if ((this._selectionMode == SelectionMode.Multiple) && JToken.isArray(selection))
    {
        for (var i = 0; i < this._childControls.length; i++)
        {
            var child = this._childControls[i];

            var itemSelected = false;

            var itemContext = child.getBindingContext();
            var selectionContext = itemContext.select(selectionItem);

            var selections = selection.getValue()
            for (var j = 0; j < selections.length; j++)
            {
                itemSelected = selectionContext.getValue().deepEquals(selections[j]);
                if (itemSelected)
                {
                    logger.info("Selected item:", selectionContext.getValue().toJson());
                    break;
                }
            }
            child.setSelected(itemSelected);
        }
    }
    else
    {
        for (var i = 0; i < this._childControls.length; i++)
        {
            var child = this._childControls[i];

            var itemContext = child.getBindingContext();
            var selectionContext = itemContext.select(selectionItem);

            if (selectionContext.getValue().deepEquals(selection))
            {
                logger.info("Selected item:", selectionContext.getValue().toJson());
                child.setSelected(true);
            }
            else
            {
                child.setSelected(false);
            }
        }
    }

    this._selectionChangingProgramatically = false;
}

WebListViewWrapper.prototype.onItemClicked = function(item)
{
    if (this._selectionMode == SelectionMode.None)
    {
        this.onItemClick(item);
    }
    else if (this._selectionMode == SelectionMode.Single)
    {
        // If the clicked item is not already selected
        if (!item.getSelected())
        {
            // Deselect the current selection
            var currentSelection = this.getSelectedItem();
            if (currentSelection)
            {
                currentSelection.setSelected(false);
            }

            // Select the clicked item
            item.setSelected(true);

            this.onSelectionChanged();
        }
    }
    else if (this._selectionMode == SelectionMode.Multiple)
    {
        // !!! Note: No current support for range selection (via shift-click)

        // Toggle the selection state of the clicked item
        item.setSelected(!item.getSelected());

        this.onSelectionChanged();
    }
}

// SelectMode.None
//
WebListViewWrapper.prototype.onItemClick = function(item)
{
    logger.info("listview item clicked");

    // This will get called when the selection mode is "None" and an item is clicked (no selection change events will
    // fire in this case).
    //
    var command = this.getCommand(CommandInstance.commandNames.OnItemClick);
    if (command != null)
    {
        logger.Debug("ListView item click with command: {0}", command);

        // The item click command handler resolves its tokens relative to the item clicked (not the list view).
        //
        this._stateManager.sendCommandRequestAsync(command.getCommand(), command.getResolvedParameters(item.getBindingContext()));
    }
}

// SelectMode.Single or SelectMode.Multiple
//
WebListViewWrapper.prototype.onSelectionChanged = function()
{
    logger.info("listview selection changed");

    var listview = this._control;

    var selectionBinding = this.getValueBinding("selection");
    if (selectionBinding)
    {
        this.updateValueBindingForAttribute("selection");
    }
    else if (!this._selectionChangingProgramatically)
    {
        this._localSelection = this.getListViewSelection(listview, "$data");
    }

    if (!this._selectionChangingProgramatically)
    {
        var command = this.getCommand(CommandInstance.commandNames.OnSelectionChange);
        if (command != null)
        {
            if (this._selectionMode == SelectionMode.Multiple)
            {
                // For selection mode "Multiple", the command hander resovles its tokens relative to the listview, not any list item(s).
                //
                this._stateManager.sendCommandRequestAsync(command.getCommand(), command.getResolvedParameters(this._bindingContext));
            }
            else
            {
                // For selection mode "Single", the command handler resolves its tokens relative to the item selected.
                //
                var currentSelection = this.getSelectedItem();
                this._stateManager.sendCommandRequestAsync(command.getCommand(), command.getResolvedParameters(currentSelection.getBindingContext()));
            }
        }
    }
}

module.exports = WebListViewWrapper;
