var logger = require('log4js').getLogger("web-image-wrapper");

var WebControlWrapper = require('./web-control-wrapper');

var binding = require('../core/binding');
var CommandInstance = require('../core/command-instance');

var WebImageWrapper = function(parent, bindingContext, controlSpec)
{
    var self = this;

    this.base = WebControlWrapper;
    this.base(parent, bindingContext, controlSpec);
    logger.info("Image control created");

    // There are two size modalities based on the presecence of sizing attributes, as outlined below.
    //
    this._heightSpecified = !!controlSpec["height"];
    this._widthSpecified = !!controlSpec["width"];

    this._isImgTag = this._heightSpecified ? !this._widthSpecified : this._widthSpecified;

    if (this._isImgTag) 
    {
        // In this modality, either the height or the width of the image is set (but not both), and the other dimension
        // must be computed based on the aspect ratio of the image and the other dimension size.  The <img> element does
        // this by default (if only one dimension is set, it computes the other one properly).
        //
        this._control =  document.createElement("img");
    }
    else
    {
        // In this mmodality, both the height and width are set, and the "scale" attribute is used to determine
        // how to position/scale/clip the image within those boundaries, based on "scale" values of Fit, Fill, and Stretch.
        // The <div> element is capable of accomplishing Fit and Fill via the backgroundSize values of "contain" and "cover",
        // respectively.  
        //
        // Either modality (or element) is capable of accomplishing Stretch, but since the modality must be determined
        // before creating the element, we need to handle Stretch in the "scale" modality (so it can be animated).
        //
        this._control =  document.createElement("div");
        this._control.style.display = "inline-block";
        this._control.style.backgroundRepeat = "no-repeat";
        this._control.style.backgroundPosition = "50% 50%";
    }

    this._control.classList.add("synchro-image");

    this.sizeAndScale("Fit");

    var self = this;
    var value = this.processElementProperty(controlSpec, "resource", function(value) 
    {
        if (self._isImgTag)
        {
            self._control.addEventListener('load', function() 
            {
                logger.info("Image is loaded!");
            });
            self._control.src = self.toString(value);
        }
        else
        {
            self._control.style.backgroundImage = "url('" + self.toString(value) + "')";
        }
        
    });

    this.processElementProperty(controlSpec, "scale", function(value)
    {
        self.sizeAndScale(self.toString(value));
    });

    var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, CommandInstance.commandNames.OnTap, WebImageWrapper.commands);
    this.processCommands(bindingSpec, WebImageWrapper.commands);

    if (this.getCommand(CommandInstance.commandNames.OnTap) != null)
    {
        // Attach a handler
        logger.info("Adding image onTap handler");
        image.addEventListener("click", this.OnTap.bind(this), false);
    }
}

WebImageWrapper.prototype = Object.create(WebControlWrapper.prototype);

WebImageWrapper.commands = [ CommandInstance.commandNames.OnTap ];

// Image scaling
//
//     "Stretch" to fill 
//     "Fit" preserving aspect
//     "Fill" preserving aspect
//
// https://www.w3.org/TR/css3-background/#backgrounds
//
// http://stackoverflow.com/questions/11757537/css-image-size-how-to-fill-not-stretch
//
WebImageWrapper.prototype.sizeAndScale = function(scale)
{
    logger.info("Setting scale to:", scale);

    if (!this._isImgTag)
    {
        // Scale based on "scale" attribute
        if (scale == "Stretch")
        {
            this._control.style.backgroundSize = "100% 100%";
        }
        else if (scale == "Fill")
        {
            this._control.style.backgroundSize = "cover";
        }
        else // "Fit" is default
        {
            this._control.style.backgroundSize = "contain";
        }
    }
}

WebImageWrapper.prototype.OnTap = function()
{
    logger.info("Image tapped");
    var command = this.getCommand(CommandInstance.commandNames.OnTap);
    if (command != null)
    {
        logger.info("Image tapped with command: %s", command.getCommand());
        this._stateManager.sendCommandRequestAsync(command.getCommand(), command.getResolvedParameters(this._bindingContext));
    }
}

module.exports = WebImageWrapper;
