var logger = require('log4js').getLogger("web-toggle-button-wrapper");

var WebControlWrapper = require('./web-control-wrapper');

var glyphMapper = require('../core/glyph-mapper');

var binding = require('../core/binding');
var CommandInstance = require('../core/command-instance');
var JToken = require('../core/json');

var WebToggleButtonWrapper = function(parent, bindingContext, controlSpec)
{
    var self = this;

    this.base = WebControlWrapper;
    this.base(parent, bindingContext, controlSpec);
    logger.debug("Toggle button control created");

    var button = document.createElement("button");
    button.classList.add("synchro-button"); // !!! synchro-toggle-button ?
    self._color = "Blue"; // !!! CSS?

    this._control = button;

    if (controlSpec["borderless"] !== false)
    {
        logger.debug("Toggle button is borderless");
        button.classList.add("synchro-borderless");
    }

    function setCaption(caption)
    {
        logger.debug("Setting caption to:", caption);
        button.innerHTML = caption;
        if (self._iconElement)
        {
            // If there is an icon, we need to re-insert it (setting innerHTML will have blown it away)
            button.insertBefore(self._iconElement, button.firstChild);
        }
    }

    function setIcon(icon)
    {
        var iconGlyph = glyphMapper.getGlyph(icon);

        logger.debug("Icon set to glyph %s, mapped to entity: %s", icon, iconGlyph);

        if (!self._iconElement)
        {
            self._iconElement = document.createElement("i");
            self._iconElement.classList.add("material-icons");
            button.insertBefore(self._iconElement, button.firstChild);
        }

        self._iconElement.innerHTML = iconGlyph;
    }

    function setColor(color)
    {
        logger.debug("Setting color to:", color);
        button.style.color = color;
    }

    this.updateVisualState = function(checked)
    {
        if (checked === undefined)
        {
            checked = self.getChecked();
        }

        // If the user specified configuration that visually communicates the state change, then we will use only those
        // configuration elements to show the state change.  If they do not include any such elements, then we will gray
        // the toggle button out to show the unchecked state.
        //
        var isVisualStateExplicit = !!(self._checkedcaption || self._checkedicon || self._checkedcolor);

        if (checked)
        {
            if (isVisualStateExplicit)
            {
                // One or more of the explicit checked items will be set below...
                //
                if (self._checkedcaption)
                {
                    setCaption(self._checkedcaption);
                }
                if (self._checkedicon)
                {
                    setIcon(self._checkedicon);
                }
                if (self._checkedcolor)
                {
                    setColor(self._checkedcolor);
                }
            }
            else
            {
                // There was no explicit visual state specified, so we will use default color for checked
                //
                setColor(self._color);
            }
        }
        else
        {
            if (isVisualStateExplicit)
            {
                // One or more of the explicit unchecked items will be set below...
                //
                if (self._uncheckedcaption)
                {
                    setCaption(self._uncheckedcaption);
                }
                if (self._uncheckedicon)
                {
                    setIcon(self._uncheckedicon);
                }
                if (self._uncheckedcolor)
                {
                    setColor(self._uncheckedcolor);
                }
            }
            else
            {
                // There was no explicit visual state specified, so we will use "gray" for unchecked
                //
                setColor("Gray"); // !!! CSS?
            }
        }
    }

    this.getChecked = function()
    {
        var isChecked = button.classList.contains("checked");
        return isChecked;
    }

    this.setChecked = function(checked)
    {
        if (checked)
        {
            logger.info("Toggle button set to checked");
            button.classList.add("checked");
        }
        else
        {
            logger.info("Toggle button set to unchecked");
            button.classList.remove("checked");
        }
        this.updateVisualState(checked);
    }

    this.processElementProperty(controlSpec, "caption", function(value) 
    { 
        self._caption = self.toString(value); 
        setCaption(self._caption);
        self.updateVisualState();
    });

    this.processElementProperty(controlSpec, "checkedcaption", function(value) 
    {
        self._checkedcaption = self.toString(value); 
        self.updateVisualState();
    });

    this.processElementProperty(controlSpec, "uncheckedcaption", function(value) 
    {
        self._uncheckedcaption = self.toString(value); 
        self.updateVisualState();
    });

    this.processElementProperty(controlSpec, "icon", function(value) 
    {
        self._icon = self.toString(value); 
        setIcon(self._icon);
        self.updateVisualState();
    });

    this.processElementProperty(controlSpec, "checkedicon", function(value) 
    {
        self._checkedicon = self.toString(value); 
        self.updateVisualState();
    });

    this.processElementProperty(controlSpec, "uncheckedicon", function(value) 
    {
        self._uncheckedicon = self.toString(value); 
        self.updateVisualState();
    });

    this.processElementProperty(controlSpec, "color", function(value) 
    { 
        // The framework will set the color, so we don't need to do that.  We just want to remember it for now.
        self._color = self.toColor(value);
        self.updateVisualState();
    });

    this.processElementProperty(controlSpec, "checkedcolor", function(value) 
    {
        self._checkedcolor = self.toColor(value);
        self.updateVisualState();
    });

    this.processElementProperty(controlSpec, "uncheckedcolor", function(value) 
    {
        self._uncheckedcolor = self.toColor(value);
        self.updateVisualState();
    });

    this.processElementProperty(controlSpec, "alt", function(value) 
    {
        button.alt = self.toString(value);
    });

    var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, "value", WebToggleButtonWrapper.commands);

    this.processCommands(bindingSpec, WebToggleButtonWrapper.commands);

    if (!this.processElementBoundValue("value", bindingSpec["value"], function() { return new JToken(self.getChecked()) }, function(value) { self.setChecked(self.toBoolean(value)) }))
    {
        this.processElementProperty(controlSpec, "value", function(value) { self.setChecked(self.toBoolean(value)) });
    }

    button.addEventListener("click", this.OnToggle.bind(this), false);
}
WebToggleButtonWrapper.prototype = Object.create(WebControlWrapper.prototype);

WebToggleButtonWrapper.commands = [ CommandInstance.commandNames.OnToggle ];

WebToggleButtonWrapper.prototype.OnToggle = function()
{
    logger.info("Toggle state changed");

    this.setChecked(!this.getChecked());

    this.updateValueBindingForAttribute("value");

    var command = this.getCommand(CommandInstance.commandNames.OnToggle);
    if (command != null)
    {
        logger.info("Toggle button state with command: %s", command.getCommand());
        this._stateManager.sendCommandRequestAsync(command.getCommand(), command.getResolvedParameters(this._bindingContext));
    }
}

module.exports = WebToggleButtonWrapper;
