var logger = require('log4js').getLogger("web-border-wrapper");

var WebControlWrapper = require('./web-control-wrapper');

var binding = require('../core/binding');
var CommandInstance = require('../core/command-instance');

// The Border is implemented as a flexbox with a direction of horizontal (row).  The item verticalAlignment will 
// automatically work.  We have to bind the horizontalAlignment attribute of the contained item to the flexbox
// 'justify-content' style value in order to horizontally align the item (same values - flex-start, center, flex-end).
//
var WebBorderWrapper = function(parent, bindingContext, controlSpec)
{
    var self = this;

    this.base = WebControlWrapper;
    this.base(parent, bindingContext, controlSpec);
    logger.info("Border control created");

    this._control = document.createElement("div");
    this._control.classList.add("synchro-border");

    this._control.style.display = "inline-flex";
    this._control.style.flexDirection = "row";
    this._control.style.alignItems = "flex-start";
    this._control.style.flexWrap = "nowrap";

    this.processElementProperty(controlSpec, "border", function(value) { self._control.style.borderColor = self.toColor(value) });

    this.processThicknessProperty(controlSpec, "borderThickness", "border", this._control, function(property, value) 
    { 
        self._control.style[property + "Style"] = "solid";
        self._control.style[property + "Width"] = self.toDeviceUnits(value);
    });
    this.processElementProperty(controlSpec, "cornerRadius", function(value) { self._control.style.borderRadius = self.toDeviceUnits(value) });
    this.processThicknessProperty(controlSpec, "padding", "padding", this._control);

    var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, CommandInstance.commandNames.OnTap, WebBorderWrapper.commands);
    this.processCommands(bindingSpec, WebBorderWrapper.commands);

    if (controlSpec["contents"] != null)
    {
        this.createControls(controlSpec["contents"], function(childControlSpec, childControlWrapper)
        {
            logger.info("Created child control");

            // !!! Need to process star sizing (similar to StackPanel orientation logic, but we're always "row")

            // We are binding the child horizontalAlignment attribute to the "justify-content" value of the container
            // (this works to align the child, since we only have one child).
            //
            childControlWrapper.processElementProperty(childControlSpec, "horizontalAlignment", function(value) 
            {
                self._control.style.justifyContent = self.toHorizontalAlignment(value);
            });

            self._control.appendChild(childControlWrapper._control);
        });
    }

    if (this.getCommand(CommandInstance.commandNames.OnTap) != null)
    {
        // Attach a handler
        logger.info("Adding border onTap handler");
        this._control.addEventListener("click", this.OnTap.bind(this), false);
    }
}

WebBorderWrapper.prototype = Object.create(WebControlWrapper.prototype);

WebBorderWrapper.commands = [ CommandInstance.commandNames.OnTap ];

WebBorderWrapper.prototype.OnTap = function()
{
    logger.info("Border tapped");
    var command = this.getCommand(CommandInstance.commandNames.OnTap);
    if (command != null)
    {
        logger.info("Border tapped with command: %s", command.getCommand());
        this._stateManager.sendCommandRequestAsync(command.getCommand(), command.getResolvedParameters(this._bindingContext));
    }
}

module.exports = WebBorderWrapper;
