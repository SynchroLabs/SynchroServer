var logger = require('log4js').getLogger("web-listbox-wrapper");

var WebControlWrapper = require('./web-control-wrapper');

var binding = require('../core/binding');
var PropertyValue = binding.PropertyValue;
var CommandInstance = require('../core/command-instance');
var JToken = require('../core/json');

var SelectionMode = require('../core/control-wrapper').ListSelectionMode;

var WebListBoxWrapper = function(parent, bindingContext, controlSpec)
{
    this.base = WebControlWrapper;
    this.base(parent, bindingContext, controlSpec);
    logger.info("ListBox control created");

    this._selectionChangingProgramatically = false;
    this._localSelection =  null;

    this._selectionMode = this.toListSelectionMode(this.processElementProperty(controlSpec, "select", null));

    logger.info("Selection mode:", this._selectionMode);

    var listbox = document.createElement("select");
    if (this._selectionMode == SelectionMode.Multiple)
    {
        listbox.multiple = true;
    }

    this._control = listbox;

    var self = this;
    var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, "items", WebListBoxWrapper.commands);

    this.processCommands(bindingSpec, WebListBoxWrapper.commands);

    if (bindingSpec["items"])
    {
        var itemContent = bindingSpec["itemContent"] || "{$data}";

        this.processElementBoundValue(
            "items",
            bindingSpec["items"],
            function() { self.getListboxContents(listbox) },
            function(value) { self.setListboxContents(listbox, self.getValueBinding("items").getBindingContext(), itemContent) }
            );
    }

    if (bindingSpec["selection"])
    {
        var selectionItem = bindingSpec["selectionItem"] || "$data";

        this.processElementBoundValue(
            "selection",
            bindingSpec["selection"],
            function() { self.getListboxSelection(listbox, selectionItem) },
            function(value) { self.setListboxSelection(listbox, selectionItem, value) }
            );
    }

    // Also "change"? (weird semantics)
    listbox.addEventListener("input", this.onSelectionChanged.bind(this), false);
}
WebListBoxWrapper.prototype = Object.create(WebControlWrapper.prototype);

WebListBoxWrapper.commands = [ CommandInstance.commandNames.OnItemClick, CommandInstance.commandNames.OnSelectionChange ];

//public JToken getListboxContents(ListBox listbox)
WebListBoxWrapper.prototype.getListboxContents = function(listbox)
{
    logger.debug("Getting listbox contents");
    /*
    JArray array = new JArray();
    foreach (BindingContextListItem item in listbox.Items)
    {
        array.Add(new JValue(item.GetValue().ToString()));
    }
    return array;
    */
}

//public void setListboxContents(ListBox listbox, BindingContext bindingContext, string itemContent)
WebListBoxWrapper.prototype.setListboxContents = function(listbox, bindingContext, itemContent)
{
    logger.info("Setting listbox contents:", itemContent);

    this._selectionChangingProgramatically = true;

    // Clear any existing contents
    for (var i = listbox.options.length-1; i >= 0; i--)
    {
        listbox.remove(i);
    }

    var itemContexts = bindingContext.selectEach("$data");
    for (var i = 0; i < itemContexts.length; i++)
    {
        var itemContext = itemContexts[i];
        logger.info("Items context:", itemContext);

        // itemContext is the binding context for the list item
        // itemContent is what you select from the list item to populate the listbox entry

        // var listItem = new BindingContextListItem(itemContext, itemContent);

        var option = document.createElement("option");

        // We can use value to store context (as value only)
        option.value = itemContext.getBindingPath(); // !!! Will this help us resolve later?

        option.innerHTML = PropertyValue.expandAsString(itemContent, itemContext);
        listbox.appendChild(option);
    }

    var selectionBinding = this.getValueBinding("selection");
    if (selectionBinding)
    {
        // If there is a "selection" value binding, then we update the selection state from that after filling the list.
        //
        selectionBinding.updateViewFromViewModel();
    }
    else if (this._localSelection)
    {
        // If there is not a "selection" value binding, then we use local selection state to restore the selection when
        // re-filling the list.
        //
        this.setListboxSelection(listbox, "$data", this._localSelection);
    }

    this._selectionChangingProgramatically = false;
}

//public JToken getListboxSelection(ListBox listbox, string selectionItem)
WebListBoxWrapper.prototype.getListboxSelection = function(listbox, selectionItem)
{
    logger.info("Getting listbox selection");

    var options = this._control.options;
    for (var i = 0; i < options.length; i++) 
    {
        opt = options[i];
        if (opt.selected)
        {
            logger.info("Item selected: %s, %s", opt.value, opt.text);
            // !!! is opt.value (bindingPath) relative to root or to control _bindingContext?
            // this._bindingContext.select
        }
    }

    if (this._selectionMode == SelectionMode.Multiple)
    {
        /*
        JArray array = new JArray();
        foreach (BindingContextListItem item in listbox.SelectedItems)
        {
            array.Add(item.GetSelection(selectionItem));
            _bindingContext.Select(selectionItem).GetValue().
        }
        return array;
        */
    }
    else
    {
        /*
        BindingContextListItem item = (BindingContextListItem)listbox.SelectedItem;
        if (item != null)
        {
            return item.GetSelection(selectionItem);
        }
        return new JValue(false); // This is a "null" selection
        */
    }
}

//public void setListboxSelection(ListBox listbox, string selectionItem, JToken selection)
WebListBoxWrapper.prototype.setListboxSelection = function(listbox, selectionItem, selection)
{
    logger.info("Setting listbox selection");

    this._selectionChangingProgramatically = true;

    /*
    if ((this._selectionMode == SelectionMode.Multiple) && (selection is JArray))
    {
        listbox.SelectedItems.Clear();
        foreach (BindingContextListItem listItem in listbox.Items)
        {
            JArray array = selection as JArray;
            foreach (JToken item in array)
            {
                if (JToken.DeepEquals(item, listItem.GetSelection(selectionItem)))
                {
                    listbox.SelectedItems.Add(listItem);
                    break;
                }
            }
        }
    }
    else
    {
        bool itemSelected = false;
        foreach (BindingContextListItem listItem in listbox.Items)
        {
            if (JToken.DeepEquals(selection, listItem.GetSelection(selectionItem)))
            {
                listbox.SelectedItem = listItem;
                itemSelected = true;
                break;
            }
        }

        if (!itemSelected)
        {
            listbox.SelectedItem = null;
        }
    }
    */

    this._selectionChangingProgramatically = false;
}

// async void listbox_SelectionChanged(object sender, SelectionChangedEventArgs e)
WebListBoxWrapper.prototype.onSelectionChanged = function()
{
    logger.info("Listbox selection changed");

    var listbox = this._control;

    var selectionBinding = this.getValueBinding("selection");
    if (selectionBinding)
    {
        this.updateValueBindingForAttribute("selection");
    }
    else if (!this._selectionChangingProgramatically)
    {
        this._localSelection = this.getListboxSelection(listbox, "$data");
    }

    if (!this._selectionChangingProgramatically)
    {
        /*
        if (this._selectionModeNone)
        {
            listbox.SelectedItem = null;
            CommandInstance command = GetCommand(CommandName.OnItemClick);
            if (command != null)
            {
                // For selection mode "None", the command handler resolves its tokens relative to the item selected.
                //
                // There should always be a first "added" item, which represents the current selection (item clicked).
                //
                if ((e.AddedItems != null) && (e.AddedItems.Count > 0))
                {
                    BindingContextListItem listItem = (BindingContextListItem)e.AddedItems[0];
                    await StateManager.sendCommandRequestAsync(command.Command, command.GetResolvedParameters(listItem.BindingContext));
                }
            }
        }
        else
        {
            logger.Debug("Selection changed by user!");
            CommandInstance command = GetCommand(CommandName.OnSelectionChange);
            if (command != null)
            {
                logger.Debug("ListView item click with command: {0}", command);

                if (listbox.SelectionMode == SelectionMode.Single)
                {
                    // For selection mode "Single", the command handler resolves its tokens relative to the item selected.
                    //
                    // There should always be a first "added" item, which represents the current selection.
                    //
                    if ((e.AddedItems != null) && (e.AddedItems.Count > 0))
                    {
                        BindingContextListItem listItem = (BindingContextListItem)e.AddedItems[0];
                        await StateManager.sendCommandRequestAsync(command.Command, command.GetResolvedParameters(listItem.BindingContext));
                    }
                }
                else if (listbox.SelectionMode == SelectionMode.Multiple)
                {
                    // For selection mode "Multiple", the command hander resovles its tokens relative to the listbox, not any list item(s).
                    //
                    await StateManager.sendCommandRequestAsync(command.Command, command.GetResolvedParameters(this.BindingContext));
                }
            }
        }
        */
    }
}

module.exports = WebListBoxWrapper;
