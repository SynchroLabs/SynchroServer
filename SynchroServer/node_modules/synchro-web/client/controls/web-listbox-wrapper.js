var logger = require('log4js').getLogger("web-listbox-wrapper");

var WebControlWrapper = require('./web-control-wrapper');

var binding = require('../core/binding');
var PropertyValue = binding.PropertyValue;
var CommandInstance = require('../core/command-instance');
var JToken = require('../core/json');

var SelectionMode = require('../core/control-wrapper').ListSelectionMode;

var WebListBoxWrapper = function(parent, bindingContext, controlSpec)
{
    var self = this;

    this.base = WebControlWrapper;
    this.base(parent, bindingContext, controlSpec);
    logger.info("ListBox control created");

    this._selectionChangingProgramatically = false;
    this._localSelection =  null;

    var listbox = document.createElement("select");
    listbox.classList.add("synchro-listbox");

    if (controlSpec["control"] === "picker")
    {
        this._selectionMode == SelectionMode.Single;
    }
    else // listbox
    {
        this._selectionMode = this.toListSelectionMode(this.processElementProperty(controlSpec, "select", null));
        if (this._selectionMode == SelectionMode.Multiple)
        {
            // This makes the listbox multi-select
            listbox.multiple = true;
        }

        // By default, a multi-select listbox shows 4 items, and a single select is shown as a dropdown (like the picker).
        // If you set the size element of a single select, then it will present as a listbox, sized to hold that many
        // items.  If there is an explicit CSS height set, then that overrides the listbox "size" attribute.  To make
        // single select listboxes look like listboxes and not pickers, we do this...
        //
        listbox.size = 4;
    }

    this._control = listbox;

    var bindingSpec = binding.getCanonicalBindingSpec(controlSpec, "items", WebListBoxWrapper.commands);

    this.processCommands(bindingSpec, WebListBoxWrapper.commands);

    if (bindingSpec["items"])
    {
        var itemContent = bindingSpec["itemContent"] || "{$data}";

        this.processElementBoundValue(
            "items",
            bindingSpec["items"],
            function() { return self.getListboxContents(listbox) }, // !!! ??? Do we need this?  We never get the listbox contents
            function(value) { self.setListboxContents(listbox, self.getValueBinding("items").getBindingContext(), itemContent) }
            );
    }

    if (bindingSpec["selection"])
    {
        var selectionItem = bindingSpec["selectionItem"] || "$data";

        this.processElementBoundValue(
            "selection",
            bindingSpec["selection"],
            function() { return self.getListboxSelection(listbox, selectionItem) },
            function(value) { self.setListboxSelection(listbox, selectionItem, value) }
            );
    }

    // !!! There is a theorized SelectMode.None item clicked which should fire the OnItemClick command.  Not sure this even makes
    //     sense with the listbox (it does with the listview).

    // Also "change"? (weird semantics)
    listbox.addEventListener("input", this.onSelectionChanged.bind(this), false);
}
WebListBoxWrapper.prototype = Object.create(WebControlWrapper.prototype);

WebListBoxWrapper.commands = [ CommandInstance.commandNames.OnItemClick, CommandInstance.commandNames.OnSelectionChange ];

WebListBoxWrapper.prototype.getListboxContents = function(listbox)
{
    // This should never get called (it's not implemented on iOS either)
    logger.error("Get listbox contents not implemented");
}

WebListBoxWrapper.prototype.setListboxContents = function(listbox, bindingContext, itemContent)
{
    // listbox - DOM elemement
    // bindingContext - BindingContext
    // itemContent - string
    //
    logger.info("Setting listbox contents:", itemContent);

    this._selectionChangingProgramatically = true;

    // Clear any existing contents
    for (var i = listbox.options.length-1; i >= 0; i--)
    {
        listbox.remove(i);
    }

    var itemContexts = bindingContext.selectEach("$data");
    for (var i = 0; i < itemContexts.length; i++)
    {
        var itemContext = itemContexts[i];

        // itemContext is the binding context for the list item
        // itemContent is what you select from the list item (itemContext) to populate the listbox entry

        var option = document.createElement("option");
        option.value = itemContext.getBindingPath(); // item path relative to root binding context
        option.innerHTML = PropertyValue.expandAsString(itemContent, itemContext);
        listbox.appendChild(option);
    }

    var selectionBinding = this.getValueBinding("selection");
    if (selectionBinding)
    {
        // If there is a "selection" value binding, then we update the selection state from that after filling the list.
        //
        selectionBinding.updateViewFromViewModel();
    }
    else if (this._localSelection)
    {
        // If there is not a "selection" value binding, then we use local selection state to restore the selection when
        // re-filling the list.
        //
        this.setListboxSelection(listbox, "$data", this._localSelection);
    }

    this._selectionChangingProgramatically = false;
}

function getSelectedItemBindingPaths(listbox)
{
    var result = [];
    var options = listbox.options;
    for (var i = 0; i < options.length; i++) 
    {
        opt = options[i];
        if (opt.selected)
        {
            logger.info("Item selected: %s, %s", opt.value, opt.text);
            result.push(opt.value);
        }
    }
    return result;
}

WebListBoxWrapper.prototype.getListboxSelection = function(listbox, selectionItem)
{
    // listbox - DOM elemement
    // selectionItem - string
    //
    logger.info("Getting listbox selection");

    var selectedItemBindingPaths = getSelectedItemBindingPaths(listbox);

    if (this._selectionMode == SelectionMode.Multiple)
    {
        var selectedTokens = [];
        for (var i = 0; i < selectedItemBindingPaths.length; i++) 
        {
            var itemContext = this._viewModel.getRootBindingContext().select(selectedItemBindingPaths[i]);
            var selectionContext = itemContext.select(selectionItem);
            selectedTokens.push(selectionContext.getValue().deepClone());
        }
        return new JToken(selectedTokens);
    }
    else
    {
        if (selectedItemBindingPaths.length > 0)
        {
            var itemContext = this._viewModel.getRootBindingContext().select(selectedItemBindingPaths[0]);
            var selectionContext = itemContext.select(selectionItem);
            return selectionContext.getValue().deepClone();
        }
        return new JToken(false); // This is a "null" selection
    }
}

WebListBoxWrapper.prototype.setListboxSelection = function(listbox, selectionItem, selection)
{
    // listbox - DOM elemement
    // selectionItem - string
    // selection - JToken
    //
    logger.info("Setting listbox selection");

    this._selectionChangingProgramatically = true;

    if ((this._selectionMode == SelectionMode.Multiple) && JToken.isArray(selection))
    {
        var options = listbox.options;
        for (var i = 0; i < options.length; i++) 
        {
            var itemSelected = false;

            var itemContext = this._viewModel.getRootBindingContext().select(options[i].value);
            var selectionContext = itemContext.select(selectionItem);

            var selections = selection.getValue()
            for (var j = 0; j < selections.length; j++)
            {
                itemSelected = selectionContext.getValue().deepEquals(selections[j]);
                if (itemSelected)
                {
                    logger.info("Selected item:", selections[j].getValue());
                    break;
                }
            }
            options[i].selected = itemSelected;
        }
    }
    else
    {
        var options = listbox.options;
        for (var i = 0; i < options.length; i++) 
        {
            var itemContext = this._viewModel.getRootBindingContext().select(options[i].value);
            var selectionContext = itemContext.select(selectionItem);

            options[i].selected = selectionContext.getValue().deepEquals(selection);
            if (options[i].selected)
            {
                logger.info("Selected item:", selection.getValue());
            }
        }
    }

    this._selectionChangingProgramatically = false;
}

WebListBoxWrapper.prototype.onSelectionChanged = function()
{
    logger.info("Listbox selection changed");

    var listbox = this._control;

    var selectionBinding = this.getValueBinding("selection");
    if (selectionBinding)
    {
        this.updateValueBindingForAttribute("selection");
    }
    else if (!this._selectionChangingProgramatically)
    {
        this._localSelection = this.getListboxSelection(listbox, "$data");
    }

    if (!this._selectionChangingProgramatically)
    {
        var command = null;

        if (this._selectionMode == SelectionMode.None)
        {
            command = this.getCommand(CommandInstance.commandNames.OnItemClick);
        }
        else
        {
            command = this.getCommand(CommandInstance.commandNames.OnSelectionChange);
        }

        if (command != null)
        {
            if (this._selectionMode == SelectionMode.Multiple)
            {
                // For selection mode "Multiple", the command hander resovles its tokens relative to the listbox, not any list item(s).
                //
                this._stateManager.sendCommandRequestAsync(command.getCommand(), command.getResolvedParameters(this._bindingContext));
            }
            else
            {
                // For selection mode "Single", the command handler resolves its tokens relative to the item selected.
                //
                var selectedItemBindingPaths = getSelectedItemBindingPaths(listbox);
                var itemContext = this._viewModel.getRootBindingContext().select(selectedItemBindingPaths[0]);
                this._stateManager.sendCommandRequestAsync(command.getCommand(), command.getResolvedParameters(itemContext));
            }
        }
    }
}

module.exports = WebListBoxWrapper;
