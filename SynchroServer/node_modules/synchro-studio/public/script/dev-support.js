// Dev Support
//
// ACE editor: https://ace.c9.io/
//
// Esprima parser: http://esprima.org/
//
// jQuery UI Layout plugin: http://layout.jquery-dev.com/
//
// Toastr: http://codeseven.github.io/toastr/
//
toastr.options = 
{
    closeButton: true,
    debug: false,
    positionClass: "toast-bottom-right",
    onclick: null,
    showDuration: 300,
    hideDuration: 1000,
    timeOut: 5000,
    extendedTimeOut: 1000,
    showEasing: "swing",
    hideEasing: "linear",
    showMethod: "fadeIn",
    hideMethod: "fadeOut"
}

Range = require("ace/range").Range;

// !!! Can we just make a CSS class for this and apply/remove it?
//
var selectedOutline = "1px dashed red";
var selectedOutlineOffset = 2;

// Add put and delete AJAX functions
//
//   http://stackoverflow.com/questions/2153917/how-to-send-a-put-delete-request-in-jquery
//
//   http://stepansuvorov.com/blog/2014/04/jquery-put-and-delete/
//
jQuery.each( [ "put", "delete" ], function( i, method ) {
  jQuery[ method ] = function( url, data, callback, type ) {
    if ( jQuery.isFunction( data ) ) {
      type = type || callback;
      callback = data;
      data = undefined;
    }

    return jQuery.ajax({
      url: url,
      type: method,
      dataType: type,
      data: data,
      success: callback
    });
  };
});

// When we add attributes to a control node, we will add them in this order.  When adding a new attribute (one that is not
// present on the node), find the attribute in this list.  If found, navigate up the list until you find an attribute from
// the this list that is present on the node, then insert the attribute being added after that attribue on the node.
//
var controlAttributeOrder =
[
    "control",
    "height",
    "width",
    "color", // Border, Button, Rectangle, Text
    "background",
    "margin",
    "padding", // Border, StackPanel
    "visibility",
    "opacity",
    "enabled",
    "orientation", // ScrollView, StackPanel, WrapPanel
    "horizontalAlignment",
    "verticalAlignment",

    "caption", // Button
    "icon", // Button
    "resource", // Button, Image

    "font", // Edit, Password, Text

    "value", // Text, ProgressRing
    "binding",

    "border", // Border, Rectangle
    "borderThickness", // Border, Rectangle
    "cornerRadius", // Border, Rectangle

    "borderless", // Button

    "lines", // Edit
    "multiline", // Edit
    "placeholder", // Edit

    "ellipsize", // Text
    "textAlignment", // Text

    "url", // WebView

    "movementThreshold", // Location

    "minimum", // ProgressBar, Slider
    "maximum", // ProgressBar, Slider

    "scale", // Image

    "select", // ListBox, ListView

    "itemHeight", // WrapPanel
    "itemWidth", // WrapPanel

    "header", // ListView
    "itemTemplate", // ListView
    "footer", // ListView

    "contents" // Border, Canvas, ScrollView, StackPanel, WrapPanel (all containers), WebView (different meaning)
];

// Control metadata
//
var controlMeta = 
{
    "*": {
        attributes: [
            { caption: "Height", attribute: "height", type: "number" },
            { caption: "Width", attribute: "width", type: "number" },
            { caption: "Visibility", attribute: "visibility", type: "boolean" },
            { caption: "Enabled", attribute: "enabled", type: "boolean" },
            { caption: "Opacity", attribute: "opacity", type: "number" }, // Range: 0-1
            { caption: "Horizontal Alignment", attribute: "horizontalAlignment", type: "select", values: ["Left", "Center", "Right"] },
            { caption: "Vertical Alignment", attribute: "verticalAlignment", type: "select", values: ["Top", "Center", "Bottom"] },
            { caption: "Margin", attribute: "margin", type: "thickness" },
            { caption: "Background", attribute: "background", type: "color" },
        ]
    },
    "border": {
        name: "Border",
        attributes: [
            { caption: "Border Color", attribute: "border", type: "color" },
            { caption: "Border Thickness", attribute: "borderThickness", type: "thickness" },
            { caption: "Corner Radius", attribute: "cornerRadius", type: "number" },
            { caption: "Padding", attribute: "padding", type: "thickness" },
        ],
        bindings: [
            { attribute: "onTap", type: "command" }
        ],
        container: { single: true },
        proto: '{ control: "border", border: "Red", borderThickness: 1, contents: [] }',
    },
    "button": {
        name: "Button",
        attributes: [
            { caption: "Caption", attribute: "caption", type: "string" },
            { caption: "Icon", attribute: "icon", type: "string" },
            { caption: "Color", attribute: "color", type: "color" },
            { caption: "Borderless", attribute: "borderless", type: "boolean" },
            // resource
        ],
        bindings: [
            { attribute: "onClick", type: "command" }
        ],
        proto: '{ control: "button", caption: "Button" }',
    },
    "canvas": {
        name: "Canvas",
        attributes: [
        ],
        container: true,
        proto: '{ control: "canvas", contents: [] }',
    },
    "edit": {
        name: "Edit",
        attributes: [
            { caption: "Font", attribute: "font", type: "font" },
            { caption: "Lines", attribute: "lines", type: "number" },
            { caption: "Multiline", attribute: "multiline", type: "boolean" },
            { caption: "Placeholder", attribute: "placeholder", type: "string" },
        ],
        bindings: [
            { attribute: "value", type: "data" },
            { attribute: "sync", type: "select", values: ["change"], tokens: false }
        ],
        proto: '{ control: "edit" }',
    },
    "image": {
        name: "Image",
        attributes: [
            { caption: "Scale", attribute: "scale", type: "select", values: ["Stretch", "Fit", "Fill"] },
            { caption: "Resource", attribute: "resource", type: "string" },
        ],
        bindings: [
            { attribute: "onTap", type: "command" }
        ],
        proto: '{ control: "image" }',
    },
    "listbox": {
        name: "Listbox",
        attributes: [
            { caption: "Selection", attribute: "select", type: "select", values: ["None", "Single", "Multiple"] },
        ],
        bindings: [
            { attribute: "items", type: "data" },
            { attribute: "selection", type: "data" }, // Where the selection is stored in viewModel
            { attribute: "selectionItem", type: "data", contextAttribute: "items" }, // What identitifies selection (in context of item from "items") - What is stored in viewModel, and what is used to evaluate items for selection
            { attribute: "itemValue", type: "string", contextAttribute: "items" }, // Item value to be displayed, defaults to {$data}
            { attribute: "onItemClick", type: "command" }, // Only called on select == None
            { attribute: "onSelectionChange", type: "command" }, // Only called on select == Single/Multiple - If Single, context is selected item - if Multiple, context is control context
        ], 
        proto: '{ control: "listbx" }',
    },
    "listview": {
        name: "List View",
        attributes: [
            { caption: "Selection", attribute: "select", type: "select", values: ["None", "Single", "Multiple"] },
        ],
        bindings: [
            { attribute: "items", type: "data" },
            { attribute: "selection", type: "data" }, // Where the selection is stored in viewModel
            { attribute: "selectionItem", type: "data", contextAttribute: "items" }, // What identitifies selection (in context of item from "items") - What is stored in viewModel, and what is used to evaluate items for selection
            { attribute: "onItemClick", type: "command" }, // Only called on select == None
            { attribute: "onSelectionChange", type: "command" }, // Only called on select == Single/Multiple - If Single, context is selected item - if Multiple, context is control context
        ],
        container: { attribute: "itemTemplate", single: false, contextAttribute: "items" },
        // !!! We have header and footer containers also - no real way to support those via GUI drag/drop.  Not sure what, if anything, we should do here.
        proto: '{ control: "listview", itemTemplate: [] }',
    },
    "location": {
        name: "Location",
        attributes: [
            { caption: "Movement Threshold", attribute: "movementThreshold", type: "number" },
        ],
        bindings: [
            { attribute: "value", type: "data" }, 
            { attribute: "sync", type: "select", values: ["change"], tokens: false },
            { attribute: "onUpdate", type: "command" }
        ],
        visualElement: false,
        proto: '{ control: "location" }',
    },
    "password": {
        name: "Password",
        attributes: [
            { caption: "Font", attribute: "font", type: "font" },
            { caption: "Placeholder", attribute: "placeholder", type: "string" },
        ],
        bindings: [
            { attribute: "value", type: "data" }, 
            { attribute: "sync", type: "select", values: ["change"], tokens: false }
        ],
        proto: '{ control: "password" }',
    },
    "picker": {
        name: "Picker",
        attributes: [
        ],
        bindings: [
            { attribute: "items", type: "data" },
            { attribute: "selection", type: "data" }, // Where the selection is stored in viewModel
            { attribute: "selectionItem", type: "data", contextAttribute: "items" }, // What identitifies selection (in context of item from "items") - What is stored in viewModel, and what is used to evaluate items for selection
            { attribute: "itemValue", type: "string", contextAttribute: "items" }, // Item value to be displayed, defaults to {$data}
            { attribute: "onSelectionChange", type: "command" }, 
        ],
        proto: '{ control: "picker" }',
    },
    "progressbar": {
        name: "Progress Bar",
        attributes: [
            { caption: "Minimum", attribute: "minimum", type: "number" },
            { caption: "Maximum", attribute: "maximum", type: "number" },
        ],
        bindings: [
            { attribute: "value", type: "data" }
        ],
        proto: '{ control: "progressbar" }',
    },
    "progressring": {
        name: "Progress Ring",
        attributes: [
            { caption: "Value", attribute: "value", type: "boolean" },
        ],
        proto: '{ control: "progressring" }',
    },
    "rectangle": {
        name: "Rectangle",
        attributes: [
            { caption: "Border Color", attribute: "border", type: "color" },
            { caption: "Border Thickness", attribute: "borderThickness", type: "thickness" },
            { caption: "Corner Radius", attribute: "cornerRadius", type: "number" },
            { caption: "Color", attribute: "color", type: "color" },
        ],
        bindings: [
            { attribute: "onTap", type: "command" }
        ],
        proto: '{ control: "rectangle", color: "Green" }',
    },
    "scrollview": {
        name: "Scroll View",
        attributes: [
            { caption: "Orientation", attribute: "orientation", type: "select", values: ["Horizontal", "Vertical"] },
        ],
        container: { single: true },
        proto: '{ control: "scrollview", orientation: "Vertical", contents: [] }',
    },
    "slider": {
        name: "Slider",
        attributes: [
            { caption: "Minimum", attribute: "minimum", type: "number" },
            { caption: "Maximum", attribute: "maximum", type: "number" },
        ],
        bindings: [
            { attribute: "value", type: "data" }
        ],
        proto: '{ control: "slider" }',
    },
    "stackpanel": {
        name: "Stack Panel",
        attributes: [
            { caption: "Orientation", attribute: "orientation", type: "select", values: ["Horizontal", "Vertical"] },
            { caption: "Padding", attribute: "padding", type: "thickness" },
        ],
        container: true,
        proto: '{ control: "stackpanel", orientation: "Vertical", contents: [] }',
    },
    "text": {
        name: "Text",
        attributes: [
            { caption: "Font", attribute: "font", type: "font" },
            { caption: "Color", attribute: "color", type: "color" },
            { caption: "Ellipsize", attribute: "ellipsize", type: "boolean" },
            { caption: "Text Alignment", attribute: "textAlignment", type: "select", values: ["Left", "Center", "Right"] },
            { caption: "Value", attribute: "value", type: "string" },
        ],
        proto: '{ control: "text", value: "Text" }',
    },
    "togglebutton": {
        name: "Toggle Button",
        attributes: [
            // !!!
        ],
        bindings: [
            { attribute: "value", type: "data" }, 
            { attribute: "onToggle", type: "command" }
        ],
        proto: '{ control: "togglebutton" }',
    },
    "toggle": {
        name: "Toggle",
        attributes: [
            // !!!
        ],
        bindings: [
            { attribute: "value", type: "data" }, 
            { attribute: "onToggle", type: "command" }
        ],
        proto: '{ control: "toggle" }',
    },
    "webview": {
        name: "Web View",
        attributes: [
            // !!! contents or url
        ],
        proto: '{ control: "webview" }',
    },
    "wrappanel": {
        name: "Wrap Panel",
        attributes: [
            { caption: "Orientation", attribute: "orientation", type: "select", values: ["Horizontal", "Vertical"] },
            { caption: "Item Height", attribute: "itemHeight", type: "number" },
            { caption: "Item Width", attribute: "itemWidth", type: "number" },
        ],
        container: true,
        proto: '{ control: "wrappanel", orientation: "Horizontal", contents: [] }',
    },
}

// The "container" attribute of control metadata indicates whether the control is a container (of other controls), and if so, which attribute of
// the control contains child controls, and whether the control can contain more than one child control.
//
// The default container attribute is "contents", and by default containers can contain multiple children.  To specify an non-default container
// attribute, use "attribute" with the name of the attribute.  To specifiy single or multiple child controls allowed, use "single" with a true or
// false value.
//
// As a shortcut, you can indicate that the control is a container using all default values by doing:
//
//    container: true
//
// That is equivalent to:
//
//    container: { attribute: "contents", single: false }  
//
// If the container value specifies a "contextAttribute", it means that the contents of the container will be in the binding context represented
// by the context specified in that attribute (and any ancestor contextAttribute values).
// 
// This function returns a fully-specified (canonical) container value, consisting of an object with the properties "attribute" and "single" (if
// controlName represents a valid control type and that control type has a container value specified).
//
function getContainerProperties(controlName)
{
    var containerProps = null;
    if (controlName && controlMeta[controlName])
    {
        containerProps = controlMeta[controlName].container;

        if (containerProps === true)
        {
            containerProps = { };
        }

        if ((containerProps != null) && (typeof containerProps === "object"))
        {
            // Value is object, set defaults for any unset properties
            //
            if (!containerProps.hasOwnProperty("attribute"))
            {
                containerProps.attribute = "contents";
            }
            if (!containerProps.hasOwnProperty("single"))
            {
                containerProps.single = false;
            }
        }
    }
    return containerProps;
}

var layout;
var centerLayout;

function onDocumentReady(modulePathPrefix)
{
    currentModulePathPrefix = modulePathPrefix;

    // http://layout.jquery-dev.com/
    //
    layout = $('body').layout(
    { 
        center__paneSelector: ".ui-layout-center",
        north__spacing_open: 0, // Makes non-sizable
        center__childOptions: {
            center__paneSelector: ".middle-center",
            north__paneSelector:  ".middle-north",
            north__size: 300, 
            south__paneSelector:  ".middle-south",
            south__size: 300, 
            south__initHidden: true,
        },
        east__childOptions: {
            center__paneSelector: ".right-center",
            south__paneSelector:  ".right-south",
        }
    });

    centerLayout = $("div.ui-layout-center").layout();

    initEditor();
    clearPropertyInspectors();

    initModalViewModel();

    $('#debuggerTabsNav a').click(function (e) 
    {
        e.preventDefault();
        $(this).tab('show');
    });
}

var editor;
var ignoreSelChange = false;

var _parsedModule = null;

function getParsedModule()
{
    if (!_parsedModule)
    {
        _parsedModule = esprima.parse(editor.getValue(), { loc: true, comment: true });
    }
    return _parsedModule;
}

function invalidateParsedModule()
{
    _parsedModule = null;
}

function initEditor()
{
    editor = ace.edit("editor");
    editor.setTheme("ace/theme/monokai");
    editor.getSession().setMode("ace/mode/javascript");
    editor.$blockScrolling = Infinity;

    editor.commands.addCommand(
    {
        name: 'saveCommand',
        bindKey: {win: 'Ctrl-S',  mac: 'Command-S'},
        exec: function(editor) 
        {
            onSaveModule();
        },
        readOnly: false // false if this command should not apply in readOnly mode
    });

    editor.on("guttermousedown", function(e)
    { 
        var target = e.domEvent.target; 
        if (target.className.indexOf("ace_gutter-cell") == -1) // !!! ???
            return; 
        if (!editor.isFocused()) 
            return; 
        if (e.clientX > 25 + target.getBoundingClientRect().left) 
            return; 

        var row = e.getDocumentPosition().row 
        if (e.editor.session.getBreakpoints()[row]) 
        {
            console.log("clearBreakpoint");
            clearBreakpoint(currentScriptPath, row);
        }
        else 
        {
            console.log("setBreakpoint");
            setBreakpoint(currentScriptPath, row);
        }
        e.stop();
    });

    editor.session.on("changeBreakpoint", function(e)
    { 
        console.log("Change breakpoint");
    });

    editor.session.on('change', function(e) 
    {
        // e.action (ex, "insert"), e.start, e.end
        console.log("Change content");
        invalidateParsedModule();
        if (!ignoreSelChange)
        {
            onEditorChange();
        }
    });

    editor.session.selection.on('changeCursor', function(e) 
    {
        var pos = editor.selection.getCursor();
        console.log("Change cursor pos - row: %s, col: %s", pos.row, pos.column);
        if (!ignoreSelChange)
        {
            onSelectionChange();
        }
    });

    editor.session.selection.on('changeSelection', function(e) 
    {
        console.log("Change selection");
    });

    // Control palette drag support
    //
    $("#control-list").children().each(function()
    {
        $(this).attr("draggable", true);

        $(this).on('dragstart', function(ev)
        {
            var event = ev.originalEvent;
            console.log("Dragstart:", event);

            // By setting the data into event.dataTransfer, it can be dropped anywhere that supports text (not just on our own editor)
            //
            event.dataTransfer.setData('text', controlMeta[$(this).attr('id')].proto);

            // Set the editor to read-only so that it won't attempt to update its cursor position while we're dragging (since
            // we're going to be doing that ourselves based on logic that takes into account controls as drop targets).
            //
            editor.setReadOnly(true);
        });

        $(this).on('dragend', function(ev)
        {
            var event = ev.originalEvent;
            console.log("Dragend:", event);

            editor.setReadOnly(false);
        });
    });

    //
    // Drag over / drop on editor
    //

    $("#editor").on('dragover', function(ev)
    {
        // Only want to fire this if we're dragging control (otherwise we'll mess up Ace's built-in text drag/drop)
        //
        if (editor.getReadOnly())
        {
            var event = ev.originalEvent;
            //console.log("Dragover:", event);

            var screenPos = editor.renderer.pixelToScreenCoordinates(event.clientX, event.clientY);
            var docPos = editor.session.screenToDocumentPosition(screenPos.row, screenPos.column);
            var target = getEditorDropTarget(docPos);
            if (target)
            {
                showEditorDropTarget(target);
                showUXDropTarget(target);
                event.preventDefault(); // Indicates that drop is supported/allowed
                editor.focus();
            }
            else
            {
                console.log("Clear selection");
                editor.selection.clearSelection();
            }
        }
    });

    $("#editor").on('drop', function(ev)
    {
        if (editor.getReadOnly())
        {
            var event = ev.originalEvent;
            console.log("Dropped:", event);

            var screenPos = editor.renderer.pixelToScreenCoordinates(event.clientX, event.clientY);
            var docPos = editor.session.screenToDocumentPosition(screenPos.row, screenPos.column);
            var target = getEditorDropTarget(docPos);
            if (target)
            {
                var data = event.dataTransfer.getData('Text');
                dropOnEditor(target, data)
                editor.focus();
            }
            else
            {
                editor.selection.clearSelection();
            }

            event.preventDefault();
        }
    });

    //
    // Drag over / drop on UX preview
    //

    $("#synchro_container").on('dragover', function(ev)
    {
        var event = ev.originalEvent;
        //console.log("Dragover:", event);

        var target = getUXDropTarget(event.clientX, event.clientY);
        if (target)
        {
            showUXDropTarget(target);
            showEditorDropTarget(target);
            event.preventDefault(); // Indicates that drop is supported/allowed
        }
        else
        {
            clearUXDropTarget();
        }
    });

    $("#synchro_container").on('dragout', function(ev)
    {
        var event = ev.originalEvent;
        event.preventDefault();
        console.log("Dragout:", event);

        clearUXDropTarget();
    });

    $("#synchro_container").on('drop', function(ev)
    {
        var event = ev.originalEvent;
        event.preventDefault();
        console.log("Dropped:", event);

        clearUXDropTarget();

        var target = getUXDropTarget(event.clientX, event.clientY);
        if (target)
        {
            var data = event.dataTransfer.getData('Text');
            dropOnEditor(target, data)
            editor.focus();
        }
    });
}

var modalViewModelEditor;

function initModalViewModel()
{
    modalViewModelEditor = ace.edit("modalViewModel");
    modalViewModelEditor.setTheme("ace/theme/chrome");
    modalViewModelEditor.setShowPrintMargin(false);
    modalViewModelEditor.renderer.setShowGutter(false);
    modalViewModelEditor.setHighlightActiveLine(false);
    modalViewModelEditor.setReadOnly(true);
    modalViewModelEditor.getSession().setMode("ace/mode/javascript");
    modalViewModelEditor.$blockScrolling = Infinity;

    modalViewModelEditor.getSession().selection.on('changeCursor', function(e) 
    {
        var pos = modalViewModelEditor.selection.getCursor();
        onBindingViewModelClick(pos);
    });

    $('#modalPropValue').on("change paste keyup click", onBindingValueSelection);
    $('#bindingModalSave').click(onBindingSave);

    $('#commandModalSave').click(onCommandSave);
}

var renderView; // renderView(view, viewModel)

function SynchroInit(synchro)
{
    renderView = synchro.renderView;

    var synchroApp =
    {
        container: document.getElementById('synchro_container'), // required
        onSetPageTitle: function(title) // optional
        {
            console.log("Page title set:", title);
            document.getElementById('synchro_title').innerHTML = title;
        },
        logConfig: {}, // optional, developer setting
    }

    return synchroApp;
}

function getEditorDropTarget(docPos)
{
    // Deterine the element that is being dragged over, and where to insert the dragged element relative to that element (before, 
    // after, or into).
    //
    var view = getViewNode();
    var elementsProp = getNodeProperty(view, "elements");
    var elements = elementsProp && elementsProp.value;
    if (view && elements && nodeContainsPos(elements, docPos))
    {
        var target = 
        {
            node: view,
            position: "into",
            attribute: "elements"
        }

        var contentsArrayNode = elements;

        var controlNode = findControlInModule(docPos);
        if (controlNode)
        {
            target.node = controlNode;
            target.attribute = null;
            contentsArrayNode = null;

            var containerProps = getContainerProperties(getNodePropertyValueAsString(target.node, "control"));
            if (containerProps)
            {
                var contents = getNodeProperty(target.node, containerProps.attribute);
                if (nodeContainsPos(contents, docPos) && (!containerProps.single || (contents.value.elements.length == 0)))
                {
                    // If the control is a container, and the docPos is in the controls container attribute, and the control is either
                    // a multiple container or the contents are currently empty, then we can drop into the contents attribute.
                    //
                    target.attribute = containerProps.attribute;
                    contentsArrayNode = contents.value;
                }
            }
        }

        if (contentsArrayNode && (contentsArrayNode.type === 'ArrayExpression'))
        {
            // We are in a contents array (in an elements or contents attribute, but not over an actual control).
            //
            // If the contents array is empty, we will keep the default position of "into", otherwise we will determine
            // the control in the contents array that the drop target should be before or after, and the position of the
            // drop target.
            //
            if (contentsArrayNode.elements.length > 0)
            {
                var beforeElement = -1;
                for (var i = 0; i < contentsArrayNode.elements.length; i++)
                {
                    var contentRange = rangeFromLocation(contentsArrayNode.elements[i].loc);
                    if (contentRange.comparePoint(docPos) == -1)
                    {
                        beforeElement = i;
                        break;
                    }
                }

                if (beforeElement >= 0)
                {
                    // Before the given element
                    //
                    target.node = contentsArrayNode.elements[beforeElement];
                    target.position = "before";
                    target.attribute = null;
                }
                else
                {
                    // After the last element
                    //
                    target.node = contentsArrayNode.elements[contentsArrayNode.elements.length-1];
                    target.position = "after";
                    target.attribute = null;
                }
            }
        }
        else if (controlNode)
        {
            var parentContainerProps = getContainerProperties(getNodePropertyValueAsString(controlNode.parent, "control"));
            if (parentContainerProps && parentContainerProps.single)
            {
                // This control's parent is a single container (and thus is already "full" because the control in question is inside it).
                // Drop is not permitted.  We could potentially try to walk up the tree to find a legal drop target, but if you're over
                // a control in a single control container, showing no drop is probably the clearest way to communicate what's going on.
                //
                // console.log("Potential drop target is control inside of a 'single' container, no drop allowed");
                return null;
            }

            // We are over a control that is not in a single container parent, so this control is our target.  We determine whether the 
            // position is before or after by testing which end of the target control range is closest to the drag location.
            //
            target.node = controlNode;
            target.position = isCloserToRangeStart(rangeFromLocation(controlNode.loc), docPos) ? "before" : "after";
            target.attribute = null;
        }

        return target;
    }
}

function showEditorDropTarget(target)
{
    if (target.position === "into")
    {
        // Place cursor in the elements/contents attribute value (which should be an empty ArrayExpression) - just advance
        // one char past start of ArrayExpression value.
        //
        var contentsProp = getNodeProperty(target.node, target.attribute);
        if (contentsProp && (contentsProp.value.type === 'ArrayExpression'))
        {
            var contentValueRange = rangeFromLocation(contentsProp.value.loc);
            contentValueRange.moveBy(0, 1);
            contentValueRange.setEnd(contentValueRange.start);
            editor.selection.setSelectionRange(contentValueRange);
        }
    }
    else
    {
        // Select target control and place cursor at beginning or end of selection as appropriate.
        //
        var range = rangeFromLocation(target.node.loc);
        editor.selection.setSelectionRange(range, target.position === 'before');
    }
}

function dropOnEditor(target, data)
{
    console.log("dropOnEditor target:", target);

    if (target.position === "into")
    {
        // Drop into the "contents" attribute value (which should be an empty ArrayExpression) - just advance one char past
        // start of ArrayExpression value.
        //
        var contentsProp = getNodeProperty(target.node, target.attribute);
        if (contentsProp && (contentsProp.value.type === 'ArrayExpression'))
        {
            var contentValueRange = rangeFromLocation(contentsProp.value.loc);
            contentValueRange.moveBy(0, 1);

            // Put the new item on it's own line (indented property), and put the close square bracked on its own line...
            //
            var targetRange = rangeFromLocation(target.node.loc);
            var insert = "\n" + spaces(targetRange.start.column + 4) + data + "\n" + spaces(targetRange.start.column);
            var end = editor.getSession().insert(contentValueRange.start, insert);

            // We only want to select the inserted control (not any other added formatting or whitespace)
            //
            var dataRange = Range.fromPoints(
                { row: contentValueRange.start.row + 1, column: targetRange.start.column + 4 },
                { row: contentValueRange.start.row + 1, column: targetRange.start.column + 4 + data.length }
            );
            editor.selection.setSelectionRange(dataRange);
        }
    }
    else if (target.position === 'before')
    {
        // Put the new control on it's own line, aligned with the control it's being placed before
        //
        var range = rangeFromLocation(target.node.loc);
        var insert = data + ", \n" + spaces(range.start.column);
        var end = editor.getSession().insert(range.start, insert);

        // We only want to select the inserted control (not any other added formatting or whitespace)
        //
        var dataRange = Range.fromPoints(range.start, {row: range.start.row, column: range.start.column + data.length});
        editor.selection.setSelectionRange(dataRange);
    }
    else if (target.position === 'after')
    {
        // Put the new control on it's own line, aligned with the control it's being placed after
        //
        var range = rangeFromLocation(target.node.loc);
        var insert = ",\n" + spaces(range.start.column) + data;
        var end = editor.getSession().insert(range.end, insert);

        // We only want to select the inserted control (not any other added formatting or whitespace)
        //
        var dataRange = Range.fromPoints({row: range.end.row + 1, column: range.start.column}, end);
        editor.selection.setSelectionRange(dataRange);
    }
}

function isPositionBefore(element, orientation, clientX, clientY)
{
    var offset = $(element).offset();
    var width = $(element).outerWidth();
    var height = $(element).outerHeight();
    var hPos = (clientX - offset.left) / width; // Horizontal position in control, range: 0-1
    var vPos = (clientY - offset.top) / height; // Vertical position in control, range: 0-1
    // console.log("clientX: %d, clientY: %d, width: %d, height: %d, hPos: %s, vPos: %s", clientX, clientY, width, height, hPos, vPos);

    // Our "position within control" value to be used in target position calc below depends on our parent orientation.
    //
    var pos = (orientation === "Horizontal") ? hPos : vPos;

    return  pos <= 0.5; // Are we in the first half of the control, in the direction of orientation (such that we'd want to insert "before")
}

function getOrientation(element)
{
    return element.style.flexDirection == "column" ? "Vertical" : "Horizontal"
}

// If the control we are over is an empty container, drop target is the container and position is "into".
//
// If the control we are over is a non-empty container, we need to evaluate our position relative to the orientation 
// of our parent for each contained child control to see which one should be the target and what the position (before/after)
// should be.
//
// If the control we are over is not a container, we just look at our position in the control relative to the orientation
// of our parent to determine if the drop target is before or after the target.
//
function getUXDropTarget(clientX, clientY)
{
    // Get Synchro UX control (HTML element) from point
    //
    var synchroControl = getSynchroControlFromPoint(clientX, clientY);
    //console.log("Synchro control over:", synchroControl);

    // We assume that this function is only called when dragging over synchro_container
    //
    var view = getViewNode();

    var target = 
    {
        node: view,
        position: "into",
        attribute: "elements",
        orientation: "Vertical"
    }

    var container = $("#synchro_container");

    // When the top level 'elements' contains more than one control, a synthetic "stackpanel" will be created to hold those 
    // controls.  In that case, we want to treat that control as the container.
    //
    var elementsProp = getNodeProperty(view, "elements");
    if (elementsProp && (elementsProp.value.type == 'ArrayExpression'))
    {
        if (elementsProp.value.elements.length > 1)
        {
            // More than one control in 'elements', promote synthetic "stackpanel" to container.
            //
            container = $(container.children('[class*="synchro-"]')[0]);
        }
    }

    // Check to see if we are over a container control, so that if so, we can positon relative to container contents below.
    //
    if (synchroControl)
    {
        var node = getViewNodeFromUXControl(synchroControl); // This will return null on top level "elements" (synthesized container)
        if (node)
        {
            target.node = node;
            container = null;

            var containerProps = getContainerProperties(getNodePropertyValueAsString(target.node, "control"));
            if (containerProps)
            {
                var contents = getNodeProperty(target.node, containerProps.attribute);
                if (!containerProps.single || (contents.value.elements.length == 0))
                {
                    // If the control is a container, and the control is either a multiple container or the contents are currently empty, 
                    // then we can drop into the contents...
                    //
                    target.attribute = containerProps.attribute;
                    container = $(synchroControl);
                }
            }
        }
    }

    if (container) // We are over a container, position relative to container contents.
    {
        // Enum direct children that are synchro controls.  If not emoty, then loop through them to find the target and relative
        // position (based on control location, orientation of parent container, and client coordinates).
        //
        var children = container.children('[class*="synchro-"]');
        if (children.length > 0)
        {
            var beforeElement = -1;
            target.orientation = getOrientation(container.get(0));

            // !!! This logic of iterating container children and determining insertion target based on "is before" works with
            //     linear layouts (like stackpanel, or a wrappanel that does not wrap).  But this will not work on a wrappanel
            //     that has wrapped for items not in the first row/col.  And canvas is a whole-nother ball of wax.
            //  
            for (var i = 0; i < children.length; i++)
            {
                if (isPositionBefore(children[i], target.orientation, clientX, clientY))
                {
                    beforeElement = i;
                    break;
                }
            }

            if (beforeElement >= 0)
            {
                // Before the given element
                //
                target.node =  getViewNodeFromUXControl(children[beforeElement]);
                target.position = "before";
                target.attribute = null;
            }
            else
            {
                // After the last element
                //
                target.node =  getViewNodeFromUXControl(children[children.length-1]);
                target.position = "after";
                target.attribute = null;
            }
        }
    }
    else // We are not over a container, position relative to control we are over.
    {
        var parent = $(synchroControl).parent();
        if (parent && (parent.length > 0))
        {
            var parentNode = getViewNodeFromUXControl(parent.get(0));
            if (parentNode)
            {
                var parentContainerProps = getContainerProperties(getNodePropertyValueAsString(parentNode, "control"));
                if (parentContainerProps && parentContainerProps.single)
                {
                    // This control's parent is a single container (and thus is already "full" because the control in question is inside it).
                    // Drop is not permitted.  We could potentially try to walk up the tree to find a legal drop target, but if you're over
                    // a control in a single control container, showing no drop is probably the clearest way to communicate what's going on.
                    //
                    // console.log("Potential drop target is control inside of a 'single' container, no drop allowed");
                    return null;
                }
            }

            // flexDirection "column" is vertical, "row" is horizontal (default)
            //
            target.orientation = getOrientation(parent.get(0));
        }

        // !!! This is going to have the same problem as documented above - it really only works with containers that have a linear layout.
        //
        target.position = isPositionBefore(synchroControl, target.orientation, clientX, clientY) ? "before" : "after";
        target.attribute = null;
    }

    if (!target.node)
    {
        console.log("Target node not found:", target);
    }

    return target;
}

function showUXDropTarget(target)
{
    clearUXDropTarget();

    var synchroControl = $("#synchro_container");
    if (target.attribute != 'elements')
    {
        synchroControl = selectVisualElementFromIndexes($("#synchro_container"), target.node.indexes);
    }

    if (synchroControl)
    {
        if (target.position === 'into')
        {
            // For "into", we just highlight the container (which should be empty)
            //
            $(synchroControl).css("outline", selectedOutline);
            $(synchroControl).css("outline-offset", selectedOutlineOffset);
        }
        else
        {
            // Determine orientation if not already set (such as when drop target determined from edit control)
            //
            if (!target.orientation)
            {
                target.orientation = "Vertical";
                var parent = $(synchroControl).parent();
                if (parent && (parent.length > 0))
                {
                    target.orientation = getOrientation(parent.get(0));
                }
            }

            // For "before" or "after", we create and position a placeholder element to show where the insertion
            // would go relative to the target node element.
            //
            var placeholder = document.createElement("div");
            placeholder.id = 'placeholder';
            placeholder.style.position = 'absolute';
            placeholder.style.pointerEvents = 'none';
            placeholder.style.background = '#000000';

            var pos = $(synchroControl).position();

            // Note: pos incluces margins, so we need to add in top/left margin.  The parseInt is required
            //       because JQuery appends "px" to the numeric values.
            //
            pos.top += parseInt($(synchroControl).css('margin-top'));
            pos.left += parseInt($(synchroControl).css('margin-left'));

            // Adjust for parent scroll
            //
            pos.top += $('#synchro_container').parent().scrollTop();
            pos.left += $('#synchro_container').parent().scrollLeft();

            // Size and position placeholder
            //
            var thickness = 1;
            var padding = 4;

            if (target.orientation === 'Horizontal')
            {
                placeholder.style.height = $(synchroControl).outerHeight() + 'px';
                placeholder.style.width = thickness + 'px';

                if (target.position === 'before')
                {
                    placeholder.style.top = pos.top + 'px'; 
                    placeholder.style.left = pos.left - padding + 'px';
                }
                else // after
                {
                    placeholder.style.top = pos.top + 'px'; 
                    placeholder.style.left = pos.left + $(synchroControl).outerWidth() + padding + 'px';
                }
            }
            else // Vertical
            {
                placeholder.style.height = thickness + 'px';
                placeholder.style.width = $(synchroControl).outerWidth() + 'px';

                if (target.position === 'before')
                {
                    placeholder.style.top = pos.top - padding + 'px';
                    placeholder.style.left = pos.left + 'px';
                }
                else // after
                {
                    placeholder.style.top = pos.top + $(synchroControl).outerHeight() + padding + 'px';
                    placeholder.style.left = pos.left + 'px';
                }
            }

            $("#synchro_container").parent().append(placeholder);
            $('#placeholder').css("outline", selectedOutline);
            $('#placeholder').css("outline-offset", selectedOutlineOffset);
        }
    }
}

function clearUXDropTarget(target)
{
    $('#placeholder').remove();
    $('#synchro_container').find('[class*="synchro-"]').css('outline', '');
}

function spaces(n)
{
    var str = "";
    for (var i = 0; i < n; i++) 
    {
        str += ' ';
    }
    return str;
}

// Return the distance between two points in the editor
//
function distance(point1, point2)
{
    // In the Ace editor the rows are about twice as tall as the columns are wide, so we'll double the row delta to make
    // the distance calculation work.
    //
    return Math.sqrt(Math.pow((point1.row - point2.row) * 2, 2) + Math.pow(point1.column - point2.column, 2));
}

// Return a boolean indicating whether the provided point is closer to the start of the range than the end.
//
function isCloserToRangeStart(range, point)
{
    return (distance(range.start, point) < distance(range.end, point));
}

function rangeFromLocation(loc)
{
    // Note: Parser "location" line values are 1-based, whereas document range rows are 0-based (even though the line numbering
    //       shown in the editor starts with 1).
    //
    var range = new Range(loc.start.line-1, loc.start.column, loc.end.line-1, loc.end.column);
    return range;
}

function getViewNode(parsed)
{
    try
    {
        var parsed = parsed || getParsedModule();
        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'View'))
                {
                    return exp.expression.right;
                }
            }
        }
    }
    catch (e)
    {
        console.log("Err:", e);
    }
}

function getViewModel(parsed)
{
    var viewModel;

    try
    {
        var designViewModelNode;
        var initViewModelNode;
        var initViewModelFnNode;

        var parsed = parsed || getParsedModule();
        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                // Look for a top-level "var designViewModel = {}"
                //
                if ((exp.type === 'VariableDeclaration') && (exp.declarations[0].id.name === 'designViewModel'))
                {
                    designViewModelNode = exp.declarations[0].init;
                }

                // Look for a top-level exports.InitializeViewModel function, and inside that, look for a "var viewModel = {}"
                //
                // Note: This will often fail to eval for real implementations as there may be variables or code in the viewModel object
                //       member values that can't be evaluated client-side at design time.  In these cases, the "designViewModel" should
                //       be used if design-time support is desired.
                //
                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'InitializeViewModel'))
                {
                    initViewModelFnNode = exp.expression.right;

                    if ((exp.expression.right.type === 'FunctionExpression') && (exp.expression.right.body.type === 'BlockStatement'))
                    {
                        var body = exp.expression.right.body.body;
                        for (var j = 0; j < body.length; j++)
                        {
                            if ((body[j].type === 'VariableDeclaration') && (body[j].declarations[0].id.name === 'viewModel'))
                            {
                                initViewModelNode = body[j].declarations[0].init;
                            }
                        }
                    }
                }
            }
        }

        // Define Synchro.getResourceUrl() here so eval can use it to resolve resource URLs
        //
        var Synchro = {
            getResourceUrl: function(context, resource) 
            {
                // Convert base document url in the form: http://host/studio/<appname>/dev#foo
                // Into a resource URL in the form:       http://host/api/<appname>/resources/<resource>
                //
                var url = document.URL.replace(/(^.*\/)(studio)(\/.*)(\/dev.*$)/, "$1api$3") + "/resources/" + resource;
                console.log("Get resource: %s, resolved to url:", resource, url);
                return url;
            }
        }

        if (designViewModelNode) // var designViewModel = {}
        {
            var range = rangeFromLocation(designViewModelNode.loc);
            eval("viewModel = " + editor.getSession().getTextRange(range));
        }
        else if (initViewModelFnNode) // fall back to var viewModel = {} from exports.InitializeViewModel
        {
            try
            {
                // First, we're going to try to actually run the InitializeViewModel function.  Since we're running it client
                // side, and it doesn't even have access to the rest of the module, this will fail in lots of cases.
                //
                // The general idea is that if your InitializeViewModel is too complex to run client side, then you should
                // implement a designViewModel to support view editing.
                //
                console.log("Running IntializeViewModel");

                var context = {};
                var session = {};
                var params = null;
                var state = null;

                var range = rangeFromLocation(initViewModelFnNode.loc);
                eval(
                    "var initializeViewModel = " + editor.getSession().getTextRange(range) + '\n' +
                    "viewModel = initializeViewModel(context, session, params, state);"
                );
            }
            catch (e)
            {
                console.log("Error running IntializeViewModel:", e);

                // If we fail in execution of InitializeViewModel, lets fall back and see of we can just eval the contents of
                // the "var viewModel =" assignment (if present)
                //
                if (initViewModelNode)
                {
                    try
                    {
                        console.log("Evaluating viewModel contents from InitializeViewModel");
                        var range = rangeFromLocation(initViewModelNode.loc);
                        eval("viewModel = " + editor.getSession().getTextRange(range));
                    }
                    catch (e)
                    {
                        console.log("Failed to evaluate viewModel content from InitializeViewModel:", e);
                    }
                }
            }
        }
        else
        {
            throw new Error('Unabled to find or designViewModel or exports.InitializeViewModel');
        }

    }
    catch (e)
    {
        console.log("Err:", e);
    }

    return viewModel;
}

function getCommandsNode(parsed)
{
    try
    {
        var parsed = parsed || getParsedModule();
        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'Commands'))
                {
                    return exp.expression.right;
                }
            }
        }
    }
    catch (e)
    {
        console.log("Err:", e);
    }
}

function updateView()
{
    try
    {
        var parsed = getParsedModule();

        var view;
        var viewModel = {};

        var viewNode = getViewNode(parsed);
        if (viewNode)
        {
            // This is a little creepy.  The View defintion in a Synchro module is not required to be JSON encoded (it's a
            // JavaScript object).  So, for example, keys do not need to be quoted, and there can even be code in the values
            // being assigned (though we're not trying to support that).  For this reason, we need to parse the found View as
            // a JavaScript object, not as JSON.  The only way to do that is with good old eval().
            //
            var range = rangeFromLocation(viewNode.loc);
            eval("view = " + editor.getSession().getTextRange(range));
        }

        if (view)
        {
            viewModel = getViewModel(parsed);
            if (!viewModel)
            {
                throw new Error('Unabled to successfully process (evaluate) ViewModel');
            }

            renderView(view, viewModel);
        }
    }
    catch (e)
    {
        console.log("Error rendering view:", e);
        renderView({elements:[]}, {});
    }
}

function selectViewNodeFromIndexes(indexes)
{
    var controlNode;
    var indexesCopy = indexes.slice(0); // We don't want to modify passed-in indexes array

    try
    {
        var parsed = getParsedModule();
        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'View'))
                {
                    var viewNode = exp.expression.right;
                    if (viewNode.type === 'ObjectExpression')
                    {
                        for (var i = 0; i < viewNode.properties.length; i++)
                        {
                            if (viewNode.properties[i].key.name === 'elements')
                            {
                                controlNode = viewNode.properties[i].value;
                                break;
                            }
                        }
                    }

                    // console.log("ControlNode:", JSON.stringify(controlNode, null, 4));

                    if (controlNode.elements.length > 1)
                    {
                        // If "elements" contains more than one control, then Synchro will wrap that control with a container (a vertical StackPanel).
                        // We want to remove that index operation from our indexes stack in that case.
                        // 
                        indexesCopy.pop(); 
                    }

                    if (indexesCopy.length == 0)
                    {
                        return null;
                    }

                    while (controlNode && indexesCopy.length)
                    {
                        if (controlNode.type === 'ObjectExpression')
                        {
                            for (var j = 0; j < controlNode.properties.length; j++)
                            {
                                if ((controlNode.properties[j].key.name === 'contents') && (controlNode.properties[j].value.type === 'ArrayExpression'))
                                {
                                    //console.log("Promoting 'contents' ArrayExpression");
                                    controlNode = controlNode.properties[j].value;
                                    break;
                                }
                            }
                        }

                        if (controlNode.type === 'ArrayExpression')
                        {
                            //console.log("Getting ArrayExpression element:", indexesCopy[indexesCopy.length-1]);
                            controlNode = controlNode.elements[indexesCopy.pop()];
                        }
                        else
                        {
                            console.log("Ended prematurely (ran out of elements) - controlNode.type:", controlNode.type);
                            controlNode = null;
                        }
                    }

                    if (controlNode)
                    {
                        controlNode.indexes = indexes.slice(0).reverse(); // Reversed copy of original indexes used to find this element
                    }
                }
            }
        }
    }
    catch (e)
    {
        console.log("Err:", e);
    }

    return controlNode;
}

// document.elementFromPoint() only returns the top-most (in the view heirarchy) element.  We want the bottom-most one (the most specific
// element).  This function gets the top-most element, hides it temporarily, then gets the next top-most element, and so on, restoring it
// all at the end, and returning an array of elements (with the top-most at the start and the bottom-most at the end).
//
// http://stackoverflow.com/a/27884653/1227119
//
function allElementsFromPoint(x, y) 
{
    var element, elements = [];
    var old_visibility = [];
    while (true) 
    {
        element = document.elementFromPoint(x, y);
        if (!element || element === document.documentElement) 
        {
            break;
        }
        elements.push(element);
        old_visibility.push(element.style.visibility);
        element.style.visibility = 'hidden'; // Temporarily hide the element (without changing the layout)
    }
    for (var k = 0; k < elements.length; k++) 
    {
        elements[k].style.visibility = old_visibility[k];
    }
    elements.reverse();
    return elements;
}

// Find the bottom-most (from the tree perspective) Synchro control from a point (you could think if this as the top-most Synchro control
// in terms of the view heirarchy, as it is in front of any containing controls).
//
function getSynchroControlFromPoint(x, y)
{
    var elements = allElementsFromPoint(x, y);

    var synchroControl = null;
    for (var i = 0; i < elements.length; i++)
    {
        if ($(elements[i]).is('[class*="synchro-"]'))
        {
            synchroControl = elements[i];
        }
    }

    return synchroControl;
}

// Use the mouse to hover over Synchro controls in the rendered view, clicking the desired control to select it in the code window.
//
function selectControl()
{
    // Disable mouse/pointer events for all of our controls (so we can click to select them without interacting with them)
    //
    $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', 'none');

    // Remove any current visual item selection
    //
    $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

    $('#synchro_container').click(function(event)
    {
        // If pointer-events are suppressed, we won't be able to find any Synchro controls...
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', '');

        var synchroControl = getSynchroControlFromPoint(event.clientX, event.clientY);
        console.log("Synchro control clicked:", synchroControl);

        var viewNode = getViewNodeFromUXControl(synchroControl);
        selectNode(viewNode);

        $('#synchro_container').off('click mousemove mouseout');
        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

        return false;
    });

    $('#synchro_container').mousemove(function(event)
    {
        // If pointer-events are suppressed, we won't be able to find any Synchro controls...
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', '');

        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

        var synchroControl = getSynchroControlFromPoint(event.clientX, event.clientY);
        if (synchroControl)
        {
            $(synchroControl).css("outline", selectedOutline);
            $(synchroControl).css("outline-offset", selectedOutlineOffset);
        }

        // Re-suppress pointer-events
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', 'none');

        return false;
    });

    $('#synchro_container').mouseout(function(event)
    {
        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');
        return false;
    });
}

function getViewNodeFromUXControl(synchroControl)
{
    var parents = $(synchroControl).parents('[class*="synchro-"]');
    var indexes = [$(synchroControl).index()];
    for (var i = 0; i < parents.length; i++)
    {
        indexes.push($(parents[i]).index());
    }
    // console.log("Indexes:", indexes);

    var viewNode = selectViewNodeFromIndexes(indexes);
    // console.log("View node:", viewNode);

    return viewNode;
}

function nodeContainsPos(node, point)
{
    var range = rangeFromLocation(node.loc);
    return range.contains(point.row, point.column);
}

// The function returns the inner-most matching node base on the specified test.
//
// The "test" param is a function that recieves a node and returns true if the node matches.
//
function findControl(node, test, indexer)
{
    //console.log("Inspecting node of type:", node.type);

    var theIndexer = indexer || { indexes: [], currIndex: null };
    var parentControl = theIndexer.parentControl;

    var isControl = false;
    var qualifyingControl = null;
    var arrayToProcess = null;

    if (node.type === 'Program')
    {
        arrayToProcess = node.body;
    }
    else if (node.type === 'ExpressionStatement')
    {
        qualifyingControl = findControl(node.expression, test, theIndexer);
    }
    else if (node.type === 'AssignmentExpression')
    {
        // operator, left, right
        qualifyingControl = findControl(node.right, test, theIndexer);
    }
    else if (node.type === 'ObjectExpression')
    {
        isControl = !!getNodeProperty(node, 'control');
        if (isControl)
        {
            node.parent = theIndexer.parentControl;
            theIndexer.parentControl = node;
        }

        if (test(node))
        {
            var elementsProp = getNodeProperty(node, 'elements');
            if (elementsProp && elementsProp.value.elements.length > 1)
            {
                // If "elements" contains more than one control, then Synchro will wrap that control with a 
                // container (a vertical StackPanel).  We need to add an extra index (at 0) to accomodate that
                // "extra" control in the visual layout.
                // 
                // console.log("Found 'elements' with multiple elements");
                theIndexer.indexes.push(0);
            }

            if (isControl)
            {
                // console.log("qualifying control at index:", theIndexer.currIndex);
                theIndexer.indexes.push(theIndexer.currIndex);
                qualifyingControl = node;
            }
        }

        arrayToProcess = node.properties;
    }
    else if (node.type === 'ArrayExpression')
    {
        arrayToProcess = node.elements;
    }
    else if (node.type === 'Property')
    {
        qualifyingControl = findControl(node.value, test, theIndexer); 
    }
    else if (node.type === 'Literal')
    {
        // node.value is value 
    }

    if (arrayToProcess)
    {
        for (var i = 0; i < arrayToProcess.length; i++)
        {
            theIndexer.currIndex = i;
            var result = findControl(arrayToProcess[i], test, theIndexer);
            if (result)
            {
                qualifyingControl = result;
                break;
            }
        }
    }

    if (qualifyingControl && (typeof indexer === 'undefined'))
    {
        // console.log("Final indexes:", theIndexer.indexes);
        qualifyingControl.indexes = theIndexer.indexes;
    }

    theIndexer.parentControl = parentControl;

    return qualifyingControl;
}

function findControlInModule(point)
{
    var options = 
    {
        loc: true,
        comment: true
    }

    try
    {
        var parsed = getParsedModule();
        return findControl(parsed, function(node)
        {
            return nodeContainsPos(node, point);
        });
    }
    catch (e)
    {
        // We don't really care about parsing errors (these happen a lot as we're editing code)
    }
}

function selectNode(node)
{
    var range = rangeFromLocation(node.loc);
    editor.selection.setSelectionRange(range, false);
}

function replaceNode(node, value)
{
    var range = rangeFromLocation(node.loc);
    editor.getSession().replace(range, value);
}

function removeNode(node)
{
    var range = rangeFromLocation(node.loc);

    // If the characters immediately following the node are ", " then we want to remove those as well...
    //
    var followRange = new Range(range.end.row, range.end.column, range.end.row, range.end.column + 2);
    var followValue = editor.getSession().getTextRange(followRange); 
    if (", " === followValue)
    {
        range.setEnd(range.end.row, range.end.column + 2);
    }
    else if (" }" === followValue)
    {
        // If this node is the last property/attribute, and it is preceded with a ", " then we should
        // remove that as well...
        //
        var precedingRange = new Range(range.start.row, range.start.column-2, range.start.row, range.start.column);
        var precedingValue = editor.getSession().getTextRange(precedingRange);
        if (precedingValue === ", ")
        {
            range.setStart(range.start.row, range.start.column - 2);
        }
    }

    editor.getSession().remove(range);
}

function getNodeProperty(node, property)
{
    if (node)
    {
        for (var i = 0; i < node.properties.length; i++)
        {
            var prop = node.properties[i];
            if (prop.key.name == property)
            {
                return prop;
            }
        }
    }
}

function getNodePropertyValueAsString(node, property)
{
    var nodeProp = getNodeProperty(node, property);
    if (nodeProp)
    {
        if (nodeProp.value.type === "Literal")
        {
            return nodeProp.value.value.toString();
        }
        else // typically object
        {
            var range = rangeFromLocation(nodeProp.value.loc);
            return editor.getSession().getTextRange(range);
        }
    }
}

function selectVisualElementFromIndexes(visualElement, indexes)
{
    var indexesCopy = indexes.slice(0);
    var elem = $(visualElement).children('[class*="synchro-"]').get(indexesCopy.shift());
    if (indexesCopy.length)
    {
        return selectVisualElementFromIndexes(elem, indexesCopy);
    }
    else
    {
        return elem;
    }
}

function addNodeAttributeAndValue(node, attribute, value, attributeOrderList)
{
    var nodeAttributes = [];
    for (var i = 0; i < node.properties.length; i++)
    {
        nodeAttributes.push(node.properties[i].key.name);
    }

    var attributeIndex = -1;
    if (attributeOrderList)
    {
        attributeIndex = attributeOrderList.indexOf(attribute);
    } 

    var precedentAttributeIndex = -1;

    if (attributeIndex != -1)
    {
        console.log("attributeOrderList index of attribute '%' is:", attribute, attributeIndex);
        console.log("attributes of node:", nodeAttributes);

        for (var j = attributeIndex-1; j >= 0; j--)
        {
            var precedentIndex = nodeAttributes.indexOf(attributeOrderList[j]);
            if (precedentIndex != -1)
            {
                console.log("Found precedent attribute '%s' as attribute index: %d in control", attributeOrderList[j], precedentIndex);
                precedentAttributeIndex = precedentIndex;
                break;
            }
        }
    }
    else
    {
        // Attribute not found in attributeOrderList array - add the attribute at the end
        //
        console.log("Attribute being added (%s) not in attributeOrderList, add after last attribute", attribute);
        precedentNodeIndex = nodeAttributes.length - 1;
    }

    if (precedentAttributeIndex != -1)
    {
        // Add attribute after predecent attribute...
        //
        var precedentAttributeNode = node.properties[precedentIndex];
        console.log("Add attribute '%s' after precedent node: %s", attribute, precedentAttributeNode);

        // Add the attribute (property) after the precedentAttributeNode (in the editor, based on the location of the
        // precedentAttributeNode).  Consider that the precedentAttributeNode may or may not currently be the last attribute
        // on the control node (so may or may not be followed by a comma).
        //
        editor.getSession().insert({row: precedentAttributeNode.loc.end.line-1, column: precedentAttributeNode.loc.end.column}, ", " + attribute + ": " + value);
    }
    else if (node.properties.length === 0)
    {
        // Add attribute as only attribute of node.  Since we don't really want to deal with any whitespace in the value (which
        // is an object), we just replace the entire value with a properly formatted object.
        //
        console.log("Adding attribute '%s' as the only attibute of node", attribute);
        var range = rangeFromLocation(node.loc);
        editor.getSession().replace(range, "{ " + attribute + ": " + value + " }");
    }
    else
    {
        // Add attribute to beginning of attributes of node.
        //
        // The attribute we're trying to add was in the list of ordered attributes, but no precent attribute from that list was found on the node.
        // That means that this attribute should be added in front of any existing attributes.
        //
        console.log("Adding attribute '%s' at the beginning of node attributes", attribute);
        editor.getSession().insert({row: node.loc.start.line-1, column: node.loc.start.column + 1}, " " + attribute + ": " + value + ",");
    }
}

//
// The idea below is to centralize the getting and setting of control properties and binding attributes and get this logic out
// of the UX handlers.
//

function getControlPropertyValue(controlNode, property)
{
    return getNodePropertyValueAsString(controlNode, property);
}

function setControlPropertyValue(controlNode, property, value)
{
    var attributes = [];
    for (var i = 0; i < controlNode.properties.length; i++)
    {
        var prop = controlNode.properties[i];
        if (prop.key.name == property)
        {
            ignoreSelChange = true;
            if (value)
            {
                replaceNode(prop.value, value);
            }
            else
            {
                removeNode(prop);
            }
            ignoreSelChange = false;
            return;
        }
        attributes.push(prop.key.name);
    }

    if (value)
    {
        // We didn't find an existing attribute to replace/remove, and the value is not empty, so we need to add this attruute/value
        //
        ignoreSelChange = true;
        addNodeAttributeAndValue(controlNode, property, value, controlAttributeOrder);
        ignoreSelChange = false;
    }
}

function getControlBindingValue(controlNode, binding)
{
    var controlType = getNodePropertyValueAsString(controlNode, "control");
    var controlBindings = controlMeta[controlType] && controlMeta[controlType].bindings;

    if (controlBindings)
    {
        var defaultBinding = controlBindings[0];

        console.log("Getting binding value for: %s, isDefault: %s", binding, defaultBinding.attribute === binding);

        var bindingNode = getNodeProperty(controlNode, "binding");
        if (bindingNode)
        {
            if (bindingNode.value.type === "ObjectExpression")
            {
                // The current binding attribute contents is an object.
                //
                if ((defaultBinding.type === "command") && getNodeProperty(bindingNode.value, "command"))
                {
                    // The default binding is a command, and the binding attribute object contains a "command" attribute.
                    //
                    if (defaultBinding.attribute === binding)
                    {
                        // The binding we're looking for is the default binding, so return the binding attribute contents...
                        //
                        var range = rangeFromLocation(bindingNode.value.loc);
                        var value = editor.getSession().getTextRange(range);
                        console.log("Binding contents for default command attribute: %s is object: %s", binding, value);
                        return value;
                    }
                }
                else
                {
                    var bindingAttributeNode = getNodeProperty(bindingNode.value, binding);
                    if (bindingAttributeNode)
                    {
                        var value;

                        if (bindingAttributeNode.value.type === "ObjectExpression")
                        {
                            var range = rangeFromLocation(bindingAttributeNode.value.loc);
                            value = editor.getSession().getTextRange(range);
                            console.log("Binding contents for attribute: %s is object: %s", binding, value);
                        }
                        else // "Literal"
                        {
                            value = bindingAttributeNode.value.value;
                            console.log("Binding contents for attribute: %s is literal: %s", binding, value);
                        }

                        return value;
                    }
                }
            }
            else if (defaultBinding.attribute === binding)
            {
                console.log("Binding contents for attribute: %s is literal: %s", binding, bindingNode.value.value);
                return bindingNode.value.value;
            }
        }
    }
}

function setControlBindingValue(controlNode, binding, value)
{
    // Set the value of the binding attribute "binding" to the value "value" (which is a literal string, which may represent a 
    // JS type such as boolean or object, and which will be substituted in as the value without any quoting being added here).
    //
    // Consider default binding (we may be setting the default binding, or the default binding may already be set and we may be
    // setting a non-default binding that causes us to have to promote the already set default binding).  Also note that we may be
    // clearing a binding if value is empty/null, and that may also result in unsetting all bindings (removing the "binding" attribute).
    //
    // The prime directive here is that if the value currenty exists (including if specified using default binding), then the new
    // value must be written to the same location as the present value (without promoting/demoting with respect to default binding).
    //
    // If the current binding attribute contents is an object and it has a "command" attribute, and the default binding attribute
    // is a command, then the current binding attribute contents represent the default binding.  If the binding we are setting
    // is not that default binging attribute, then we need to promote this contents.
    // 
    var controlType = getNodePropertyValueAsString(controlNode, "control");
    var controlBindings = controlMeta[controlType] && controlMeta[controlType].bindings;

    if (controlBindings)
    {
        var defaultBinding = controlBindings[0];

        console.log("Setting binding value for: %s, isDefault: %s", binding, defaultBinding.attribute === binding);

        ignoreSelChange = true;

        var bindingNode = getNodeProperty(controlNode, "binding");
        if (bindingNode)
        {
            // If we're setting the default binding attribute and the value is null and the default attribute is currently
            // the only attribute set, we can just set binding to null via setControlPropertyValue() - though maybe we don't
            // need that much special casing...
            //
            if (bindingNode.value.type === "ObjectExpression")
            {
                if ((defaultBinding.type === "command") && getNodeProperty(bindingNode.value, "command"))
                {
                    // The default binding is a command, and the binding attribute object contains a "command" attribute.
                    //
                    if (defaultBinding.attribute === binding)
                    {
                        if (value)
                        {
                            // Replace binding value
                            console.log("Replacing default binding attribute value (object) with: %s", value);
                            replaceNode(bindingNode.value, value);
                        }
                        else
                        {
                            // Remove binding attribute
                            console.log("Default binding is empty, removing binding attribute (object)");
                            removeNode(bindingNode);
                        }
                    }
                    else if (value)
                    {
                        // Adding new binding attribute, need to promote existing contents to be explicit default binding attribute value
                        //
                        // Note: There is currently no control with a default binding attribute that is a command, and which also has other
                        //       binding attributes, so this case can't get hit.
                        //
                        var range = rangeFromLocation(bindingNode.value.loc);
                        var currentValue = editor.getSession().getTextRange(range);

                        console.log("Adding new value for binding: %s, need to promote existing default binding (object): %s", binding, currentValue);

                        var newValue = "{ " + defaultBinding.attribute + ": " + currentValue + ", " + binding + ": " + value + " }";
                        replaceNode(bindingNode.value, newValue); 
                    }
                }
                else
                {
                    // Object of binding props - add/replace/remove binding attribute in object
                    //
                    var bindingAttributeNode = getNodeProperty(bindingNode.value, binding);
                    if (bindingAttributeNode)
                    {
                        if (value)
                        {
                            // Replace binding value
                            console.log("Replacing binding object attribute: % with value: %s", binding, value);
                            replaceNode(bindingAttributeNode.value, value);
                        }
                        else
                        {
                            // Remove binding attribute
                            //
                            if (bindingNode.value.properties.length === 1)
                            {
                                // We are removing the only remaining binding attribute object value, so we should just remove the entire
                                // binding attribute.
                                //
                                console.log("Removing only binding attribute '%s', so removing binding node itself", binding);
                                removeNode(bindingNode);
                            }
                            else if ((binding != defaultBinding.attribute) && (bindingNode.value.properties.length === 2) && (getNodeProperty(bindingNode.value, defaultBinding.attribute)))
                            {
                                // After removal, the only remaning binding attibute will be the default binding attribute, so we
                                // need to promote its value to the binding attribute value
                                //
                                var defaultBindingValueNode = getNodeProperty(bindingNode.value, defaultBinding.attribute);
                                var range = rangeFromLocation(defaultBindingValueNode.value.loc);
                                var defaultBindingValue = editor.getSession().getTextRange(range);

                                console.log("Remove binding attribute '%s', promoting default binding value: %s", binding, defaultBindingValue);
                                replaceNode(bindingNode.value, defaultBindingValue);
                            }
                            else
                            {
                                console.log("Binding value is empty, removing binding attribute:", binding);
                                removeNode(bindingAttributeNode);
                            }
                        }
                    }
                    else if (value)
                    {
                        if ((bindingNode.value.properties.length === 0) &&  (defaultBinding.attribute === binding))
                        {
                            // The binding value is an empty object, and we're setting the default attribute value.  Replace current
                            // binding value (empty object) with value.
                            //
                            console.log("Replacing binding attribute value (empty object) with default binding attribute value: %s", value);
                            replaceNode(bindingNode.value, value);
                        }
                        else
                        {
                            // Need to add new binding object attribute for value (in proper order per "bindings")
                            //
                            var bindingAttributeOrder = [];
                            for (var i = 0; i < controlBindings.length; i++)
                            {
                                bindingAttributeOrder.push(controlBindings[i].attribute);
                            }
                            addNodeAttributeAndValue(bindingNode.value, binding, value, bindingAttributeOrder);
                        }
                    }
                }
            }
            else if (defaultBinding.attribute === binding)
            {
                // Literal where we are replacing or removing the default binding attribute value
                //
                if (value)
                {
                    // Replace binding value
                    console.log("Replacing default binding attribute value (literal) with: %s", value);
                    replaceNode(bindingNode.value, value);
                }
                else
                {
                    // Remove binding attribute
                    console.log("Default binding is empty, removing binding attribute (literal)");
                    removeNode(bindingNode);
                }
            }
            else 
            {
                // Literal where we are adding a new binding attribute value (need to promote current value)
                //
                var range = rangeFromLocation(bindingNode.value.loc);
                var currentValue = editor.getSession().getTextRange(range);

                console.log("Adding new value for binding: %s, need to promote existing default binding (literal): %s", binding, currentValue);

                var newValue = "{ " + defaultBinding.attribute + ": " + currentValue + ", " + binding + ": " + value + " }";
                replaceNode(bindingNode.value, newValue); 
            }
        }
        else // No binding node
        {
            if (value)
            {
                if (defaultBinding.attribute !== binding)
                {
                    value = "{ " + binding + ": " + value + " }";
                }

                // Add binding attribute
                //
                setControlPropertyValue(controlNode, "binding", value);
            }
        }

        ignoreSelChange = false;
    }
}

// Get the list of command handlers (if any) in the current module
//
function getModuleCommands()
{
    var commandsNode = getCommandsNode();
    if (commandsNode)
    {
        if (commandsNode.type === "ObjectExpression")
        {
            var commands = [];
            for (var i = 0; i < commandsNode.properties.length; i++)
            {
                commands.push(commandsNode.properties[i].key.name);
            }

            return commands;
        }
    }
}

// Add a new command handler (function) to the current module (assumes that the command does not exist)
//
function createModuleCommand(commandName)
{
    var commandsNode = getCommandsNode();
    if (!commandsNode)
    {
        // Insert new commands export and command at end of file
        //
        var insert = "\n" + 
            "exports.Commands =\n" +
            "{\n" + 
            "    " + commandName + ": function(context, session, viewModel, params)\n" +
            "    {\n" +
            "    },\n" +
            "}\n";

        var lines = editor.getSession().getLength();
        editor.getSession().insert({row: lines + 1, column: 0}, insert); 
    }
    else
    {
        // Insert command commandName at end of commands
        //
        var lastCommand = commandsNode.properties[commandsNode.properties.length-1];
        var indent = lastCommand.loc.start.column;

        var insert = ",\n" + 
            spaces(indent) + commandName + ": function(context, session, viewModel, params)\n" +
            spaces(indent) + "{\n" +
            spaces(indent) + "}";

        editor.getSession().insert({row: lastCommand.loc.end.line - 1, column: lastCommand.loc.end.column}, insert);
    }
}

// The control currently selected in the editor (meaning the cursor is located in the control, and the property inspector
// widgets are linked to that control).
//
var selectedControl; 

function clearPropertyInspectors()
{
    $('#widget-container-control').empty();
    $('#widget-container-binding').empty();
    $('#widget-container-common').empty();
    $('#widget-container-control-panel').hide();
    $('#widget-container-binding-panel').hide();
    $('#widget-container-common-panel').hide();
}

function populatePropertyInspectorWidgets(divId, properties, isBindings)
{
    if (properties && properties.length)
    {
        for (var i = 0; i < properties.length; i++)
        {
            var property = properties[i];

            var propertyCaption = property.caption || property.attribute;

            // Widget group
            //
            $('#' + divId).append(
                "<div class='form-group'" +
                    "<label for='widget-" + property.attribute + "'>" + propertyCaption + ":</label>" + 
                    "<div class='input-group' id='widget-" + property.attribute + "-group'></div>" +
                "</div>"
            );

            // Widget control
            //
            if ((property.type === 'select') || (property.type === 'boolean'))
            {
                // There are cases (of "select" and "boolean" types) where tokens are not allowed, as specified with "tokens" property
                // value of false.  In these cases, we want to show a normal select control where the user can choose between "empty" (unset)
                // and the acceptabe values (so no freeform text, and no token accessory).
                //
                $('#widget-' + property.attribute + '-group').append(
                    "<select id='widget-" + property.attribute + "' type='text' class='form-control' oninput='propChange(this," + isBindings + ")'>"
                );

                if (property.tokens === false)
                {
                    $('#widget-' + property.attribute).append("<option></option>");
                }

                if (property.type === 'select')
                {
                    for (var j = 0; j < property.values.length; j++)
                    {
                        $('#widget-' + property.attribute).append("<option>" + property.values[j] + "</option>");
                    }
                }
                else if (property.type === 'boolean')
                {
                    $('#widget-' + property.attribute).append("<option>true</option>");
                    $('#widget-' + property.attribute).append("<option>false</option>");
                }

                if (property.tokens !== false)
                {
                    $('#widget-' + property.attribute).editableSelect({ filter: false });
                }
            }
            else
            {
                $('#widget-' + property.attribute + '-group').append(
                    "<input id='widget-" + property.attribute + "' type='text' class='form-control' oninput='propChange(this," + isBindings + ")'>"
                );
            }

            if (property.tokens !== false)
            {
                // Widget accessory
                //
                var accessoryLabel = "{ }";
                var accessoryFunction = "onTokenAccessory";

                if (property.type === "data")
                {
                    accessoryLabel = "&harr;";
                    accessoryFunction = "onDataBindingAccessory";
                }
                else if (property.type === "command")
                {
                    accessoryLabel = "fn";
                    accessoryFunction = "onCommandAccessory";
                }

                $('#widget-' + property.attribute + '-group').append(
                    "<span class='input-group-btn'>" + 
                       "<button id='widget-" + property.attribute + "-binding' class='btn btn-default' type='button'" +
                              " onclick='" + accessoryFunction + "(this);'>" + accessoryLabel + "</button>" + 
                    "</span>"
                );
            }

            // Set Widget value
            //
            var value = isBindings ? getControlBindingValue(selectedControl, property.attribute) : getControlPropertyValue(selectedControl, property.attribute);
            $('#widget-' + property.attribute).val(value);
        }

        // Show panel
        //
        $('#' + divId + '-panel').show();
    }
}

function onSelectionChange()
{
    var pos = editor.selection.getCursor();
    var controlNode = findControlInModule(pos);

    if (selectedControl != controlNode)
    {
        if (selectedControl)
        {
            selectedControl = null;

            // Remove existing property inspector widgets
            //
            console.log("Removing property inspector widgets");
            clearPropertyInspectors();

            // Turn off any visual element selection
            //
            $('#synchro_container').find('[class*="synchro-"]').css('outline', '');
        }

        if (controlNode)
        {
            selectedControl = controlNode;

            // Create and populate property inspector widgets
            //
            var controlType = getNodePropertyValueAsString(controlNode, 'control');

            console.log("Adding property inspector widgets for control of type:", controlType);

            var commonAttributes = controlMeta["*"].attributes;
            var controlAttributes = controlMeta[controlType] && controlMeta[controlType].attributes;
            var bindingAttributes = controlMeta[controlType] && controlMeta[controlType].bindings;

            $('#control-type').text(controlMeta[controlType].name);
            populatePropertyInspectorWidgets('widget-container-control', controlAttributes);
            populatePropertyInspectorWidgets('widget-container-binding', bindingAttributes, true);
            populatePropertyInspectorWidgets('widget-container-common', commonAttributes);

            // Select the visual element that corresponds to the selected control node.
            //
            var elem = selectVisualElementFromIndexes($("#synchro_container"), controlNode.indexes);
            $(elem).css("outline", selectedOutline);
            $(elem).css("outline-offset", selectedOutlineOffset);
        }
    }
}

function onEditorChange()
{
    // Update property inspector widget values from currently selected control node (if any).
    //  
    console.log("Editor change");

    // !!! This may need some work.  We should probably make sure the controlNode === selectedNodes (if we're going to update 
    //     property inspector widgets in-place, we need to make sure they're for the correct control).  If the node is different,
    //     then we need to do the onSelectionChange() logic (which will probably get called anyway - not sure the editor content
    //     can change without changing the selection - maybe?).
    //

    // Note: If we aren't in a control node, then we shouldn't have an property inspector widgets (so no need to clear values).
    //
    var pos = editor.selection.getCursor();
    var controlNode = findControlInModule(pos);
    if (controlNode)
    {
        var attributes = controlMeta["*"].attributes;
        attributes = attributes.concat(controlMeta[getNodePropertyValueAsString(controlNode, 'control')].attributes);

        for (var i = 0; i < attributes.length; i++)
        {
            $('#widget_' + attributes[i].attribute).val(getControlPropertyValue(controlNode, attributes[i].attribute));
        }

        var bindings = controlMeta[getNodePropertyValueAsString(controlNode, 'control')].bindings;
        if (bindings)
        {
            for (var i = 0; i < bindings.length; i++)
            {
                $('#widget_' + bindings[i].attribute).val(getControlBindingValue(controlNode, bindings[i].attribute));
            }
        }
    }

    updateView();
}

function controlValueToAttribute(controlValue)
{
    var value;

    // See if the string is quoted (matching set of single or double quotes at beginning and end of string)
    //
    var result = controlValue.match(/^(['"])(.*)\1$/);
    if (result)
    {
        // We found a quoted string.
        //
        // We are going to escape any additional instances of the quoting inside the quoted value (to avoid broken quoting that would
        // break our Javascript object when updated).
        //
        console.log("Quoted string, quote used was: %s, quoted value was:", result[1], result[2]);
        value = result[1] + result[2].replace(/\\/g,'\\').replace(new RegExp("\\" + result[1], 'g'),'\\' + result[1]) + result[1];
    }
    else
    {
        // See if we have a string surrounded by braces (potential object)
        //
        result = controlValue.match(/^{(.*)}$/);
        if (result)
        {
            // We found a brace quoted string.  See if this is an object, else treat it like a literal string (quote it)
            //
            console.log("Brace quoted string, quoted value was:", result[1]);
            try
            {
                // If controlValue is a legitimate Javascript value (object, in this case), then the eval will succeed
                //
                eval("var tmpValue = " + controlValue);
                value = controlValue;
            }
            catch (e)
            {
                // Not a valid object.  Assume it's a string that needs to be quuoted.
                //
                value = '"' + controlValue.replace(/\\/g,'\\').replace(/\"/g,'\\"') + '"';
            }
        }
        else // Not a quoted or brace-quoted string - should be literal value
        {
            try
            {
                // For primitive Javascript types (boolean, int, null, etc), this value assignment will succeed
                //
                value = JSON.stringify(JSON.parse(controlValue));
            }
            catch (e)
            {
                // Not a valid primitive type.  Assume it's a string that needs to be quoted and quote it
                //
                value = '"' + controlValue.replace(/\\/g,'\\').replace(/\"/g,'\\"') + '"';
            }
        }
    }

    return value;
}

// Called when property inspector widget receives input - updates editor content (selected control attributes) based on change
//
function propChange(control, isBinding)
{
    var propName = $(control).attr("id").match(/^widget-(.*)$/)[1];

    // The logic below is all about trying to figure out the intetion of the user.  We check for explicitly quoted strings and 
    // string surrounded by braces, and we check to see if values are Javascript primitive values.  Worst case, we fall back to
    // treating the values as strings (escaping as appropriate to make sure they are valid Javascript values).
    //
    // !!! When we have more sophisticated controls (like a complex control for font attributes), we're going to have to be smarter
    //     about converting those control values to "value" here.
    //
    var value = null;
    var controlValue = control.value;
    if (controlValue !== "")
    {
        value = controlValueToAttribute(controlValue);
    }

    console.log("Property '%s' changed to: %s", propName, value);

    var pos = editor.selection.getCursor();
    var controlNode = findControlInModule(pos);

    if (controlNode)
    {
        console.log("Found control:", controlNode);
        if (isBinding)
        {
            setControlBindingValue(controlNode, propName, value);
        }
        else
        {
            setControlPropertyValue(controlNode, propName, value);
        }
    }

    updateView();
}

//
// ViewModel modal dialog and helpers
//

function viewModelNodeContainsPoint(node, point)
{
    var range = new Range(node.loc.start.line-2, node.loc.start.column, node.loc.end.line-2, node.loc.end.column);
    return range.contains(point.row, point.column);
}

function getBindingPath(node, point)
{
    if (node.type === 'ObjectExpression')
    {
        for (var i = 0; i < node.properties.length; i++)
        {
            if (viewModelNodeContainsPoint(node.properties[i], point))
            {
                var path = node.properties[i].key.value;
                var result = getBindingPath(node.properties[i], point);
                if (result)
                {
                    path += "." + result;
                }
                return path;
            }
        }
    }
    else if (node.type === 'ArrayExpression')
    {
        for (var i = 0; i < node.elements.length; i++)
        {
            if (viewModelNodeContainsPoint(node.elements[i], point))
            {
                var path = "" + i;
                var result = getBindingPath(node.elements[i], point);
                if (result)
                {
                    path += "." + result;
                }
                return path;
            }
        }
    }
    else if (node.type === 'Property')
    {
        return getBindingPath(node.value, point);
    }

    return false;
}

var modelViewEditorLoading = false;

function onTokenAccessory(control)
{
    var propName = $(control).attr("id").match(/^widget-(.*)-binding$/)[1];
    onBinding(propName, false);
}

function onDataBindingAccessory(control)
{
    var propName = $(control).attr("id").match(/^widget-(.*)-binding$/)[1];
    onBinding(propName, true);
}

function onCommandAccessory(control)
{
    var propName = $(control).attr("id").match(/^widget-(.*)-binding$/)[1];
    var $control = $("#widget-" + propName);

    var propVal = $control.val();

    console.log("Command accessory property '%s' with value: %s", propName, propVal);

    var propValParsed = getParsedObject(propVal);
    console.log("PropVal parsed:", propValParsed);

    var commandName;
    if (propValParsed.type === "ObjectExpression")
    {
        commandName = getNodePropertyValueAsString(propValParsed, "command");
        var paramIndex = 1;
        for (var i = 0; i < propValParsed.properties.length; i++)
        {
            var paramName = propValParsed.properties[i].key.name;
            if (paramName != "command")
            {
                if (paramIndex > 3)
                {
                    console.log("Exceeded max number of supported params (3)");
                    break;
                }

                var paramValue;
                if (propValParsed.properties[i].value.type === "Literal")
                {
                    paramValue = propValParsed.properties[i].value.value;
                }
                else
                {
                    var loc = propValParsed.properties[i].value.loc;
                    paramValue = propVal.substring(loc.start.column, loc.end.column);
                }

                console.log("Found param name: %s, value: %s", paramName, paramValue);

                $("#commandParamName" + paramIndex).val(paramName);
                $("#commandParamValue" + paramIndex).val(paramValue);
                paramIndex++;
            }
        }

        for (var i = paramIndex; i <= 3; i++)
        {
            // Clear any unset param fields
            $("#commandParamName" + i).val("");
            $("#commandParamValue" + i).val("");
        }
    }
    else if (propValParsed.type === "Identifier")
    {
        commandName = propValParsed.name;
    }

    var commands = getModuleCommands();
    console.log("Got commands:", commands);

    $('#commandList').empty();
    $('#commandList').append("<option>[Create new command]</option>");
    var selection = 0;
    if (commands)
    {
        for (var i = 0; i < commands.length; i++)
        {
            if (commandName === commands[i])
            {
                selection = i + 1;
            }
            $('#commandList').append("<option>" + commands[i] + "</option>");
        }
    }

    if ((selection === 0) && commandName)
    {
        // Command name was not found in list, set is as "new command name"
        //
        $("#newCommandName").val(commandName);
    }

    $('#commandList').prop("selectedIndex", selection);
    onCommandChange(); // Update #newCommandName visibility based on selection

    // Show the modal
    //
    $('#commandModal').data('property', propName);
    $('#commandModal').modal();
}

function onCommandChange()
{
    console.log("onCommandChange:", $('#commandList').val());

    if ($('#commandList').prop("selectedIndex") === 0)
    {
        $('#newCommandName').show();
    }
    else
    {
        $('#newCommandName').hide();
    }
}

function onCommandSave()
{
    $('#commandModal').modal('hide');

    var propName = $('#commandModal').data('property');

    console.log("onCommandSave, prop:", propName);

    var command = $('#newCommandName').val();
    var commandIsNew = true;

    if ($('#commandList').prop("selectedIndex") !== 0)
    {
        command = $('#commandList').val();
        commandIsNew = false;
    }

    if (commandIsNew)
    {
        createModuleCommand(command);
    }

    var propVal = command;

    // Collect params
    //
    var params = [];
    for (var i = 1; i <= 3; i++)
    {
        var name = $("#commandParamName" + i).val();
        var controlValue = $("#commandParamValue" + i).val();

        if (name && !name.match(/^\w+$/))
        {
            // !!!
            console.log("Found command param with invalid name:", name);
        }
        else if (name && !controlValue)
        {
            // !!!
            console.log("Found command param with name '%s' and no value", name);
        }
        else if (!name && controlValue)
        {
            // !!!
            console.log("Found command param with no name, and value of: %s", controlValue);
        }
        else if (controlValue)
        {
            var value = controlValueToAttribute(controlValue);
            if (name && value)
            {
                params.push({name: name, value: value});
            }
        }
    }

    // If params, create object with command and params
    //
    if (params.length)
    {
        console.log("Found params:", params);
        propVal = '{ command: "' + command + '"';
        for (var i = 0; i < params.length; i++)
        {
            propVal += ", " + params[i].name + ': ' + params[i].value; 
        }
        propVal += ' }';
    }

    $('#widget-' + propName).val(propVal);
    propChange($('#widget-' + propName).get(0), true);
}

function onBinding(propName, isDataBinding)
{
    // !!! One of the issues we have is understanding the binding context of the control (in the case where it's not the root binding context).
    //     This is necessary so that when the user clicks an item of the viewModel, we can construct a path from the control's binding context
    //     to the selected binding context (potentially using "$parent." to backtrack up from the control's binding context).
    //
    // !!! The new "contextAttribute" (on plain attributes and on bindings) will allow us to compute the context for the current node (will 
    //     involve using ".parent" on the node to walk up the tree).
    //
    var $control = $("#widget-" + propName);

    if (isDataBinding)
    {
        // Value binding is a single element from the viewModel, with no brace-quoting.
        //
        $('#bindingModalTitle').html("Data Binding");
        $('#modalPropValueLabel').html("Binding: " + propName);
        $("#tokenModifiers").hide();
    }
    else
    {
        // Propery binding can have zero or more tokens, with literal string elements interspersed
        //
        $('#bindingModalTitle').html("Property Binding");
        $('#modalPropValueLabel').html("Property: " + propName);
        $("#tokenModifiers").show();
    }

    // Populate modal - with property value, viewModel, etc.
    //
    $('#modalPropValue').val($control.val());
    $('#modalPropValue').data('property', propName);
    $('#modalPropValue').data('isDataBinding', isDataBinding);
    $('#modalPropValue').prop({'selectionStart': 0, 'selectionEnd': 0});
    onBindingValueSelection(); // Update binding token widgets

    var viewModel = getViewModel();
    if (viewModel)
    {
        modelViewEditorLoading = true;
        modalViewModelEditor.session.setValue(JSON.stringify(viewModel, null, 4));
        modelViewEditorLoading = false;
    }

    // Show the modal
    //
    $('#bindingModal').modal();
}

// Given a property value and selection range, determine if the selection contains, or is entirely within, a token, and if so,
// return details on the matched token.
//
function getSelectedTokenString(selection)
{
    if (selection.start != selection.end)
    {
        var sel = selection.val.substring(selection.start, selection.end);
        if (!sel.match(/^{?[\^]?[\!]?[a-zA-Z0-9$._\[\]-]*}?$/))
        {
            console.log("Current selection contains non-token value");
            return null;
        }
    }

    var match;
    var tokenRe = /{[\^]?[\!]?[a-zA-Z0-9$._\[\]-]*}/g;
    while ((match = tokenRe.exec(selection.val)) != null) 
    {
        // See if current selection is entirely within this match...
        //
        var matchEnd = match.index + match[0].length;
        if ((selection.start >= match.index) && (selection.start < matchEnd) && (selection.end <= matchEnd))
        {
            return { match: match[0], start: match.index, end: match.index + match[0].length };
        }
    }
}

function getSelection($control)
{
    return { start: $control.prop('selectionStart'), end: $control.prop('selectionEnd'), val: $control.val() };
}

function getParsedObject(str)
{
    var jsText = "var foo =\n" + str; // newline is so col numbers are correct on returned object
    var parsed = esprima.parse(jsText, { loc: true });
    return parsed.body[0].declarations[0].init;
}

function onBindingViewModelClick(pos)
{
    if (modelViewEditorLoading) return;

    console.log("modalViewModel change cursor pos - row: %s, col: %s", pos.row, pos.column);

    var viewModelText = "var viewModel =\n" + modalViewModelEditor.getValue();
    var parsedViewModel = esprima.parse(viewModelText, { loc: true });

    var objectExpression = parsedViewModel.body[0].declarations[0].init;

    var bindingPath = getBindingPath(objectExpression, pos);
    if (bindingPath)
    {
        var isDataBinding = $('#modalPropValue').data('isDataBinding');
        if (isDataBinding)
        {
            // For value binding, we replace the value with the binding path
            //
            $('#modalPropValue').val(bindingPath);
        }
        else
        {
            // For property / token binding, if current selection is in a token, then we replace that token
            // with the selected token, otherwise we replace the current selection with the selected token
            //
            var selection = getSelection($('#modalPropValue'));
            var token = getSelectedTokenString(selection);
            if (token)
            {
                // Replace token instead of selection
                console.log("Currently selected token (viewModel click):", token);
                selection.start = token.start;
                selection.end = token.end;
            }

            $('#modalPropValue').val(selection.val.substring(0, selection.start) + "{" + bindingPath + "}" + selection.val.substring(selection.end));
            $('#modalPropValue').prop({'selectionStart': selection.start, 'selectionEnd': selection.start});
            onBindingValueSelection(); // Update binding token widgets
        }
    }
}

function onBindingTokenOneTimeClick()
{
    var checked = $("#tokenModifierOneTime").prop('checked');
    console.log("Binding token one-time click, value:", checked);

    var selection = getSelection($('#modalPropValue'));
    var token = getSelectedTokenString(selection);
    if (token)
    {
        var newToken;
        if (checked)
        {
            newToken = token.match.replace(/({)([^\^].*})/g, "$1^$2");
        }
        else
        {
            newToken = token.match.replace(/({)[\^](.*})/g, "$1$2");
        }
        $('#modalPropValue').val(selection.val.substring(0, token.start) + newToken + selection.val.substring(token.end));
        $('#modalPropValue').prop({'selectionStart': token.start, 'selectionEnd': token.start});
    }
}

function onBindingTokenNegateClick()
{
    var checked = $("#tokenModifierNegate").prop('checked');
    console.log("Binding token negate click, value:", checked);

    var selection = getSelection($('#modalPropValue'));
    var token = getSelectedTokenString(selection);
    if (token)
    {
        var newToken;
        if (checked)
        {
            newToken = token.match.replace(/({[\^]?)([^!].*})/g, "$1!$2");
        }
        else
        {
            newToken = token.match.replace(/({[\^]?)[!](.*})/g, "$1$2");
        }
        $('#modalPropValue').val(selection.val.substring(0, token.start) + newToken + selection.val.substring(token.end));
        $('#modalPropValue').prop({'selectionStart': token.start, 'selectionEnd': token.start});
    }
}

function onBindingValueSelection()
{
    var isDataBinding = $('#modalPropValue').data('isDataBinding');
    if (!isDataBinding)
    {
        console.log("Token value selection change");

        var selection = getSelection($('#modalPropValue'));
        var token = getSelectedTokenString(selection);
        if (token)
        {
            // Enable the one-time/negation controls, and set their values
            //
            console.log("Currently selected token (prop val selection change):", token);
            $("#tokenModifiers").prop('disabled', false);
            $("#tokenModifierOneTime").prop('checked', token.match[1] === '^');
            $("#tokenModifierNegate").prop('checked', (token.match[1] === '!') || (token.match[2] === '!'));
        }
        else
        {
            // Disable and unset the one-time/negation controls
            //
            console.log("No token currently selected (prop val selection change)");
            $("#tokenModifiers").prop('disabled', true);
            $("#tokenModifierOneTime").prop('checked', false);
            $("#tokenModifierOneNegate").prop('checked', false);
        }
    }
}

function onBindingSave()
{
    $('#bindingModal').modal('hide');

    var propName = $('#modalPropValue').data('property');
    var isDataBinding = $('#modalPropValue').data('isDataBinding');
    var propVal = $('#modalPropValue').val();

    console.log("Property binding model: new value for prop: %s is: %s", propName, propVal);

    $('#widget-' + propName).val(propVal);
    propChange($('#widget-' + propName).get(0), isDataBinding);
}

//
// Debug 
//

function showDebug(isDebug)
{
    if (isDebug)
    {
        layout.hide("east");
        centerLayout.hide("north");
        centerLayout.show("south");
    }
    else
    {
        centerLayout.hide("south");
        centerLayout.show("north");
        layout.show("east");
    }
}

var activeBreakpointMarker;

// Set active breakpoint (called by debugger client)
//
function setActiveBreakpoint(row) // Use -1 to clear
{
    if (activeBreakpointMarker)
    {
        editor.getSession().removeMarker(activeBreakpointMarker);
        activeBreakpointMarker = null;
    }

    if (row >= 0)
    {
        Range = require("ace/range").Range;
        var range = new Range(row, 0, row, 100);
        activeBreakpointMarker = editor.getSession().addMarker(range,"active-breakpoint","line", true);
    }
}

// Load source on behalf of debugger (called by debugger client)
//
function onBreakpointSource(sourceData)
{
    if (sourceData.scriptPath.lastIndexOf(currentModulePathPrefix) == 0)
    {
        sourceData.moduleName = sourceData.scriptPath.substring(currentModulePathPrefix.length);
        console.log("Loading breakpoint source from module loader for module: " + sourceData.moduleName);
        $.getJSON("module", { module: sourceData.moduleName }, function(data)
        {
            // Process JSON response
            console.log("loadModule " + sourceData.moduleName + ": " + JSON.stringify(data));
            sourceData.source = data.source;
            loadSource(sourceData);
        })
        .fail(function() 
        {
            alert( "loadModule error" );
        });
    }
    else
    {
        loadSource(sourceData);
    }
}

// 
// Modules
//

var currentModulePathPrefix = null;
var currentModule = null; // Only if loaded via modules (not via debugger)
var currentScriptPath = null;

// Here is some a discussion and some code to deal with moving breakpoints on line insert/delete:
//
//     https://groups.google.com/forum/#!msg/ace-discuss/sfGv4tRWZdY/ca1LuolbLnAJ
//     https://github.com/MikeRatcliffe/Acebug/blob/master/chrome/content/ace%2B%2B/startup.js
//

function loadSource(sourceData)
{
    // sourceData.moduleName
    // sourceData.scriptPath
    // sourceData.source
    // sourceData.breakpoints
    // sourceData.executionPointer
    currentModule = sourceData.moduleName;
    currentScriptPath = sourceData.scriptPath;

    editor.session.clearBreakpoints();
    editor.session.setValue(sourceData.source);

    if (sourceData.breakpoints)
    {
        for (var i = 0; i < sourceData.breakpoints.length; i++)
        {
            var breakpoint = sourceData.breakpoints[i];
            editor.session.setBreakpoint(breakpoint.line);
        }
    }
    var executionPointer = sourceData.executionPointer || -1;
    setActiveBreakpoint(executionPointer);
    if (executionPointer >= 0)
    {
        editor.renderer.scrollToLine(executionPointer, true, true);
    }

    $("#module").text("Module: " + currentModule);
    if (currentModule)
    {
        $("button#save").show();
    }
    else
    {
        $("button#save").hide();
    }

    // Highlight the new active module...
    //
    $("div#modules a.active").removeClass("active");
    $("div#modules a[module='" + currentModule + "']").addClass("active");
}

// Reload the list of modules and repopulate the modules list (such as after adding/removing a module)
// 
function loadModules(cb)
{
    $.getJSON(".", function(data)
    {
        // Process JSON response
        console.log("loadModules - got app info:", JSON.stringify(data));

        $('#modules').empty();
        for (var i = 0; i < data.modules.length; i++)
        {
            $('#modules').append(
                '<a href="#"  class="list-group-item" module="' + data.modules[i] + '" onClick="return onLoadModule(\'' + data.modules[i] + '\');">' + data.modules[i] + '</a>'
            );
        }
        cb();
    })
    .fail(function(jqxhr, textStatus, error) 
    {
        cb(error);
    });
}

function onNewModule()
{
    bootbox.prompt(
    {
        title: "Enter module name for new module",
        callback: function (moduleName) 
        {
            if (moduleName === null)
            {
                // prompt dialog cancelled
                return;
            }

            console.log("New module:", moduleName);

            // Validate that moduleName is composed of legal filename chars (path sep allowed)
            var match = moduleName.match(/^[a-zA-Z0-9_]+(?:[\/][a-zA-Z0-9_]+)*([.][a-zA-Z0-9_]+)?$/);
            console.log("Match:", match);

            if (!match)
            {
                bootbox.alert("Bad filename");
                return;
            }

            var moduleSource = [ 
                'exports.View =',
                '{',
                '    title: "' + moduleName + '",',
                '    elements:',
                '    [',
                '        { control: "text", value: "Sample text control" }',
                '    ]',
                '}',
                '',
                'exports.InitializeViewModel = function(context, session)',
                '{',
                '    var viewModel =',
                '    {',
                '    }',
                '    return viewModel;',
                '}'
                ].join("\n");

            if (!match[1])
            {
                // No file extension, add .js
                console.log("Adding .js extension");
                moduleName += ".js";
            }

            $.post("module", { module: moduleName, source: moduleSource }, function(result)
            {
                //alert("Result: " + JSON.stringify(result, null, 4));
                if (result.status == "OK")
                {
                    loadModules(function(err)
                    {
                        if (err)
                        {
                            toastr.error("Error loading module list after creating new module, details: " + err);
                        }
                        else
                        {
                            loadSource(
                            {
                                moduleName: moduleName,
                                scriptPath: currentModulePathPrefix + moduleName,
                                source: moduleSource
                            });
                            toastr.success(result.message);
                        }
                    });
                }
                else if (result.status == "Fail")
                {
                    toastr.error(result.message);
                }
            })
            .fail(function(jqXHR, textStatus) 
            {
                alert("Fail:" + JSON.stringify(jqXHR, null, 4));
                alert("Module create failed: " + textStatus);
            });
        }
    });

    return false; // To prevent default click behavior
}

function onLoadModule(moduleName)
{
    var modulePath = currentModulePathPrefix + moduleName;
    $.getJSON("module", { module: moduleName }, function(data)
    {
        // Process JSON response
        console.log("loadModule " + moduleName + ": " + JSON.stringify(data));
        loadSource(
        {
            moduleName: moduleName,
            scriptPath: modulePath,
            source: data.source
        });
        loadBreakpoints(modulePath);
    })
    .fail(function() 
    {
        alert( "loadModule error" );
    });

    return false; // To prevent default click behavior
}

function onSaveModule()
{
    if (!currentModule)
    {
        toastr.error("No modules loaded, save failed");
        return;
    }

    $.put("module", { module: currentModule, source: editor.getValue() }, function(result)
    {
        //alert("Result: " + JSON.stringify(result, null, 4));
        if (result.status == "OK")
        {
            toastr.success(result.message);
        }
        else if (result.status == "Fail")
        {
            toastr.error(result.message);
        }
    })
    .fail(function(jqXHR, textStatus) 
    {
        console.log("Save module fail:" + JSON.stringify(jqXHR, null, 4));
        toastr.error("Module save failed: " + textStatus);
    });
}
