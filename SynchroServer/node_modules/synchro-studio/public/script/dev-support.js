// Dev Support
//
// ACE: https://ace.c9.io/
//
Range = require("ace/range").Range;

// When we add attributes to a control node, we will add them in this order.  When adding a new attribute (one that is not
// present on the node), find the attribute in this list.  If found, navigate up the list until you find an attribute from
// the list that is present on the node, then insert the attribute being added after that attribue on the node.
//
var attributeOrder =
[
    "control",
    "height",
    "width",
    "color", // Border, Button, Rectangle, Text
    "background",
    "margin",
    "padding", // Border, StackPanel
    "visibility",
    "opacity",
    "enabled",
    "orientation", // ScrollView, StackPanel, WrapPanel
    "horizontalAlignment",
    "verticalAlignment",

    "caption", // Button
    "icon", // Button
    "resource", // Button, Image

    "font", // Edit, Password, Text

    "value", // Text, ProgressRing
    "binding",

    "border", // Border, Rectangle
    "borderThickness", // Border, Rectangle
    "cornerRadius", // Border, Rectangle

    "borderless", // Button

    "lines", // Edit
    "multiline", // Edit
    "placeholder", // Edit

    "ellipsize", // Text
    "textAlignment", // Text

    "url", // WebView

    "movementThreshold", // Location

    "minimum", // ProgressBar, Slider
    "maximum", // ProgressBar, Slider

    "scale", // Image

    "select", // ListBox, ListView

    "itemHeight", // WrapPanel
    "itemWidth", // WrapPanel

    "header", // ListView
    "itemTemplate", // ListView
    "footer", // ListView

    "contents" // Border, Canvas, ScrollView, StackPanel, WrapPanel (all containers), WebView (different meaning)
];

// !!! We should populate the inspector with the common control attributes, and also with control-specific attributes
//
var controlAttributes = 
{
    "*": [
        { caption: "Height", attribute: "height", type: "number" },
        { caption: "Width", attribute: "width", type: "number" },
        { caption: "Visibility", attribute: "visibility", type: "boolean" },
        { caption: "Enabled", attribute: "enabled", type: "boolean" },
        { caption: "Opacity", attribute: "opacity", type: "number" }, // Range: 0-1
        { caption: "Horizontal Alignment", attribute: "horizontalAlignment", type: "select", values: ["Left", "Center", "Right"] },
        { caption: "Vertical Alignment", attribute: "verticalAlignment", type: "select", values: ["Top", "Center", "Bottom"] },
        { caption: "Margin", attribute: "margin", type: "thickness" },
    ],
    "border": [
    ],
    "button": [
        { caption: "Caption", attribute: "caption", type: "string" },
        { caption: "Icon", attribute: "icon", type: "string" },
        { caption: "Color", attribute: "color", type: "color" },
        { caption: "Borderless", attribute: "borderless", type: "boolean" },
    ],
    "canvas": [
    ],
    "edit": [
    ],
    "image": [
    ],
    "listbox": [
    ],
    "listview": [
    ],
    "location": [
    ],
    "password": [
    ],
    "progressbar": [
    ],
    "progressring": [
    ],
    "rectangle": [
    ],
    "scrollview": [
    ],
    "slider": [
    ],
    "stackpanel": [
    ],
    "text": [
    ],
    "wrappanel": [
    ]
}

function onDocumentReady()
{
    // http://layout.jquery-dev.com/
    //
    $('body').layout(
    { 
        center__paneSelector: ".ui-layout-center",
        north__spacing_open: 0, // Makes non-sizable
        center__childOptions: {
            center__paneSelector: ".middle-center",
            north__paneSelector:  ".middle-north",
        },
        east__childOptions: {
            center__paneSelector: ".right-center",
            south__paneSelector:  ".right-south",
        }
    });

    var middleLayout = $("div.ui-layout-center").layout();
    middleLayout.sizePane("north", 300);

    initEditor();
}

var editor;
var ignoreSelChange = false;

function initEditor()
{
    editor = ace.edit("editor");
    editor.setTheme("ace/theme/monokai");
    editor.getSession().setMode("ace/mode/javascript");

    editor.getSession().on('change', function(e) 
    {
        console.log("Change content - type: %s, data: %s", e.type, JSON.stringify(e.data));
        if (!ignoreSelChange)
        {
            onEditorChange();
        }
    });

    editor.getSession().selection.on('changeCursor', function(e) 
    {
        var pos = editor.selection.getCursor();
        console.log("Change cursor pos - row: %s, col: %s", pos.row, pos.column);
        if (!ignoreSelChange)
        {
            onSelectionChange();
        }
    });

    editor.getSession().selection.on('changeSelection', function(e) 
    {
        console.log("Change selection");
    });

    // on "focus" and "blur"
}

var renderView; // renderView(view, viewModel)

function SynchroInit(synchro)
{
    renderView = synchro.renderView;

    var synchroApp =
    {
        container: document.getElementById('synchro_container'), // required
        onSetPageTitle: function(title) // optional
        {
            console.log("Page title set:", title);
            document.getElementById('synchro_title').innerHTML = title;
        },
        logConfig: {}, // optional, developer setting
    }

    return synchroApp;
}

function updateView()
{
    try
    {
        var parsed = esprima.parse(editor.getValue(), { loc: true, comment: true });

        var view;
        var viewModel = {};

        var initViewModelRange;
        var designViewModelRange;

        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'View'))
                {
                    var node = exp.expression.right;
                    // console.log("Found View:", node);

                    var range = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);

                    // This is a little creepy.  The View defintion in a Synchro module is not required to be JSON encoded (it's a
                    // JavaScript object).  So, for example, keys do not need to be quoted, and there can even be code in the values
                    // being assigned (though we're not trying to support that).  For this reason, we need to parse the found View as
                    // a JavaScript object, not as JSON.  The only way to do that is with good old eval().
                    //
                    eval("view = " + editor.getSession().getTextRange(range));
                }

                // Look for a top-level "var designViewModel = {}"
                //
                if ((exp.type === 'VariableDeclaration') && (exp.declarations[0].id.name === 'designViewModel'))
                {
                    var node = exp.declarations[0].init;
                    //console.log("Found designViewModel:", JSON.stringify(node, null, 4));
                    designViewModelRange = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);
                }

                // Look for a top-level exports.InitializeViewModel function, and inside that, look for a "var viewModel = {}"
                //
                // Note: This will often fail to eval for real implementations as there may be variables or code in the viewModel object
                //       member values that can't be evaluated client-side at design time.  In these cases, the "designViewModel" should
                //       be used if design-time support is desired.
                //
                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'InitializeViewModel'))
                {
                    if ((exp.expression.right.type === 'FunctionExpression') && (exp.expression.right.body.type === 'BlockStatement'))
                    {
                        var body = exp.expression.right.body.body;
                        for (var j = 0; j < body.length; j++)
                        {
                            if ((body[j].type === 'VariableDeclaration') && (body[j].declarations[0].id.name === 'viewModel'))
                            {
                                var node = body[j].declarations[0].init;
                                //console.log("Found viewModel in fn:", JSON.stringify(node, null, 4));
                                initViewModelRange = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);
                            }
                        }
                    }
                }
            }
        }

        if (view)
        {
            // !!! Define Synchro.getResourceUrl() and maybe others so they eval correctly (and work) at design time?
            //
            if (designViewModelRange) // var designViewModel = {}
            {
                eval("viewModel = " + editor.getSession().getTextRange(designViewModelRange));
            }
            else if (initViewModelRange) // fall back to var viewModel = {} from exports.InitializeViewModel
            {
                // !!! try/catch - if parse fails - messageBox (probably requires runtime state - recommend using "designViewModel")
                //
                eval("viewModel = " + editor.getSession().getTextRange(initViewModelRange));
            }

            renderView(view, viewModel);
        }
    }
    catch (e)
    {
        console.log("Err:", e);
    }
}

function selectViewNodeFromIndexes(indexes)
{
    var controlNode;

    try
    {
        var parsed = esprima.parse(editor.getValue(), { loc: true, comment: true });

        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'View'))
                {
                    var viewNode = exp.expression.right;
                    if (viewNode.type === 'ObjectExpression')
                    {
                        for (var i = 0; i < viewNode.properties.length; i++)
                        {
                            if (viewNode.properties[i].key.name === 'elements')
                            {
                                controlNode = viewNode.properties[i].value;
                                break;
                            }
                        }
                    }

                    // console.log("ControlNode:", JSON.stringify(controlNode, null, 4));

                    if (controlNode.elements.length > 1)
                    {
                        // If "elements" contains more than one control, then Synchro will wrap that control with a container (a vertical StackPanel).
                        // We want to remove that index operation from our indexes stack in that case.
                        // 
                        indexes.pop(); 
                    }

                    while (controlNode && indexes.length)
                    {
                        if (controlNode.type === 'ObjectExpression')
                        {
                            for (var j = 0; j < controlNode.properties.length; j++)
                            {
                                if ((controlNode.properties[j].key.name === 'contents') && (controlNode.properties[j].value.type === 'ArrayExpression'))
                                {
                                    console.log("Promoting 'contents' ArrayExpression");
                                    controlNode = controlNode.properties[j].value;
                                    break;
                                }
                            }
                        }

                        if (controlNode.type === 'ArrayExpression')
                        {
                            console.log("Getting ArrayExpression element:", indexes[indexes.length-1]);
                            controlNode = controlNode.elements[indexes.pop()];
                        }
                        else
                        {
                            console.log("Ended prematurely (ran out of elements) - controlNode.type:", controlNode.type);
                            controlNode = null;
                        }
                    }
                }
            }
        }
    }
    catch (e)
    {
        console.log("Err:", e);
    }

    return controlNode;
}


// document.elementFromPoint() only returns the top-most (in the view heirarchy) element.  We want the bottom-most one (the most specific
// element).  This function gets the top-most element, hides it temporarily, then gets the next top-most element, and so on, restoring it
// all at the end, and returning an array of elements (with the top-most at the start and the bottom-most at the end).
//
// http://stackoverflow.com/a/27884653/1227119
//
function allElementsFromPoint(x, y) 
{
    var element, elements = [];
    var old_visibility = [];
    while (true) 
    {
        element = document.elementFromPoint(x, y);
        if (!element || element === document.documentElement) 
        {
            break;
        }
        elements.push(element);
        old_visibility.push(element.style.visibility);
        element.style.visibility = 'hidden'; // Temporarily hide the element (without changing the layout)
    }
    for (var k = 0; k < elements.length; k++) 
    {
        elements[k].style.visibility = old_visibility[k];
    }
    elements.reverse();
    return elements;
}

// Find the bottom-most (from the tree perspective) Synchro control from a point (you could think if this as the top-most Synchro control
// in terms of the view heirarchy, as it is in front of any containing controls).
//
function getSynchroControlFromPoint(x, y)
{
    var elements = allElementsFromPoint(x, y);

    var synchroControl = null;
    for (var i = 0; i < elements.length; i++)
    {
        if ($(elements[i]).is('[class*="synchro-"]'))
        {
            synchroControl = elements[i];
        }
    }

    return synchroControl;
}

// Use the mouse to hover over Synchro controls in the rendered view, clicking the desired control to select it in the code window.
//
function selectControl()
{
    // Disable mouse/pointer events for all of our controls (so we can click to select them without interacting with them)
    //
    $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', 'none');

    // Remove any current visual item selection
    //
    $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

    $('#synchro_container').click(function(event)
    {
        // If pointer-events are suppressed, we won't be able to find any Synchro controls...
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', '');

        var synchroControl = getSynchroControlFromPoint(event.clientX, event.clientY);
        console.log("Synchro control clicked:", synchroControl);

        var parents = $(synchroControl).parents('[class*="synchro-"]');
        console.log("Parents:", parents);

        var indexes = [$(synchroControl).index()];
        for (var i = 0; i < parents.length; i++)
        {
            indexes.push($(parents[i]).index());
        }

        console.log("Indexes:", indexes);

        var viewNode = selectViewNodeFromIndexes(indexes);
        console.log("View node:", viewNode);

        selectNode(viewNode);

        $('#synchro_container').off('click mousemove mouseout');
        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

        return false;
    });

    $('#synchro_container').mousemove(function(event)
    {
        // If pointer-events are suppressed, we won't be able to find any Synchro controls...
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', '');

        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

        var synchroControl = getSynchroControlFromPoint(event.clientX, event.clientY);
        if (synchroControl)
        {
            $(synchroControl).css("outline", "1px dotted red");
        }

        // Re-suppress pointer-events
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', 'none');

        return false;
    });

    $('#synchro_container').mouseout(function(event)
    {
        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');
        return false;
    });

}

function nodeContainsPos(node, row, col)
{
    return !((row < node.loc.start.line) ||
             (row > node.loc.end.line) ||
             ((row == node.loc.start.line) && (col < node.loc.start.column)) ||
             ((row == node.loc.end.line) && (col > node.loc.end.column)));
}

function findControl(node, row, col, indexer)
{
    //console.log("Inspecting node of type:", node.type);

    var theIndexer = indexer || { indexes: [], currIndex: null };

    var qualifyingControl = null;
    var arrayToProcess = null;

    if (node.type === 'Program')
    {
        arrayToProcess = node.body;
    }
    else if (node.type === 'ExpressionStatement')
    {
        qualifyingControl = findControl(node.expression, row, col, theIndexer);
    }
    else if (node.type === 'AssignmentExpression')
    {
        // operator, left, right
        qualifyingControl = findControl(node.right, row, col, theIndexer);
    }
    else if (node.type === 'ObjectExpression')
    {
        for (var i = 0; i < node.properties.length; i++)
        {
            if ((node.properties[i].key.name === 'elements') && nodeContainsPos(node, row, col))
            {
                // If "elements" contains more than one control, then Synchro will wrap that control with a 
                // container (a vertical StackPanel).  We need to add an extra index (at 0) to accomodate that
                // "extra" control in the visual layout.
                // 
                if (node.properties[i].value.elements.length > 1)
                {
                    // console.log("Found 'elements' with multiple elements");
                    indexer.indexes.push(0);
                }
            }

            // console.log("Inspecting node property:", node.properties[i]);
            if ((node.properties[i].key.name === 'control') && nodeContainsPos(node, row, col))
            {
                // console.log("qualifying control at index:", indexer.currIndex);
                indexer.indexes.push(indexer.currIndex);
                qualifyingControl = node;
            }
        }
        arrayToProcess = node.properties;
    }
    else if (node.type === 'ArrayExpression')
    {
        arrayToProcess = node.elements;
    }
    else if (node.type === 'Property')
    {
        qualifyingControl = findControl(node.value, row, col, theIndexer); 
    }
    else if (node.type === 'Literal')
    {
        // node.value is value 
    }

    if (arrayToProcess)
    {
        for (var i = 0; i < arrayToProcess.length; i++)
        {
            theIndexer.currIndex = i;
            var result = findControl(arrayToProcess[i], row, col, theIndexer);
            if (result)
            {
                qualifyingControl = result;
                break;
            }
        }
    }

    if (qualifyingControl && (typeof indexer === 'undefined'))
    {
        // console.log("Final indexes:", theIndexer.indexes);
        qualifyingControl.indexes = theIndexer.indexes;
    }

    return qualifyingControl;
}

function findControlInModule(row, col)
{
    var options = 
    {
        loc: true,
        comment: true
    }

    try
    {
        var parsed = esprima.parse(editor.getValue(), options);
        return findControl(parsed, row, col)
    }
    catch (e)
    {
        // We don't really care about parsing errors (these happen a lot as we're editing code)
    }
}

function selectNode(node)
{
    var range = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);
    editor.selection.setSelectionRange(range, false);
}

function replaceNode(node, value)
{
    var range = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);
    editor.getSession().replace(range, value);
}

function removeNode(node)
{
    var range = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);

    // If the characters immediately following the node are ", " then we want to remove those as well...
    //
    var followRange = new Range(node.loc.end.line-1, node.loc.end.column, node.loc.end.line-1, node.loc.end.column + 2);
    if (", " === editor.getSession().getTextRange(followRange))
    {
        range.setEnd(node.loc.end.line-1, node.loc.end.column + 2);
    }

    editor.getSession().remove(range);
}

function getNodePropertyValue(node, property)
{
    for (var i = 0; i < node.properties.length; i++)
    {
        var prop = node.properties[i];
        if (prop.key.name == property)
        {
            return prop.value.value;
        }
    }
}

function selectVisualElementFromIndexes(visualElement, indexes)
{
    var elem = $(visualElement).children('[class*="synchro-"]').get(indexes.shift());
    if (indexes.length)
    {
        return selectVisualElementFromIndexes(elem, indexes);
    }
    else
    {
        return elem;
    }
}

// The control currently selected in the editor (meaning the cursor is located in the control, and the property inspector
// widgets are linked to that control).
//
var selectedControl; 

function onSelectionChange()
{
    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos.row + 1, pos.col);

    if (selectedControl != controlNode)
    {
        if (selectedControl)
        {
            // !!! Remove existing property inspector widgets
            //
            console.log("Removing property inspector widgets");
            $('#widget-container').empty();

            // Turn off any visual element selection
            //
            $('#synchro_container').find('[class*="synchro-"]').css('outline', '');
        }

        if (controlNode)
        {
            // !!! Create and populate property inspector widgets
            //
            console.log("Adding property inspector widgets for control of type:", getNodePropertyValue(controlNode, 'control'));

            var widgets = controlAttributes["*"];
            for (var i = 0; i < widgets.length; i++)
            {
                $('#widget-container').append(
                    "<div class='form-group'>" +
                        "<label for='widget_" + widgets[i].attribute + "'>" + widgets[i].caption + ":</label>" + 
                        "<input id='widget_" + widgets[i].attribute + "' type='text' class='form-control' oninput='propChange(this)'>" +
                    "</div>"
                );
                $('#widget_' + widgets[i].attribute).val(getNodePropertyValue(controlNode, widgets[i].attribute));
            }

            // Select the visual element that corresponds to the selected control node.
            //
            var elem = selectVisualElementFromIndexes($("#synchro_container"), controlNode.indexes);
            $(elem).css("outline", "1px dotted red");
        }

        selectedControl = controlNode;
    }
}

function onEditorChange() 
{
    // Update property inspector widget values from currently selected control node (if any).
    //  
    // Note: If we aren't in a control node, then we shouldn't have an property inspector widgets (so no need to clear values).
    //
    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos.row + 1, pos.col);

    var widgets = controlAttributes["*"];
    for (var i = 0; i < widgets.length; i++)
    {
        if (controlNode)
        {
            $('#widget_' + widgets[i].attribute).val(getNodePropertyValue(controlNode, widgets[i].attribute));
        }
    }
}

function selectControlText()
{
    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos.row + 1, pos.col);

    if (controlNode)
    {
        selectNode(controlNode);
    }
}

// Called when property inspector widget receives input
//
function propChange(control)
{
    var propName = $(control).attr("id").replace(/^widget_/, '');

    // Value may have to be converted to string/quoted (depending on type).  We will attempt to do a JSON parse+stringify, which
    // will handle numbers, booleans, and null.  Any value that fails JSON.parse is assumed to be a string and gets quoted.
    //
    // !!! When we have more sophisticated controls (like a "select" for orientation, or a complex control for font attributes), 
    //     we're going to have to be smarter about converting those control values to "value" here.
    //
    var value = control.value != "" ? control.value : null;
    if (value)
    {
        try
        {
            value = JSON.stringify(JSON.parse(value));
        }
        catch (e)
        {
            value = '"' + value + '"';
        }
    }

    console.log("Property '%s' changed to: %s", propName, value);

    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos.row + 1, pos.col);

    if (controlNode)
    {
        console.log("Found control:", controlNode);
        var attributes = [];
        for (var i = 0; i < controlNode.properties.length; i++)
        {
            var prop = controlNode.properties[i];
            if (prop.key.name == propName)
            {
                ignoreSelChange = true;
                if (value)
                {
                    replaceNode(prop.value, value);
                }
                else
                {
                    removeNode(prop);
                }
                ignoreSelChange = false;
                return;
            }
            attributes.push(prop.key.name);
        }

        // We found the control node, but not the property.  We need to add it according to "attributeOrder".
        //
        var attributeIndex = attributeOrder.indexOf(propName);
        if (attributeIndex != -1)
        {
            console.log("attributeOrder index of property '%' is:", propName, attributeIndex);
            console.log("attributes of control:", attributes);

            for (var j = attributeIndex-1; j >= 0; j--)
            {
                var precedentIndex = attributes.indexOf(attributeOrder[j]);
                if (precedentIndex != -1)
                {
                    console.log("Found precedent attribute '%s' as attribute index: %d in control", attributeOrder[j], precedentIndex);

                    var precedentAttributeNode = controlNode.properties[precedentIndex];
                    console.log("Add property '%s' after precedent node:", propName, precedentAttributeNode);

                    // Add the attribute (propName) after the precedentAttributeNode (in the editor, based on the location of the
                    // precedentAttributeNode).  Consider that the precedentAttributeNode may or may not currently be the last attribute
                    // on the control node (so may or may not be followed by a comma).
                    //
                    ignoreSelChange = true;
                    editor.getSession().insert({row: precedentAttributeNode.loc.end.line-1, column: precedentAttributeNode.loc.end.column}, ", " + propName + ": " + value);
                    ignoreSelChange = false;
                    break;
                }
            }
        }
        else
        {
            // !!! propName attribute not found in attributeOrder array - add the property someplace reasonable (at the end, or right before
            //     "content" if "content" exists).
            //
            console.log("!!! Property '%' not found in attributeOrder array", propName);
        }

    }
}

function onLoadModule(moduleName)
{
    console.log("Load modules:", moduleName);

    $.getJSON("module", { module: moduleName }, function(data)
    {
        // Process JSON response
        console.log("loadModule " + moduleName + ": " + JSON.stringify(data));
        editor.session.setValue(data.source);

        // Highlight the new active module...
        //
        $("div#modules a.active").removeClass("active");
        $("div#modules a[module='" + moduleName + "']").addClass("active");
     })
    .fail(function() 
    {
        alert( "loadModule error" );
    });

    return false; // To prevent default click behavior
}
