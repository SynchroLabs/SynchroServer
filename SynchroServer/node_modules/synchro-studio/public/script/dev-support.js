// Dev Support
//
// ACE editor: https://ace.c9.io/
//
// Esprima parser: http://esprima.org/
//

Range = require("ace/range").Range;

var selectedOutline = "1px dashed red";
var selectedOutlineOffset = 2;

// When we add attributes to a control node, we will add them in this order.  When adding a new attribute (one that is not
// present on the node), find the attribute in this list.  If found, navigate up the list until you find an attribute from
// the this list that is present on the node, then insert the attribute being added after that attribue on the node.
//
var attributeOrder =
[
    "control",
    "height",
    "width",
    "color", // Border, Button, Rectangle, Text
    "background",
    "margin",
    "padding", // Border, StackPanel
    "visibility",
    "opacity",
    "enabled",
    "orientation", // ScrollView, StackPanel, WrapPanel
    "horizontalAlignment",
    "verticalAlignment",

    "caption", // Button
    "icon", // Button
    "resource", // Button, Image

    "font", // Edit, Password, Text

    "value", // Text, ProgressRing
    "binding",

    "border", // Border, Rectangle
    "borderThickness", // Border, Rectangle
    "cornerRadius", // Border, Rectangle

    "borderless", // Button

    "lines", // Edit
    "multiline", // Edit
    "placeholder", // Edit

    "ellipsize", // Text
    "textAlignment", // Text

    "url", // WebView

    "movementThreshold", // Location

    "minimum", // ProgressBar, Slider
    "maximum", // ProgressBar, Slider

    "scale", // Image

    "select", // ListBox, ListView

    "itemHeight", // WrapPanel
    "itemWidth", // WrapPanel

    "header", // ListView
    "itemTemplate", // ListView
    "footer", // ListView

    "contents" // Border, Canvas, ScrollView, StackPanel, WrapPanel (all containers), WebView (different meaning)
];

// Control metadata
//
var controlMeta = 
{
    "*": {
        attributes: [
            { caption: "Height", attribute: "height", type: "number" },
            { caption: "Width", attribute: "width", type: "number" },
            { caption: "Visibility", attribute: "visibility", type: "boolean" },
            { caption: "Enabled", attribute: "enabled", type: "boolean" },
            { caption: "Opacity", attribute: "opacity", type: "number" }, // Range: 0-1
            { caption: "Horizontal Alignment", attribute: "horizontalAlignment", type: "select", values: ["Left", "Center", "Right"] },
            { caption: "Vertical Alignment", attribute: "verticalAlignment", type: "select", values: ["Top", "Center", "Bottom"] },
            { caption: "Margin", attribute: "margin", type: "thickness" },
            { caption: "Background", attribute: "background", type: "color" },
        ]
    },
    "border": {
        name: "Border",
        attributes: [
            { caption: "Border Color", attribute: "border", type: "color" },
            { caption: "Border Thickness", attribute: "borderThickness", type: "thickness" },
            { caption: "Corner Radius", attribute: "cornerRadius", type: "number" },
            { caption: "Padding", attribute: "padding", type: "thickness" },
        ],
        bindings: ["onTap"],
        container: true, // single
        proto: '{ control: "border", border: "Red", contents: [] }',
    },
    "button": {
        name: "Button",
        attributes: [
            { caption: "Caption", attribute: "caption", type: "string" },
            { caption: "Icon", attribute: "icon", type: "string" },
            { caption: "Color", attribute: "color", type: "color" },
            { caption: "Borderless", attribute: "borderless", type: "boolean" },
            // resource
        ],
        bindings: ["onClick"],
        proto: '{ control: "button", caption: "Button" }',
    },
    "canvas": {
        name: "Canvas",
        attributes: [
        ],
        container: true,
        proto: '{ control: "canvas", contents: [] }',
    },
    "edit": {
        name: "Edit",
        attributes: [
            { caption: "Font", attribute: "font", type: "font" },
            { caption: "Lines", attribute: "lines", type: "number" },
            { caption: "Multiline", attribute: "multiline", type: "boolean" },
            { caption: "Placeholder", attribute: "placeholder", type: "string" },
        ],
        bindings: ["value", "sync"], // sync == "change"
        proto: '{ control: "edit" }',
    },
    "image": {
        name: "Image",
        attributes: [
            { caption: "Scale", attribute: "scale", type: "select", values: ["Stretch", "Fit", "Fill"] },
            { caption: "Resource", attribute: "resource", type: "string" },
        ],
        bindings: ["onTap"],
        proto: '{ control: "image" }',
    },
    "listbox": {
        name: "Listbox",
        attributes: [
            { caption: "Selection", attribute: "select", type: "select", values: ["None", "Single", "Multiple"] },
        ],
        bindings: ["items"], // !!! More (complex)
        proto: '{ control: "listbx" }',
    },
    "listview": {
        name: "List View",
        attributes: [
            { caption: "Selection", attribute: "select", type: "select", values: ["None", "Single", "Multiple"] },
            // header, footer, itemTemplate
        ],
        bindings: ["items"], // !!! More (complex)
        proto: '{ control: "listview" }',
    },
    "location": {
        name: "Location",
        attributes: [
            { caption: "Movement Threshold", attribute: "movementThreshold", type: "number" },
        ],
        bindings: ["value", "sync", "onUpdate"], // sync == "change"
        visualElement: false,
        proto: '{ control: "location" }',
    },
    "password": {
        name: "Password",
        attributes: [
            { caption: "Font", attribute: "font", type: "font" },
            { caption: "Placeholder", attribute: "placeholder", type: "string" },
        ],
        bindings: ["value", "sync"], // sync == "change"
        proto: '{ control: "password" }',
    },
    "picker": {
        name: "Picker",
        attributes: [
        ],
        bindings: ["items"], // !!! More (complex)
        proto: '{ control: "picker" }',
    },
    "progressbar": {
        name: "Progress Bar",
        attributes: [
            { caption: "Minimum", attribute: "minimum", type: "number" },
            { caption: "Maximum", attribute: "maximum", type: "number" },
        ],
        bindings: ["value"],
        proto: '{ control: "progressbar" }',
    },
    "progressring": {
        name: "Progress Ring",
        attributes: [
            { caption: "Value", attribute: "value", type: "boolean" },
        ],
        proto: '{ control: "progressring" }',
    },
    "rectangle": {
        name: "Rectangle",
        attributes: [
            { caption: "Border Color", attribute: "border", type: "color" },
            { caption: "Border Thickness", attribute: "borderThickness", type: "thickness" },
            { caption: "Corner Radius", attribute: "cornerRadius", type: "number" },
            { caption: "Color", attribute: "color", type: "color" },
        ],
        bindings: ["onTap"],
        proto: '{ control: "rectangle", color: "Green" }',
    },
    "scrollview": {
        name: "Scroll View",
        attributes: [
            { caption: "Orientation", attribute: "orientation", type: "select", values: ["Horizontal", "Vertical"] },
        ],
        container: true,
        proto: '{ control: "scrollview", orientation: "Vertical", contents: [] }',
    },
    "slider": {
        name: "Slider",
        attributes: [
            { caption: "Minimum", attribute: "minimum", type: "number" },
            { caption: "Maximum", attribute: "maximum", type: "number" },
        ],
        proto: '{ control: "slider" }',
    },
    "stackpanel": {
        name: "Stack Panel",
        attributes: [
            { caption: "Orientation", attribute: "orientation", type: "select", values: ["Horizontal", "Vertical"] },
            { caption: "Padding", attribute: "padding", type: "thickness" },
        ],
        container: true,
        proto: '{ control: "stackpanel", orientation: "Vertical", contents: [] }',
    },
    "text": {
        name: "Text",
        attributes: [
            { caption: "Font", attribute: "font", type: "font" },
            { caption: "Color", attribute: "color", type: "color" },
            { caption: "Ellipsize", attribute: "ellipsize", type: "boolean" },
            { caption: "Text Alignment", attribute: "textAlignment", type: "select", values: ["Left", "Center", "Right"] },
            { caption: "Value", attribute: "value", type: "boolean" },
        ],
        proto: '{ control: "text", value: "Text" }',
    },
    "togglebutton": {
        name: "Toggle Button",
        attributes: [
            // !!!
        ],
        bindings: ["value", "onToggle"],
        proto: '{ control: "togglebutton" }',
    },
    "toggle": {
        name: "Toggle",
        attributes: [
            // !!!
        ],
        bindings: ["value", "onToggle"],
        proto: '{ control: "toggle" }',
    },
    "webview": {
        name: "Web View",
        attributes: [
            // !!! contents or url
        ],
        proto: '{ control: "webview" }',
    },
    "wrappanel": {
        name: "Wrap Panel",
        attributes: [
            { caption: "Orientation", attribute: "orientation", type: "select", values: ["Horizontal", "Vertical"] },
            { caption: "Item Height", attribute: "itemHeight", type: "number" },
            { caption: "Item Width", attribute: "itemWidth", type: "number" },
        ],
        container: true,
        proto: '{ control: "wrappanel", orientation: "Horizontal", contents: [] }',
    },
}

function onDocumentReady()
{
    // http://layout.jquery-dev.com/
    //
    $('body').layout(
    { 
        center__paneSelector: ".ui-layout-center",
        north__spacing_open: 0, // Makes non-sizable
        center__childOptions: {
            center__paneSelector: ".middle-center",
            north__paneSelector:  ".middle-north",
        },
        east__childOptions: {
            center__paneSelector: ".right-center",
            south__paneSelector:  ".right-south",
        }
    });

    var middleLayout = $("div.ui-layout-center").layout();
    middleLayout.sizePane("north", 300);

    initEditor();
    clearPropertyInspectors();
}

var editor;
var ignoreSelChange = false;

var _parsedModule = null;

function getParsedModule()
{
    if (!_parsedModule)
    {
        _parsedModule = esprima.parse(editor.getValue(), { loc: true, comment: true });
    }
    return _parsedModule;
}

function invalidateParsedModule()
{
    _parsedModule = null;
}

function initEditor()
{
    editor = ace.edit("editor");
    editor.setTheme("ace/theme/monokai");
    editor.getSession().setMode("ace/mode/javascript");
    editor.$blockScrolling = Infinity;

    editor.getSession().on('change', function(e) 
    {
        console.log("Change content - type: %s, data: %s", e.type, JSON.stringify(e.data));
        invalidateParsedModule();
        if (!ignoreSelChange)
        {
            onEditorChange();
        }
    });

    editor.getSession().selection.on('changeCursor', function(e) 
    {
        var pos = editor.selection.getCursor();
        console.log("Change cursor pos - row: %s, col: %s", pos.row, pos.column);
        if (!ignoreSelChange)
        {
            onSelectionChange();
        }
    });

    editor.getSession().selection.on('changeSelection', function(e) 
    {
        console.log("Change selection");
    });

    // Control palette drag support
    //
    $("#control-list").children().each(function()
    {
        $(this).attr("draggable", true);

        $(this).on('dragstart', function(ev)
        {
            var event = ev.originalEvent;
            console.log("Dragstart:", event);

            // By setting the data into event.dataTransfer, it can be dropped anywhere that supports text (not just on our own editor)
            //
            event.dataTransfer.setData('text', controlMeta[$(this).attr('id')].proto);

            // Set the editor to read-only so that it won't attempt to update its cursor position while we're dragging (since
            // we're going to be doing that ourselves based on logic that takes into account controls as drop targets).
            //
            editor.setReadOnly(true);
        });

        $(this).on('dragend', function(ev)
        {
            var event = ev.originalEvent;
            console.log("Dragend:", event);

            editor.setReadOnly(false);
        });
    });

    //
    // Drag over / drop on editor
    //

    $("#editor").on('dragover', function(ev)
    {
        // Only want to fire this if we're dragging control (otherwise we'll mess up Ace's built-in text drag/drop)
        //
        if (editor.getReadOnly())
        {
            var event = ev.originalEvent;
            //console.log("Dragover:", event);

            var screenPos = editor.renderer.pixelToScreenCoordinates(event.clientX, event.clientY);
            var docPos = editor.session.screenToDocumentPosition(screenPos.row, screenPos.column);
            var target = getEditorDropTarget(docPos);
            if (target)
            {
                showEditorDropTarget(target);
                showUXDropTarget(target);
                event.preventDefault(); // Indicates that drop is supported/allowed
                editor.focus();
            }
            else
            {
                console.log("Clear selection");
                editor.selection.clearSelection();
            }
        }
    });

    $("#editor").on('drop', function(ev)
    {
        if (editor.getReadOnly())
        {
            var event = ev.originalEvent;
            console.log("Dropped:", event);

            var screenPos = editor.renderer.pixelToScreenCoordinates(event.clientX, event.clientY);
            var docPos = editor.session.screenToDocumentPosition(screenPos.row, screenPos.column);
            var target = getEditorDropTarget(docPos);
            if (target)
            {
                var data = event.dataTransfer.getData('Text');
                dropOnEditor(target, data)
                editor.focus();
            }
            else
            {
                editor.selection.clearSelection();
            }

            event.preventDefault();
        }
    });

    //
    // Drag over / drop on UX preview
    //

    $("#synchro_container").on('dragover', function(ev)
    {
        var event = ev.originalEvent;
        //console.log("Dragover:", event);

        var target = getUXDropTarget(event.clientX, event.clientY);
        if (target)
        {
            showUXDropTarget(target);
            showEditorDropTarget(target);
            event.preventDefault(); // Indicates that drop is supported/allowed
        }
        else
        {
            clearUXDropTarget();
        }
    });

    $("#synchro_container").on('dragout', function(ev)
    {
        var event = ev.originalEvent;
        event.preventDefault();
        console.log("Dragout:", event);

        clearUXDropTarget();
    });

    $("#synchro_container").on('drop', function(ev)
    {
        var event = ev.originalEvent;
        event.preventDefault();
        console.log("Dropped:", event);

        clearUXDropTarget();

        var target = getUXDropTarget(event.clientX, event.clientY);
        if (target)
        {
            var data = event.dataTransfer.getData('Text');
            dropOnEditor(target, data)
            editor.focus();
        }
    });
}

var renderView; // renderView(view, viewModel)

function SynchroInit(synchro)
{
    renderView = synchro.renderView;

    var synchroApp =
    {
        container: document.getElementById('synchro_container'), // required
        onSetPageTitle: function(title) // optional
        {
            console.log("Page title set:", title);
            document.getElementById('synchro_title').innerHTML = title;
        },
        logConfig: {}, // optional, developer setting
    }

    return synchroApp;
}

function getEditorDropTarget(docPos)
{
    // Deterine the element that is being dragged over, and where to insert the dragged element relative to that element (before, 
    // after, or into).
    //
    var view = getViewNode();
    var elementsProp = getNodeProperty(view, "elements");
    var elements = elementsProp && elementsProp.value;
    if (view && elements && nodeContainsPos(elements, docPos))
    {
        var target = 
        {
            node: view,
            position: "into",
            attribute: "elements"
        }

        var contentsArrayNode = elements;

        var controlNode = findControlInModule(docPos);
        if (controlNode)
        {
            target.node = controlNode;

            var contents = getNodeProperty(target.node, "contents");
            if (contents && nodeContainsPos(contents, docPos))
            {
                target.attribute = "contents";
                contentsArrayNode = contents.value;
            }
            else
            {
                target.attribute = null;
                contentsArrayNode = null;
            }
        }

        if (contentsArrayNode && (contentsArrayNode.type === 'ArrayExpression'))
        {
            // We are in a contents array (in an elements or contents attribute, but not over an actual control).
            //
            // If the contents array is empty, we will keep the default position of "into", otherwise we will determine
            // the control in the contents array that the drop target should be before or after, and the position of the
            // drop target.
            //
            if (contentsArrayNode.elements.length > 0)
            {
                var controlType = getNodePropertyValue(target.node, "control");
                if ((controlType === 'border') || (controlType === 'scrollview'))
                {
                    // If the container is a border or scrollview and it already has an item in it, then drop is not permitted
                    //
                    return null;
                }

                var beforeElement = -1;
                for (var i = 0; i < contentsArrayNode.elements.length; i++)
                {
                    var contentRange = rangeFromLocation(contentsArrayNode.elements[i].loc);
                    if (contentRange.comparePoint(docPos) == -1)
                    {
                        beforeElement = i;
                        break;
                    }
                }

                if (beforeElement >= 0)
                {
                    // Before the given element
                    //
                    target.node = contentsArrayNode.elements[beforeElement];
                    target.position = "before";
                    target.attribute = null;
                }
                else
                {
                    // After the last element
                    //
                    target.node = contentsArrayNode.elements[contentsArrayNode.elements.length-1];
                    target.position = "after";
                    target.attribute = null;
                }
            }
        }
        else if (controlNode)
        {
            // !!! TODO: If this control's parent is a border or scrollview, then drop is not permitted (the parent is already full)
            //

            // We are over a control, so that is our target.  We determine whether the position is before or after by
            // testing which end of the target control range is closest to the drag location.
            //
            target.node = controlNode;
            target.position = isCloserToRangeStart(rangeFromLocation(controlNode.loc), docPos) ? "before" : "after";
            target.attribute = null;
        }

        return target;
    }
}

function showEditorDropTarget(target)
{
    if (target.position === "into")
    {
        // Place cursor in the elements/contents attribute value (which should be an empty ArrayExpression) - just advance
        // one char past start of ArrayExpression value.
        //
        var contentsProp = getNodeProperty(target.node, target.attribute);
        if (contentsProp && (contentsProp.value.type === 'ArrayExpression'))
        {
            var contentValueRange = rangeFromLocation(contentsProp.value.loc);
            contentValueRange.moveBy(0, 1);
            contentValueRange.setEnd(contentValueRange.start);
            editor.selection.setSelectionRange(contentValueRange);
        }
    }
    else
    {
        // Select target control and place cursor at beginning or end of selection as appropriate.
        //
        var range = rangeFromLocation(target.node.loc);
        editor.selection.setSelectionRange(range, target.position === 'before');
    }
}

function dropOnEditor(target, data)
{
    if (target.position === "into")
    {
        // Drop into the "contents" attribute value (which should be an empty ArrayExpression) - just advance one char past
        // start of ArrayExpression value.
        //
        var contentsProp = getNodeProperty(target.node, target.attribute);
        if (contentsProp && (contentsProp.value.type === 'ArrayExpression'))
        {
            var contentValueRange = rangeFromLocation(contentsProp.value.loc);
            contentValueRange.moveBy(0, 1);

            // Put the new item on it's own line (indented property), and put the close square bracked on its own line...
            //
            var targetRange = rangeFromLocation(target.node.loc);
            var insert = "\n" + spaces(targetRange.start.column + 4) + data + "\n" + spaces(targetRange.start.column);
            var end = editor.getSession().insert(contentValueRange.start, insert);

            // We only want to select the inserted control (not any other added formatting or whitespace)
            //
            var dataRange = Range.fromPoints(
                { row: contentValueRange.start.row + 1, column: targetRange.start.column + 4 },
                { row: contentValueRange.start.row + 1, column: targetRange.start.column + 4 + data.length }
            );
            editor.selection.setSelectionRange(dataRange);
        }
    }
    else if (target.position === 'before')
    {
        // Put the new control on it's own line, aligned with the control it's being placed before
        //
        var range = rangeFromLocation(target.node.loc);
        var insert = data + ", \n" + spaces(range.start.column);
        var end = editor.getSession().insert(range.start, insert);

        // We only want to select the inserted control (not any other added formatting or whitespace)
        //
        var dataRange = Range.fromPoints(range.start, {row: range.start.row, column: range.start.column + data.length});
        editor.selection.setSelectionRange(dataRange);
    }
    else if (target.position === 'after')
    {
        // Put the new control on it's own line, aligned with the control it's being placed after
        //
        var range = rangeFromLocation(target.node.loc);
        var insert = ",\n" + spaces(range.start.column) + data;
        var end = editor.getSession().insert(range.end, insert);

        // We only want to select the inserted control (not any other added formatting or whitespace)
        //
        var dataRange = Range.fromPoints({row: range.end.row + 1, column: range.start.column}, end);
        editor.selection.setSelectionRange(dataRange);
    }
}

function isPositionBefore(element, orientation, clientX, clientY)
{
    var offset = $(element).offset();
    var width = $(element).outerWidth();
    var height = $(element).outerHeight();
    var hPos = (clientX - offset.left) / width; // Horizontal position in control, range: 0-1
    var vPos = (clientY - offset.top) / height; // Vertical position in control, range: 0-1
    // console.log("clientX: %d, clientY: %d, width: %d, height: %d, hPos: %s, vPos: %s", clientX, clientY, width, height, hPos, vPos);

    // Our "position within control" value to be used in target position calc below depends on our parent orientation.
    //
    var pos = (orientation === "Horizontal") ? hPos : vPos;

    return  pos <= 0.5; // Are we in the first half of the control, in the direction of orientation (such that we'd want to insert "before")
}

function getOrientation(element)
{
    return element.style.flexDirection == "column" ? "Vertical" : "Horizontal"
}

// If the control we are over is an empty container, drop target is the container and position is "into".
//
// If the control we are over is a non-empty container, we need to evaluate our position relative to the orientation 
// of our parent for each contained child control to see which one should be the target and what the position (before/after)
// should be.
//
// If the control we are over is not a container, we just look at our position in the control relative to the orientation
// of our parent to determine if the drop target is before or after the target.
//
function getUXDropTarget(clientX, clientY)
{
    // Get Synchro UX control (HTML element) from point
    //
    var synchroControl = getSynchroControlFromPoint(clientX, clientY);
    //console.log("Synchro control over:", synchroControl);

    // We assume that this function is only called when dragging over synchro_container
    //
    var view = getViewNode();

    var target = 
    {
        node: view,
        position: "into",
        attribute: "elements",
        orientation: "Vertical"
    }

    var container = $("#synchro_container");

    // When the top level 'elements' contains more than one control, a synthetic "stackpanel" will be created to hold those 
    // controls.  In that case, we want to treat that control as the container.
    //
    var elementsProp = getNodeProperty(view, "elements");
    if (elementsProp && (elementsProp.value.type == 'ArrayExpression'))
    {
        if (elementsProp.value.elements.length > 1)
        {
            // More than one control in 'elements', promote synthetic "stackpanel" to container.
            //
            container = $(container.children('[class*="synchro-"]')[0]);
        }
    }

    // Check to see if we are over a container control, so that if so, we can positon relative to container contents below.
    //
    if (synchroControl)
    {
        var node = getViewNodeFromUXControl(synchroControl); // This will return null on top level "elements" (synthesized container)
        if (node)
        {
            target.node = node;

            if (getNodeProperty(target.node, "contents"))
            {
                container = $(synchroControl);
                target.attribute = "contents";
            }
            else
            {
                container = null;
            }
        }
    }

    if (container) // We are over a container, position relative to container contents.
    {
        // Enum direct children that are synchro controls.  If not emoty, then loop through them to find the target and relative
        // position (based on control location, orientation of parent container, and client coordinates).
        //
        var children = container.children('[class*="synchro-"]');
        if (children.length > 0)
        {
            var controlType = getNodePropertyValue(target.node, "control");
            if ((controlType === 'border') || (controlType === 'scrollview'))
            {
                // If the container is a border or scrollview and it already has an item in it, then drop is not permitted
                //
                return null;
            }

            var beforeElement = -1;
            target.orientation = getOrientation(container.get(0));

            // !!! This logic of iterating container children and determining insertion target based on "is before" works with
            //     linear layouts (like stackpanel, or a wrappanel that does not wrap).  But this will not work on a wrappanel
            //     that has wrapped for items not in the first row/col.  And canvas is a whole-nother ball of wax.
            //  
            for (var i = 0; i < children.length; i++)
            {
                if (isPositionBefore(children[i], target.orientation, clientX, clientY))
                {
                    beforeElement = i;
                    break;
                }
            }

            if (beforeElement >= 0)
            {
                // Before the given element
                //
                target.node =  getViewNodeFromUXControl(children[beforeElement]);
                target.position = "before";
                target.attribute = null;
            }
            else
            {
                // After the last element
                //
                target.node =  getViewNodeFromUXControl(children[children.length-1]);
                target.position = "after";
                target.attribute = null;
            }
        }
    }
    else // We are not over a container, position relative to control we are over.
    {
        var parent = $(synchroControl).parent();
        if (parent && (parent.length > 0))
        {
            var parentNode = getViewNodeFromUXControl(parent.get(0));
            if (parentNode)
            {
                var controlType = getNodePropertyValue(parentNode, "control");
                if ((controlType === 'border') || (controlType === 'scrollview'))
                {
                    // If this control's parent is a border or scrollview, then drop is not permitted (the parent is already full)
                    //
                    return null;
                }
            }

            // flexDirection "column" is vertical, "row" is horizontal (default)
            //
            target.orientation = getOrientation(parent.get(0));
        }

        target.position = isPositionBefore(synchroControl, target.orientation, clientX, clientY) ? "before" : "after";
        target.attribute = null;
    }

    if (!target.node)
    {
        console.log("Target node not found:", target);
    }

    return target;
}

function showUXDropTarget(target)
{
    clearUXDropTarget();

    var synchroControl = $("#synchro_container");
    if (target.attribute != 'elements')
    {
        synchroControl = selectVisualElementFromIndexes($("#synchro_container"), target.node.indexes);
    }

    if (synchroControl)
    {
        if (target.position === 'into')
        {
            // For "into", we just highlight the container (which should be empty)
            //
            $(synchroControl).css("outline", selectedOutline);
            $(synchroControl).css("outline-offset", selectedOutlineOffset);
        }
        else
        {
            // Determine orientation if not already set (such as when drop target determined from edit control)
            //
            if (!target.orientation)
            {
                target.orientation = "Vertical";
                var parent = $(synchroControl).parent();
                if (parent && (parent.length > 0))
                {
                    target.orientation = getOrientation(parent.get(0));
                }
            }

            // For "before" or "after", we create and position a placeholder element to show where the insertion
            // would go relative to the target node element.
            //
            var placeholder = document.createElement("div");
            placeholder.id = 'placeholder';
            placeholder.style.position = 'absolute';
            placeholder.style.pointerEvents = 'none';
            placeholder.style.background = '#000000';

            var pos = $(synchroControl).position();

            // Note: pos incluces margins, so we need to add in top/left margin.  The parseInt is required
            //       because JQuery appends "px" to the numeric values.
            //
            pos.top += parseInt($(synchroControl).css('margin-top'));
            pos.left += parseInt($(synchroControl).css('margin-left'));

            // Adjust for parent scroll
            //
            pos.top += $('#synchro_container').parent().scrollTop();
            pos.left += $('#synchro_container').parent().scrollLeft();

            // Size and position placeholder
            //
            var thickness = 1;
            var padding = 4;

            if (target.orientation === 'Horizontal')
            {
                placeholder.style.height = $(synchroControl).outerHeight() + 'px';
                placeholder.style.width = thickness + 'px';

                if (target.position === 'before')
                {
                    placeholder.style.top = pos.top + 'px'; 
                    placeholder.style.left = pos.left - padding + 'px';
                }
                else // after
                {
                    placeholder.style.top = pos.top + 'px'; 
                    placeholder.style.left = pos.left + $(synchroControl).outerWidth() + padding + 'px';
                }
            }
            else // Vertical
            {
                placeholder.style.height = thickness + 'px';
                placeholder.style.width = $(synchroControl).outerWidth() + 'px';

                if (target.position === 'before')
                {
                    placeholder.style.top = pos.top - padding + 'px';
                    placeholder.style.left = pos.left + 'px';
                }
                else // after
                {
                    placeholder.style.top = pos.top + $(synchroControl).outerHeight() + padding + 'px';
                    placeholder.style.left = pos.left + 'px';
                }
            }

            $("#synchro_container").parent().append(placeholder);
            $('#placeholder').css("outline", selectedOutline);
            $('#placeholder').css("outline-offset", selectedOutlineOffset);
        }
    }
}

function clearUXDropTarget(target)
{
    $('#placeholder').remove();
    $('#synchro_container').find('[class*="synchro-"]').css('outline', '');
}

function spaces(n)
{
    var str = "";
    for (var i = 0; i < n; i++) 
    {
        str += ' ';
    }
    return str;
}

// Return the distance between two points in the editor
//
function distance(point1, point2)
{
    // In the Ace editor the rows are about twice as tall as the columns are wide, so we'll double the row delta to make
    // the distance calculation work.
    //
    return Math.sqrt(Math.pow((point1.row - point2.row) * 2, 2) + Math.pow(point1.column - point2.column, 2));
}

// Return a boolean indicating whether the provided point is closer to the start of the range than the end.
//
function isCloserToRangeStart(range, point)
{
    return (distance(range.start, point) < distance(range.end, point));
}

function rangeFromLocation(loc)
{
    // Note: Parser "location" line values are 1-based, whereas document range rows are 0-based (even though the line numbering
    //       shown in the editor starts with 1).
    //
    var range = new Range(loc.start.line-1, loc.start.column, loc.end.line-1, loc.end.column);
    return range;
}

function getViewNode()
{
    try
    {
        var parsed = getParsedModule();
        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'View'))
                {
                    return exp.expression.right;
                }
            }
        }
    }
    catch (e)
    {
        console.log("Err:", e);
    }
}

function updateView()
{
    try
    {
        var parsed = getParsedModule();

        var view;
        var viewModel = {};

        var initViewModelRange;
        var designViewModelRange;

        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'View'))
                {
                    var node = exp.expression.right;
                    // console.log("Found View:", node);

                    var range = rangeFromLocation(node.loc);

                    // This is a little creepy.  The View defintion in a Synchro module is not required to be JSON encoded (it's a
                    // JavaScript object).  So, for example, keys do not need to be quoted, and there can even be code in the values
                    // being assigned (though we're not trying to support that).  For this reason, we need to parse the found View as
                    // a JavaScript object, not as JSON.  The only way to do that is with good old eval().
                    //
                    eval("view = " + editor.getSession().getTextRange(range));
                }

                // Look for a top-level "var designViewModel = {}"
                //
                if ((exp.type === 'VariableDeclaration') && (exp.declarations[0].id.name === 'designViewModel'))
                {
                    var node = exp.declarations[0].init;
                    //console.log("Found designViewModel:", JSON.stringify(node, null, 4));
                    designViewModelRange = rangeFromLocation(node.loc);
                }

                // Look for a top-level exports.InitializeViewModel function, and inside that, look for a "var viewModel = {}"
                //
                // Note: This will often fail to eval for real implementations as there may be variables or code in the viewModel object
                //       member values that can't be evaluated client-side at design time.  In these cases, the "designViewModel" should
                //       be used if design-time support is desired.
                //
                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'InitializeViewModel'))
                {
                    if ((exp.expression.right.type === 'FunctionExpression') && (exp.expression.right.body.type === 'BlockStatement'))
                    {
                        var body = exp.expression.right.body.body;
                        for (var j = 0; j < body.length; j++)
                        {
                            if ((body[j].type === 'VariableDeclaration') && (body[j].declarations[0].id.name === 'viewModel'))
                            {
                                var node = body[j].declarations[0].init;
                                //console.log("Found viewModel in fn:", JSON.stringify(node, null, 4));
                                initViewModelRange = rangeFromLocation(node.loc);
                            }
                        }
                    }
                }
            }
        }

        if (view)
        {
            // !!! Define Synchro.getResourceUrl() and maybe others so they eval correctly (and work) at design time?
            //
            if (designViewModelRange) // var designViewModel = {}
            {
                eval("viewModel = " + editor.getSession().getTextRange(designViewModelRange));
            }
            else if (initViewModelRange) // fall back to var viewModel = {} from exports.InitializeViewModel
            {
                // !!! try/catch - if parse fails - messageBox (probably requires runtime state - recommend using "designViewModel")
                //
                eval("viewModel = " + editor.getSession().getTextRange(initViewModelRange));
            }

            renderView(view, viewModel);
        }
    }
    catch (e)
    {
        console.log("Error rendering view:", e);
        renderView({elements:[]}, {});
    }
}

function selectViewNodeFromIndexes(indexes)
{
    var controlNode;
    var indexesCopy = indexes.slice(0); // We don't want to modify passed-in indexes array

    try
    {
        var parsed = getParsedModule();
        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'View'))
                {
                    var viewNode = exp.expression.right;
                    if (viewNode.type === 'ObjectExpression')
                    {
                        for (var i = 0; i < viewNode.properties.length; i++)
                        {
                            if (viewNode.properties[i].key.name === 'elements')
                            {
                                controlNode = viewNode.properties[i].value;
                                break;
                            }
                        }
                    }

                    // console.log("ControlNode:", JSON.stringify(controlNode, null, 4));

                    if (controlNode.elements.length > 1)
                    {
                        // If "elements" contains more than one control, then Synchro will wrap that control with a container (a vertical StackPanel).
                        // We want to remove that index operation from our indexes stack in that case.
                        // 
                        indexesCopy.pop(); 
                    }

                    if (indexesCopy.length == 0)
                    {
                        return null;
                    }

                    while (controlNode && indexesCopy.length)
                    {
                        if (controlNode.type === 'ObjectExpression')
                        {
                            for (var j = 0; j < controlNode.properties.length; j++)
                            {
                                if ((controlNode.properties[j].key.name === 'contents') && (controlNode.properties[j].value.type === 'ArrayExpression'))
                                {
                                    //console.log("Promoting 'contents' ArrayExpression");
                                    controlNode = controlNode.properties[j].value;
                                    break;
                                }
                            }
                        }

                        if (controlNode.type === 'ArrayExpression')
                        {
                            //console.log("Getting ArrayExpression element:", indexesCopy[indexesCopy.length-1]);
                            controlNode = controlNode.elements[indexesCopy.pop()];
                        }
                        else
                        {
                            console.log("Ended prematurely (ran out of elements) - controlNode.type:", controlNode.type);
                            controlNode = null;
                        }
                    }

                    if (controlNode)
                    {
                        controlNode.indexes = indexes.slice(0).reverse(); // Reversed copy of original indexes used to find this element
                    }
                }
            }
        }
    }
    catch (e)
    {
        console.log("Err:", e);
    }

    return controlNode;
}

// document.elementFromPoint() only returns the top-most (in the view heirarchy) element.  We want the bottom-most one (the most specific
// element).  This function gets the top-most element, hides it temporarily, then gets the next top-most element, and so on, restoring it
// all at the end, and returning an array of elements (with the top-most at the start and the bottom-most at the end).
//
// http://stackoverflow.com/a/27884653/1227119
//
function allElementsFromPoint(x, y) 
{
    var element, elements = [];
    var old_visibility = [];
    while (true) 
    {
        element = document.elementFromPoint(x, y);
        if (!element || element === document.documentElement) 
        {
            break;
        }
        elements.push(element);
        old_visibility.push(element.style.visibility);
        element.style.visibility = 'hidden'; // Temporarily hide the element (without changing the layout)
    }
    for (var k = 0; k < elements.length; k++) 
    {
        elements[k].style.visibility = old_visibility[k];
    }
    elements.reverse();
    return elements;
}

// Find the bottom-most (from the tree perspective) Synchro control from a point (you could think if this as the top-most Synchro control
// in terms of the view heirarchy, as it is in front of any containing controls).
//
function getSynchroControlFromPoint(x, y)
{
    var elements = allElementsFromPoint(x, y);

    var synchroControl = null;
    for (var i = 0; i < elements.length; i++)
    {
        if ($(elements[i]).is('[class*="synchro-"]'))
        {
            synchroControl = elements[i];
        }
    }

    return synchroControl;
}

// Use the mouse to hover over Synchro controls in the rendered view, clicking the desired control to select it in the code window.
//
function selectControl()
{
    // Disable mouse/pointer events for all of our controls (so we can click to select them without interacting with them)
    //
    $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', 'none');

    // Remove any current visual item selection
    //
    $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

    $('#synchro_container').click(function(event)
    {
        // If pointer-events are suppressed, we won't be able to find any Synchro controls...
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', '');

        var synchroControl = getSynchroControlFromPoint(event.clientX, event.clientY);
        console.log("Synchro control clicked:", synchroControl);

        var viewNode = getViewNodeFromUXControl(synchroControl);
        selectNode(viewNode);

        $('#synchro_container').off('click mousemove mouseout');
        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

        return false;
    });

    $('#synchro_container').mousemove(function(event)
    {
        // If pointer-events are suppressed, we won't be able to find any Synchro controls...
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', '');

        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

        var synchroControl = getSynchroControlFromPoint(event.clientX, event.clientY);
        if (synchroControl)
        {
            $(synchroControl).css("outline", selectedOutline);
            $(synchroControl).css("outline-offset", selectedOutlineOffset);
        }

        // Re-suppress pointer-events
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', 'none');

        return false;
    });

    $('#synchro_container').mouseout(function(event)
    {
        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');
        return false;
    });
}

function getViewNodeFromUXControl(synchroControl)
{
    var parents = $(synchroControl).parents('[class*="synchro-"]');
    var indexes = [$(synchroControl).index()];
    for (var i = 0; i < parents.length; i++)
    {
        indexes.push($(parents[i]).index());
    }
    // console.log("Indexes:", indexes);

    var viewNode = selectViewNodeFromIndexes(indexes);
    // console.log("View node:", viewNode);

    return viewNode;
}

function nodeContainsPos(node, point)
{
    var range = rangeFromLocation(node.loc);
    return range.contains(point.row, point.column);
}

function findControl(node, point, indexer)
{
    //console.log("Inspecting node of type:", node.type);

    var theIndexer = indexer || { indexes: [], currIndex: null };

    var qualifyingControl = null;
    var arrayToProcess = null;

    if (node.type === 'Program')
    {
        arrayToProcess = node.body;
    }
    else if (node.type === 'ExpressionStatement')
    {
        qualifyingControl = findControl(node.expression, point, theIndexer);
    }
    else if (node.type === 'AssignmentExpression')
    {
        // operator, left, right
        qualifyingControl = findControl(node.right, point, theIndexer);
    }
    else if (node.type === 'ObjectExpression')
    {
        for (var i = 0; i < node.properties.length; i++)
        {
            if ((node.properties[i].key.name === 'elements') && nodeContainsPos(node, point))
            {
                // If "elements" contains more than one control, then Synchro will wrap that control with a 
                // container (a vertical StackPanel).  We need to add an extra index (at 0) to accomodate that
                // "extra" control in the visual layout.
                // 
                if (node.properties[i].value.elements.length > 1)
                {
                    // console.log("Found 'elements' with multiple elements");
                    indexer.indexes.push(0);
                }
            }

            // console.log("Inspecting node property:", node.properties[i]);
            if ((node.properties[i].key.name === 'control') && nodeContainsPos(node, point))
            {
                // console.log("qualifying control at index:", indexer.currIndex);
                indexer.indexes.push(indexer.currIndex);
                qualifyingControl = node;
            }
        }
        arrayToProcess = node.properties;
    }
    else if (node.type === 'ArrayExpression')
    {
        arrayToProcess = node.elements;
    }
    else if (node.type === 'Property')
    {
        qualifyingControl = findControl(node.value, point, theIndexer); 
    }
    else if (node.type === 'Literal')
    {
        // node.value is value 
    }

    if (arrayToProcess)
    {
        for (var i = 0; i < arrayToProcess.length; i++)
        {
            theIndexer.currIndex = i;
            var result = findControl(arrayToProcess[i], point, theIndexer);
            if (result)
            {
                qualifyingControl = result;
                break;
            }
        }
    }

    if (qualifyingControl && (typeof indexer === 'undefined'))
    {
        // console.log("Final indexes:", theIndexer.indexes);
        qualifyingControl.indexes = theIndexer.indexes;
    }

    return qualifyingControl;
}

function findControlInModule(point)
{
    var options = 
    {
        loc: true,
        comment: true
    }

    try
    {
        var parsed = getParsedModule();
        return findControl(parsed, point)
    }
    catch (e)
    {
        // We don't really care about parsing errors (these happen a lot as we're editing code)
    }
}

function selectNode(node)
{
    var range = rangeFromLocation(node.loc);
    editor.selection.setSelectionRange(range, false);
}

function replaceNode(node, value)
{
    var range = rangeFromLocation(node.loc);
    editor.getSession().replace(range, value);
}

function removeNode(node)
{
    var range = rangeFromLocation(node.loc);

    // If the characters immediately following the node are ", " then we want to remove those as well...
    //
    var followRange = new Range(range.end.row, range.end.column, range.end.row, range.end.column + 2);
    if (", " === editor.getSession().getTextRange(followRange))
    {
        range.setEnd(range.end.row, range.end.column + 2);
    }

    editor.getSession().remove(range);
}

function getNodeProperty(node, property)
{
    if (node)
    {
        for (var i = 0; i < node.properties.length; i++)
        {
            var prop = node.properties[i];
            if (prop.key.name == property)
            {
                return prop;
            }
        }
    }
}

function getNodePropertyValue(node, property)
{
    var nodeProp = getNodeProperty(node, property);
    if (nodeProp)
    {
        return nodeProp.value.value;
    }
}

function selectVisualElementFromIndexes(visualElement, indexes)
{
    var indexesCopy = indexes.slice(0);
    var elem = $(visualElement).children('[class*="synchro-"]').get(indexesCopy.shift());
    if (indexesCopy.length)
    {
        return selectVisualElementFromIndexes(elem, indexesCopy);
    }
    else
    {
        return elem;
    }
}

// The control currently selected in the editor (meaning the cursor is located in the control, and the property inspector
// widgets are linked to that control).
//
var selectedControl; 

function clearPropertyInspectors()
{
    $('#control-widget-container').empty();
    $('#common-widget-container').empty();
    $('#control-widget-container-panel').hide();
    $('#common-widget-container-panel').hide();
}

function populatePropertyInspectorWidgets(divId, attributes)
{
    // For "select" (bool and others), this is maybe a better solution...
    //
    // https://github.com/indrimuska/jquery-editable-select
    //
    if (attributes && attributes.length)
    {
        for (var i = 0; i < attributes.length; i++)
        {
            $('#' + divId).append(
                "<div class='form-group'" +
                    "<label for='widget-" + attributes[i].attribute + "'>" + attributes[i].caption + ":</label>" + 
                    "<div class='input-group' id='widget-" +attributes[i].attribute + "-group'></div>" +
                "</div>"
            );

            if ((attributes[i].type === 'select') || (attributes[i].type === 'boolean'))
            {
                $('#widget-' + attributes[i].attribute + '-group').append(
                    "<select id='widget-" + attributes[i].attribute + "' type='text' class='form-control' oninput='propChange(this)'>"
                );

                if (attributes[i].type === 'select')
                {
                    for (var j = 0; j < attributes[i].values.length; j++)
                    {
                        $('#widget-' + attributes[i].attribute).append("<option>" + attributes[i].values[j] + "</option>");
                    }
                }
                else if (attributes[i].type === 'boolean')
                {
                    $('#widget-' + attributes[i].attribute).append("<option>true</option>");
                    $('#widget-' + attributes[i].attribute).append("<option>false</option>");
                }

                $('#widget-' + attributes[i].attribute).editableSelect({ filter: false });
            }
            else
            {
                $('#widget-' + attributes[i].attribute + '-group').append(
                    "<input id='widget-" + attributes[i].attribute + "' type='text' class='form-control' oninput='propChange(this)'>"
                );
            }

            $('#widget-' + attributes[i].attribute + '-group').append(
                "<span class='input-group-btn'>" + 
                   "<button id='widget-" + attributes[i].attribute + "-binding' class='btn btn-default' type='button' onclick='onBinding(this);'>{}</button>" + 
                "</span>"
            );

            $('#widget-' + attributes[i].attribute).val(getNodePropertyValue(controlNode, attributes[i].attribute));
        }
        $('#' + divId + '-panel').show();
    }
}

function onSelectionChange()
{
    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos);

    if (selectedControl != controlNode)
    {
        if (selectedControl)
        {
            // Remove existing property inspector widgets
            //
            console.log("Removing property inspector widgets");
            clearPropertyInspectors();

            // Turn off any visual element selection
            //
            $('#synchro_container').find('[class*="synchro-"]').css('outline', '');
        }

        if (controlNode)
        {
            // Create and populate property inspector widgets
            //
            var controlType = getNodePropertyValue(controlNode, 'control');

            console.log("Adding property inspector widgets for control of type:", controlType);

            var commonAttributes = controlMeta["*"].attributes;
            var controlAttributes = controlMeta[controlType] && controlMeta[controlType].attributes;

            $('#control-type').text(controlMeta[controlType].name);
            populatePropertyInspectorWidgets('control-widget-container', controlAttributes);
            populatePropertyInspectorWidgets('common-widget-container', commonAttributes);

            // Select the visual element that corresponds to the selected control node.
            //
            var elem = selectVisualElementFromIndexes($("#synchro_container"), controlNode.indexes);
            $(elem).css("outline", selectedOutline);
            $(elem).css("outline-offset", selectedOutlineOffset);
        }

        selectedControl = controlNode;
    }
}

function onEditorChange() 
{
    // Update property inspector widget values from currently selected control node (if any).
    //  
    console.log("Editor change");

    // Note: If we aren't in a control node, then we shouldn't have an property inspector widgets (so no need to clear values).
    //
    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos);
    if (controlNode)
    {
        var widgets = controlMeta["*"].attributes;
        widgets = widgets.concat(controlMeta[getNodePropertyValue(controlNode, 'control')].attributes);

        for (var i = 0; i < widgets.length; i++)
        {
            if (controlNode)
            {
                $('#widget_' + widgets[i].attribute).val(getNodePropertyValue(controlNode, widgets[i].attribute));
            }
        }
    }

    updateView();
}

// Called when property inspector widget receives input - updates editor content (selected control attributes) based on change
//
function propChange(control)
{
    var propName = $(control).attr("id").match(/^widget-(.*)$/)[1];

    // Value may have to be converted to string/quoted (depending on type).  We will attempt to do a JSON parse+stringify, which
    // will handle numbers, booleans, and null.  Any value that fails JSON.parse is assumed to be a string and gets quoted.
    //
    // !!! When we have more sophisticated controls (like a "select" for orientation, or a complex control for font attributes), 
    //     we're going to have to be smarter about converting those control values to "value" here.
    //
    var value = control.value != "" ? control.value : null;
    if (value)
    {
        try
        {
            value = JSON.stringify(JSON.parse(value));
        }
        catch (e)
        {
            value = '"' + value + '"';
        }
    }

    console.log("Property '%s' changed to: %s", propName, value);

    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos);

    if (controlNode)
    {
        console.log("Found control:", controlNode);
        var attributes = [];
        for (var i = 0; i < controlNode.properties.length; i++)
        {
            var prop = controlNode.properties[i];
            if (prop.key.name == propName)
            {
                ignoreSelChange = true;
                if (value)
                {
                    replaceNode(prop.value, value);
                }
                else
                {
                    removeNode(prop);
                }
                ignoreSelChange = false;
                updateView();
                return;
            }
            attributes.push(prop.key.name);
        }

        // We found the control node, but not the property.  We need to add it according to "attributeOrder".
        //
        var attributeIndex = attributeOrder.indexOf(propName);
        if (attributeIndex != -1)
        {
            console.log("attributeOrder index of property '%' is:", propName, attributeIndex);
            console.log("attributes of control:", attributes);

            for (var j = attributeIndex-1; j >= 0; j--)
            {
                var precedentIndex = attributes.indexOf(attributeOrder[j]);
                if (precedentIndex != -1)
                {
                    console.log("Found precedent attribute '%s' as attribute index: %d in control", attributeOrder[j], precedentIndex);

                    var precedentAttributeNode = controlNode.properties[precedentIndex];
                    console.log("Add property '%s' after precedent node:", propName, precedentAttributeNode);

                    // Add the attribute (propName) after the precedentAttributeNode (in the editor, based on the location of the
                    // precedentAttributeNode).  Consider that the precedentAttributeNode may or may not currently be the last attribute
                    // on the control node (so may or may not be followed by a comma).
                    //
                    ignoreSelChange = true;
                    editor.getSession().insert({row: precedentAttributeNode.loc.end.line-1, column: precedentAttributeNode.loc.end.column}, ", " + propName + ": " + value);
                    ignoreSelChange = false;
                    break;
                }
            }
        }
        else
        {
            // !!! propName attribute not found in attributeOrder array - add the property someplace reasonable (at the end, or right before
            //     "content" if "content" exists).
            //
            console.log("!!! Property '%' not found in attributeOrder array", propName);
        }

    }

    updateView();
}

function onBinding(control)
{
    // !!! Implement this...
    //
    var propName = $(control).attr("id").match(/^widget-(.*)-binding$/)[1];
    var control = $("#widget-" + propName);

    alert("Binding for: " + propName + ", value: " + control.val());
}

function onLoadModule(moduleName)
{
    console.log("Load modules:", moduleName);

    $.getJSON("module", { module: moduleName }, function(data)
    {
        // Process JSON response
        console.log("loadModule " + moduleName + ": " + JSON.stringify(data));
        editor.session.setValue(data.source);

        // Highlight the new active module...
        //
        $("div#modules a.active").removeClass("active");
        $("div#modules a[module='" + moduleName + "']").addClass("active");
     })
    .fail(function() 
    {
        alert( "loadModule error" );
    });

    return false; // To prevent default click behavior
}
