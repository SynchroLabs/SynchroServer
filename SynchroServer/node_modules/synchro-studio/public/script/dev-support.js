// Dev Support
//
// ACE: https://ace.c9.io/
//
Range = require("ace/range").Range;

// When we add attributes to a control node, we will add them in this order.  When adding a new attribute (one that is not
// present on the node), find the attribute in this list.  If found, navigate up the list until you find an attribute from
// the list that is present on the node, then insert the attribute being added after that attribue on the node.
//
var attributeOrder =
[
    "control",
    "height",
    "width",
    "color", // Border, Button, Rectangle, Text
    "background",
    "margin",
    "padding", // Border, StackPanel
    "visibility",
    "opacity",
    "enabled",
    "orientation", // ScrollView, StackPanel, WrapPanel
    "horizontalAlignment",
    "verticalAlignment",

    "caption", // Button
    "icon", // Button
    "resource", // Button, Image

    "font", // Edit, Password, Text

    "value", // Text, ProgressRing
    "binding",

    "border", // Border, Rectangle
    "borderThickness", // Border, Rectangle
    "cornerRadius", // Border, Rectangle

    "borderless", // Button

    "lines", // Edit
    "multiline", // Edit
    "placeholder", // Edit

    "ellipsize", // Text
    "textAlignment", // Text

    "url", // WebView

    "movementThreshold", // Location

    "minimum", // ProgressBar, Slider
    "maximum", // ProgressBar, Slider

    "scale", // Image

    "select", // ListBox, ListView

    "itemHeight", // WrapPanel
    "itemWidth", // WrapPanel

    "header", // ListView
    "itemTemplate", // ListView
    "footer", // ListView

    "contents" // Border, Canvas, ScrollView, StackPanel, WrapPanel (all containers), WebView (different meaning)
];

function onDocumentReady()
{
    // http://layout.jquery-dev.com/
    //
    $('body').layout(
    { 
        center__paneSelector: ".ui-layout-center",
        north__spacing_open: 0, // Makes non-sizable
        center__childOptions: {
            center__paneSelector: ".middle-center",
            north__paneSelector:  ".middle-north",
        },
        east__childOptions: {
            center__paneSelector: ".right-center",
            south__paneSelector:  ".right-south",
        }
    });

    var middleLayout = $("div.ui-layout-center").layout();
    middleLayout.sizePane("north", 300);

    initEditor();
}

var editor;
var ignoreSelChange = false;

function initEditor()
{
    editor = ace.edit("editor");
    editor.setTheme("ace/theme/monokai");
    editor.getSession().setMode("ace/mode/javascript");

    editor.getSession().on('change', function(e) 
    {
        console.log("Change content - type: %s, data: %s", e.type, JSON.stringify(e.data));
    });

    editor.getSession().selection.on('changeCursor', function(e) 
    {
        var pos = editor.selection.getCursor();
        console.log("Change cursor pos - row: %s, col: %s", pos.row, pos.column);
        if (!ignoreSelChange)
        {
            updateProperties();
        }
    });

    editor.getSession().selection.on('changeSelection', function(e) 
    {
        console.log("Change selection");
    });

    // on "focus" and "blur"
}

var renderView; // renderView(view, viewModel)

function SynchroInit(synchro)
{
    renderView = synchro.renderView;

    var synchroApp =
    {
        container: document.getElementById('synchro_container'), // required
        onSetPageTitle: function(title) // optional
        {
            console.log("Page title set:", title);
            document.getElementById('synchro_title').innerHTML = title;
        },
        logConfig: {}, // optional, developer setting
    }

    return synchroApp;
}

function updateView()
{
    try
    {
        var parsed = esprima.parse(editor.getValue(), { loc: true, comment: true });

        var view;
        var viewModel = {};

        var initViewModelRange;
        var designViewModelRange;

        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'View'))
                {
                    var node = exp.expression.right;
                    // console.log("Found View:", node);

                    var range = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);

                    // This is a little creepy.  The View defintion in a Synchro module is not required to be JSON encoded (it's a
                    // JavaScript object).  So, for example, keys do not need to be quoted, and there can even be code in the values
                    // being assigned (though we're not trying to support that).  For this reason, we need to parse the found View as
                    // a JavaScript object, not as JSON.  The only way to do that is with good old eval().
                    //
                    eval("view = " + editor.getSession().getTextRange(range));
                }

                // Look for a top-level "var designViewModel = {}"
                //
                if ((exp.type === 'VariableDeclaration') && (exp.declarations[0].id.name === 'designViewModel'))
                {
                    var node = exp.declarations[0].init;
                    //console.log("Found designViewModel:", JSON.stringify(node, null, 4));
                    designViewModelRange = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);
                }

                // Look for a top-level exports.InitializeViewModel function, and inside that, look for a "var viewModel = {}"
                //
                // Note: This will often fail to eval for real implementations as there may be variables or code in the viewModel object
                //       member values that can't be evaluated client-side at design time.  In these cases, the "designViewModel" should
                //       be used if design-time support is desired.
                //
                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'InitializeViewModel'))
                {
                    if ((exp.expression.right.type === 'FunctionExpression') && (exp.expression.right.body.type === 'BlockStatement'))
                    {
                        var body = exp.expression.right.body.body;
                        for (var j = 0; j < body.length; j++)
                        {
                            if ((body[j].type === 'VariableDeclaration') && (body[j].declarations[0].id.name === 'viewModel'))
                            {
                                var node = body[j].declarations[0].init;
                                //console.log("Found viewModel in fn:", JSON.stringify(node, null, 4));
                                initViewModelRange = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);
                            }
                        }
                    }
                }
            }
        }

        if (view)
        {
            // !!! Define Synchro.getResourceUrl() and maybe others so they eval correctly (and work) at design time?
            //
            if (designViewModelRange) // var designViewModel = {}
            {
                eval("viewModel = " + editor.getSession().getTextRange(designViewModelRange));
            }
            else if (initViewModelRange) // fall back to var viewModel = {} from exports.InitializeViewModel
            {
                // !!! try/catch - if parse fails - messageBox (probably requires runtime state - recommend using "designViewModel")
                //
                eval("viewModel = " + editor.getSession().getTextRange(initViewModelRange));
            }

            renderView(view, viewModel);
        }
    }
    catch (e)
    {
        console.log("Err:", e);
    }
}

function selectViewNodeFromIndexes(indexes)
{
    var controlNode;

    try
    {
        var parsed = esprima.parse(editor.getValue(), { loc: true, comment: true });

        if (parsed.type === 'Program')
        {
            for (var i = 0; i < parsed.body.length; i++)
            {
                var exp = parsed.body[i];

                if ((exp.type === 'ExpressionStatement') && 
                    (exp.expression.type === 'AssignmentExpression') && 
                    (exp.expression.left.type === 'MemberExpression') &&
                    (exp.expression.left.object.name === 'exports') &&
                    (exp.expression.left.property.name === 'View'))
                {
                    var viewNode = exp.expression.right;
                    if (viewNode.type === 'ObjectExpression')
                    {
                        for (var i = 0; i < viewNode.properties.length; i++)
                        {
                            if (viewNode.properties[i].key.name === 'elements')
                            {
                                controlNode = viewNode.properties[i].value;
                                break;
                            }
                        }
                    }

                    console.log("ControlNode:", JSON.stringify(controlNode, null, 4));

                    if (controlNode.elements.length > 1)
                    {
                        // If "elements" contains more than one control, then Synchro will wrap that control with a container (a vertical StackPanel).
                        // We want to remove that index operation from our indexes stack in that case.
                        // 
                        indexes.pop(); 
                    }

                    while (controlNode && indexes.length)
                    {
                        if (controlNode.type === 'ObjectExpression')
                        {
                            for (var j = 0; j < controlNode.properties.length; j++)
                            {
                                if ((controlNode.properties[j].key.name === 'contents') && (controlNode.properties[j].value.type === 'ArrayExpression'))
                                {
                                    console.log("Promoting 'contents' ArrayExpression");
                                    controlNode = controlNode.properties[j].value;
                                    break;
                                }
                            }
                        }

                        if (controlNode.type === 'ArrayExpression')
                        {
                            console.log("Getting ArrayExpression element:", indexes[indexes.length-1]);
                            controlNode = controlNode.elements[indexes.pop()];
                        }
                        else
                        {
                            console.log("Ended - controlNode.type:", controlNode.type);
                            controlNode = null;
                        }
                    }
                }
            }
        }
    }
    catch (e)
    {
        console.log("Err:", e);
    }

    return controlNode;
}


// document.elementFromPoint() only returns the top-most (in the view heirarchy) element.  We want the bottom-most one (the most specific
// element).  This function gets the top-most element, hides it temporarily, then gets the next top-most element, and so on, restoring it
// all at the end, and returning an array of elements (with the top-most at the top and the bottom-most at the end).
//
// http://stackoverflow.com/a/27884653/1227119
//
function allElementsFromPoint(x, y) 
{
    var element, elements = [];
    var old_visibility = [];
    while (true) 
    {
        element = document.elementFromPoint(x, y);
        if (!element || element === document.documentElement) 
        {
            break;
        }
        elements.push(element);
        old_visibility.push(element.style.visibility);
        element.style.visibility = 'hidden'; // Temporarily hide the element (without changing the layout)
    }
    for (var k = 0; k < elements.length; k++) 
    {
        elements[k].style.visibility = old_visibility[k];
    }
    elements.reverse();
    return elements;
}

function getSynchroControlFromPoint(x, y)
{
    var elements = allElementsFromPoint(x, y);

    var synchroControl = null;
    for (var i = 0; i < elements.length; i++)
    {
        if ($(elements[i]).is('[class*="synchro-"]'))
        {
            synchroControl = elements[i];
        }
    }

    return synchroControl;
}

function selectControl()
{
    // Disable mouse/pointer events for all of our controls (so we can click to select them without interacting with them)
    //
    $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', 'none');

    $('#synchro_container').click(function(event)
    {
        // If pointer-events are suppressed, we won't be able to find any Synchro controls...
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', '');

        var synchroControl = getSynchroControlFromPoint(event.clientX, event.clientY);
        console.log("Synchro control clicked:", synchroControl);

        var parents = $(synchroControl).parents('[class*="synchro-"]');
        console.log("Parents:", parents);

        var indexes = [$(synchroControl).index()];
        for (var i = 0; i < parents.length; i++)
        {
            indexes.push($(parents[i]).index());
        }

        console.log("Indexes:", indexes);

        var viewNode = selectViewNodeFromIndexes(indexes);
        console.log("View node:", viewNode);

        selectNode(viewNode);

        $('#synchro_container').off('click mousemove mouseout');
        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

        return false;
    });

    $('#synchro_container').mousemove(function(event)
    {
        // If pointer-events are suppressed, we won't be able to find any Synchro controls...
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', '');

        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');

        var synchroControl = getSynchroControlFromPoint(event.clientX, event.clientY);
        if (synchroControl)
        {
            $(synchroControl).css("outline", "1px dotted red");
        }

        // Re-suppress pointer-events
        //
        $('#synchro_container').find('[class*="synchro-"]').css('pointer-events', 'none');

        return false;
    });

    $('#synchro_container').mouseout(function(event)
    {
        $('#synchro_container').find('[class*="synchro-"]').css('outline', '');
        return false;
    });

}

function nodeContainsPos(node, row, col)
{
    return !((row < node.loc.start.line) ||
             (row > node.loc.end.line) ||
             ((row == node.loc.start.line) && (col < node.loc.start.column)) ||
             ((row == node.loc.end.line) && (col > node.loc.end.column)));
}

function findControl(node, row, col)
{
    //console.log("Inspecting node of type:", node.type);

    var qualifyingControl = null;
    var arrayToProcess = null;

    if (node.type === 'Program')
    {
        arrayToProcess = node.body;
    }
    else if (node.type === 'ExpressionStatement')
    {
        qualifyingControl = findControl(node.expression, row, col);
    }
    else if (node.type === 'AssignmentExpression')
    {
        // operator, left, right
        qualifyingControl = findControl(node.right, row, col);
    }
    else if (node.type === 'ObjectExpression')
    {
        for (var i = 0; i < node.properties.length; i++)
        {
            //console.log("Inspecting node property:", node.properties[i]);
            if ((node.properties[i].key.name === 'control') && nodeContainsPos(node, row, col))
            {
                //console.log("qualifying control");
                qualifyingControl = node;
            }
        }
        arrayToProcess = node.properties;
    }
    else if (node.type === 'ArrayExpression')
    {
        arrayToProcess = node.elements;
    }
    else if (node.type === 'Property')
    {
        qualifyingControl = findControl(node.value, row, col); 
    }
    else if (node.type === 'Literal')
    {
        // node.value is value 
    }

    if (arrayToProcess)
    {
        for (var i = 0; i < arrayToProcess.length; i++)
        {
            var result = findControl(arrayToProcess[i], row, col);
            if (result)
            {
                qualifyingControl = result;
                break;
            }
        }
    }

    return qualifyingControl;
}

function findControlInModule(row, col)
{
    var options = 
    {
        loc: true,
        comment: true
    }

    try
    {
        var parsed = esprima.parse(editor.getValue(), options);
        return findControl(parsed, row, col)
    }
    catch (e)
    {
        // We don't really care about parsing errors (these happen a lot as we're editing code)
    }
}

function selectNode(node)
{
    var range = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);
    editor.selection.setSelectionRange(range, false);
}

function replaceNode(node, value)
{
    var range = new Range(node.loc.start.line-1, node.loc.start.column, node.loc.end.line-1, node.loc.end.column);
    editor.getSession().replace(range, value);
}

function updateProperties()
{
    $('#height').val('');
    $('#width').val('');

    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos.row + 1, pos.col);

    if (controlNode)
    {
        console.log("Found control:", controlNode);
        for (var i = 0; i < controlNode.properties.length; i++)
        {
            var prop = controlNode.properties[i];
            if (prop.key.name == 'height')
            {
                $('#height').val(prop.value.value);
            }
            if (prop.key.name == 'width')
            {
                $('#width').val(prop.value.value);
            }
        }
    }
}

function selectControlText()
{
    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos.row + 1, pos.col);

    if (controlNode)
    {
        selectNode(controlNode);
    }
}

function propChange(control, propName)
{
    // !!! Value name have to be converted to string/quoted (depending on type).  We could try to parse as number, then bool, 
    //     and fall back to string (quoting literal, if not already quoted).  Maybe just use JSON.parse()?  Any cases of object
    //     or array, where we would not want to quote?
    //
    // !!! If value is empty what do we do?  Remove property?  Writing empty property is bad (causes parse failures, 
    //     obviously, among other things).
    //
    console.log("Property '%s' changed to: %s", propName, control.value);

    var pos = editor.selection.getCursor();
    controlNode = findControlInModule(pos.row + 1, pos.col);

    if (controlNode)
    {
        console.log("Found control:", controlNode);
        for (var i = 0; i < controlNode.properties.length; i++)
        {
            var prop = controlNode.properties[i];
            if (prop.key.name == propName)
            {
                ignoreSelChange = true;
                replaceNode(prop.value, control.value);
                ignoreSelChange = false;
                return;
            }
        }

        // !!! We found the control node, but not the property.  We need to add it according to "attributeOrder".
        //
    }
}

function onLoadModule(moduleName)
{
    console.log("Load modules:", moduleName);

    $.getJSON("module", { module: moduleName }, function(data)
    {
        // Process JSON response
        console.log("loadModule " + moduleName + ": " + JSON.stringify(data));
        editor.session.setValue(data.source);

        // Highlight the new active module...
        //
        $("div#modules a.active").removeClass("active");
        $("div#modules a[module='" + moduleName + "']").addClass("active");
     })
    .fail(function() 
    {
        alert( "loadModule error" );
    });

    return false; // To prevent default click behavior
}
