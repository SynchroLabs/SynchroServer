// Debugger API server (serves the debug API over websocket to web client).  This can be somewhat
// confusing, as this debugger API "server" itself is a client of the v8 debugger service (accessed
// via v8client, which uses v8protocol to talk to the v8 debugger on the debug port).
//
//    Browser->[websocket]->debug-server(this)->v8client->v8protocol over socket->v8 debugger
//
var WebSocket = require('faye-websocket');
var v8Client = require('./v8client');
var path = require('path');

var logger = require('log4js').getLogger("dbg-server");


// All paths passed to/from the debugger server use forward slash delimiters.  Convert to/from the platform-local
// path delimiters to the platform-local delimiters used by the debugging engine as necessary...
//
function toLocalPath(pathName)
{
    if (path.sep != '/')
    {
        // Replace forward slash with local platform seperator
        return pathName.replace(/[\/]/g, path.sep);
    }
    else
    {
        return pathName;
    }
}

function toPortablePath(pathName)
{
    if (path.sep != '/')
    {
        // Replace backslash with forward slash
        return pathName.replace(/[\\]/g, '/');
    }
    else
    {
        return pathName;
    }
}

function sendResponse(ws, responseObject)
{
    ws.send(JSON.stringify(responseObject));
}

// https://github.com/joyent/node/blob/master/lib/_debugger.js
//
// Specifically, review the debugger "interface" class Interface (lots of useful implementation details).
//

function DebugSession(ws, port)
{
    logger.info("Starting debugger client, connecting to port: " + port);

    this.client = new v8Client();
    this.client.connect(port);

    // !!! This can fail hard (like kill the server hard) if the connect fails (specifically with bad/zero port)
    this.client.reqVersion(function(err, version) {
       logger.debug("Remote debugger version: " + version);
    });

    this.client.watch("viewModel");

    this.client.on("ready", function() 
    {
        logger.debug("Got ready");
        sendResponse(ws, { event: "ready" });
        logger.debug("Found " + Object.keys(this.scripts).length + " scripts");
        for (var key in this.scripts)
        {
            logger.trace("Found script: " + this.scripts[key].name + " (" + this.scripts[key].lineCount + " lines)");
        }
    });

    // On the break you need to send back the breakpoint info, the stack frame (possibly frame summary only), and the
    // fully resolved "current" frame (frame 0), which will contain the arguments and values for the frame, as well as
    // the watches resolved in the context of that frame.
    //
    // The web client may elect to retrieve a specific frame, in which case that fully resolved frame should be returned:
    //     client.reqFrame(frameIndex, function(err, frame));
    //
    // The user may also elect to retrieve the source for a frame:
    //     client.reqSource(frameIndex, null, null, function(err, source));
    //

    this.client.on("break", function(response) 
    {
        var self = this;

        logger.debug("Got break at: " + response.body.script.name + " - line: " + response.body.sourceLine);
        var breakData = 
        {
            frameIndex: 0,
            scriptId: response.body.script.id,
            scriptName: toPortablePath(path.basename(response.body.script.name)),
            scriptPath: toPortablePath(response.body.script.name),
            lineCount: response.body.script.lineCount,
            sourceLine: response.body.sourceLine,
            sourceColumn: response.body.sourceColumn,
            frames: []
        }
        
        this.fullTrace(function (err, data)
        {
            logger.debug("Stacktrace contained " + data.frames.length + " frames");
            data.frames.forEach(function(frame) 
            {
                var frameData = 
                {
                    frameIndex: frame.index,
                    scriptId: frame.script.id,
                    scriptName: toPortablePath(path.basename(frame.script.name)),
                    scriptPath: toPortablePath(frame.script.name),
                    lineCount: frame.script.lineCount,
                    isNative: frame.script.isNative,
                    sourceLine: frame.line,
                    sourceColumn: frame.column,
                    funcName: (frame.func.name !== "") ? frame.func.name : frame.func.inferredName,
                    arguments: frame.arguments, // [] name, value.display
                    locals: frame.locals,       // [] name, value.display
                    watches: frame.watches      // [] id, watch, value
                }
                breakData.frames.push(frameData);
            });

            sendResponse(ws, { event: "break", breakPoint: breakData });
        });
    });

    this.client.on("end", function() 
    {
        logger.debug("Got end");
        sendResponse(ws, { event: "end" });
    });

    this.close = function(callback)
    {
        // !!! When we stop debugging, it might be nice to keep track of breakpoints, so that when we start debugging
        //     again we can restore them (any breakpoints we have currently set are going to be lost when we terminate
        //     the debugging session in "disconnect" below).
        //

        // The disconnect below will blow away any breakpoints and resume execution (if currently suspended), which
        // we need to do since we aren't going to be around to handle the breakpoints getting hit.
        var self = this;
        this.client.req({ command: "disconnect" }, function ()
        {
            self.client.end();
            if (callback)
            {
                callback();
            }
        });
    }
}

function processWebSocketMessage(ws, event, state)
{
    // !!! TODO:
    //
    //     setBreakpoint(s), clearBreakpoint(s), clearAllBreakpoints, listBreakpoints
    //
    //     watch, unwatch (value, index?)
    //
    //     getSource (for frame?)
    //
    //     On break: return break details (module, line), stack frames, locals (anything in scope?), watches
    //
    //         Frame contains arguments and locals (but they need to be looked up / mirrored)
    //
    //     View: Output, locals, call stack, watches
    //        -- For each frame in the call stack: ability to get source/position and locals
    //
    //     Maybe client.isRunning
    //
    //
    //   
    var requestObject = JSON.parse(event.data);
    logger.debug("Processing debug API command: " + requestObject.command);
    switch (requestObject.command)
    {
        case "connect":
        {
            state.debugSession = new DebugSession(ws, requestObject.port);
        }
        break;

        case "version":
        {
            state.debugSession.client.reqVersion(function(err, version) 
            {
                logger.debug("Remote debugger version: " + version);
                sendResponse(ws, { event: "version", version: version });
            });
        }
        break;

        case "continue":
        {
            state.debugSession.client.reqContinue(function() 
            {
                logger.debug("continued");
                sendResponse(ws, { event: "continued" });
            });
        }
        break;

        case "step":
        {
            // action: next, in, out
            state.debugSession.client.step(requestObject.action, 1, function() 
            {
                // You get another break after the step, so not clear you need any kind of onComplete 
                // response to the client command...
                //
                logger.debug("step completed");
                sendResponse(ws, { event: "stepped" });
            });
        }
        break;

        case "source":
        {
            // !!! Ideally, we should automatically (or maybe by param) get the breakpoints associated with the
            //     module and return those at the same time.
            //
            state.debugSession.client.reqSource(requestObject.frame, null, null, function(err, source) 
            {
                logger.debug("got source for frame " + requestObject.frame);
                if (requestObject.scriptPath)
                {
                    source.breakpoints = state.debugSession.client.listBreakpoints(toLocalPath(requestObject.scriptPath));
                }
                sendResponse(ws, { event: "source", context: requestObject.context, source: source });
            });
        }
        break;

        case "setbreakpoint":
        {
            state.debugSession.client.setBreakpoint(toLocalPath(requestObject.scriptName), requestObject.line, function(err, breakpoint) 
            {
                logger.debug("breakpoint set: " + JSON.stringify(breakpoint));
                breakpoint.scriptName = toPortablePath(breakpoint.scriptName);
                sendResponse(ws, { event: "breakpoint-set", breakpoint: breakpoint });
            });
        }
        break;

        case "clearbreakpoint":
        {
            state.debugSession.client.clearBreakpoint(toLocalPath(requestObject.scriptName), requestObject.line, function(err, breakpoint) 
            {
                logger.debug("breakpoint cleared: " + JSON.stringify(breakpoint));
                breakpoint.scriptName = toPortablePath(breakpoint.scriptName);
                sendResponse(ws, { event: "breakpoint-cleared", breakpoint: breakpoint });
            });
        }
        break;

        case "getbreakpoints":
        {
            logger.debug("getting breakpoints for script: " + requestObject.scriptName);
            var breakpoints = state.debugSession.client.listBreakpoints(toLocalPath(requestObject.scriptName));
            sendResponse(ws, { event: "breakpoints", scriptName: toPortablePath(requestObject.scriptName), breakpoints: breakpoints });
        }
        break;

        case "close":
        {
            state.debugSession.close(function() 
            {
                logger.debug("closed");
                sendResponse(ws, { event: "closed" });
                ws.end();
                state.debugSession = null;
            });
        }
        break;
    }
}

exports.processWebSocket = function(request, socket, body)
{
    var ws = new WebSocket(request, socket, body);
    logger.debug("Debug API initialized WebSocket");

    state = {};

    ws.on('message', function(event) 
    {
        logger.debug("Debug API got WebSocket message: " + event.data);
        processWebSocketMessage(ws, event, state);
    });

    ws.on('close', function(event) 
    {
        logger.debug('Debug API WebSocket close', event.code, event.reason);
        if (state.debugSession)
        {
            state.debugSession.close();
        }
        ws = null;
    });
}
