// Synchro Studio module
//
// http://justjs.com/posts/creating-reusable-express-modules-with-their-own-routes-views-and-static-assets
//
var logger = require('log4js').getLogger("synchro-studio");
var express = require('express');
var path = require('path');
var url = require('url');
var co = require('co');

var hbs = require('express-hbs');

var render = hbs.create().express3({
    partialsDir: __dirname + '/views/partials',
    layoutsDir: __dirname + '/views/layouts',
    defaultLayout: __dirname + '/views/layouts/default.hbs',
    contentHelperName: 'content'
});

var index = require('./routes/index');
var edit = require('./routes/edit');
var login = require('./routes/login');
var dev = require('./routes/dev');

var debugApi = require('./lib/ws-debug-server');

// Constructor
//
// Note: basePath is from SYNCHRO_STUDIO_PATH.  If that value is null, you won't have the edit/debug (sandbox) functionality
//       available from the main menu, or server from studio at all.  You might set this to null if you want the menu page for
//       sharing endppints/QR codes, and web app links (if present), without exposing the Synchro Sandbox edit/debug functionality.
//
//       webAppUrlPrefix is from APP_PATH_PREFIX.  If present, you will have "Web App" links that lead to the web client for each
//       endpoint / app.
//
var SynchroStudio = function(config, basePath, apiManager, webAppUrlPrefix)
{
	this.config = config;
	this.basePath = basePath;
	this.apiManager = apiManager;
	this.webAppUrlPrefix = webAppUrlPrefix;
};

SynchroStudio.prototype.getUrlPrefix = function()
{
	return this.basePath;
}

// Called before the Express router or any routes are added to the app.  This is a good time to add any
// static middleware.
//
SynchroStudio.prototype.addMiddleware = function(expressApp)
{
	if (this.basePath)
	{
		logger.debug("Adding static path from basePath: " + this.basePath);
		logger.debug("Static path is: " + path.join(__dirname, 'public'));
		expressApp.use(this.basePath, express.static(path.join(__dirname, 'public'), { maxAge: this.config.get('STATIC_CACHE_MAXAGE') }));
	}
	else
	{
		logger.debug("No studio basePath, middleware not added");
	}
}

SynchroStudio.prototype.addRoutes = function(expressApp, config, checkAuthFn)
{
	var self = this;

	var checkAuth = login.checkAuth; // Defaults to built-in check auth function

	if (checkAuthFn === false)
	{
		// false value means no auth...
		//
		checkAuth = function(req, res, next)
		{
			next();
		}
	}
	else if (checkAuthFn)
	{
		// Custom check auth function provided...
		//
		checkAuth = checkAuthFn;
	}

	expressApp.get('/', function(request, response) 
	{
	    // Asynchronously process the loaded apps and render the 'index' (app list) page
	    //
	    co(function * ()
	    {
	        var identity = 
	        {  
	            title: config.get('STUDIO_TITLE'),
	            subtitle: config.get('STUDIO_SUBTITLE')
	        };
	        var applications = [];

	        var apiProcessors = self.apiManager.getApiProcessors();
	        for (appPath in apiProcessors)
	        {
	            var appModuleStore = yield self.apiManager.getAppModuleStoreForPathAwaitable(appPath);
	            var studioPath = self.getUrlPrefix() ? (self.getUrlPrefix() + "/" + appPath + "/sandbox") : null;
	            var webAppPath = self.webAppUrlPrefix ? (self.webAppUrlPrefix + "/" + appPath) : null;

                // For Azure, need to check x-arr-ssl, since it terminates SSL for us
                var secure = request.protocol == "https" || request.secure || (request.get && request.get('x-arr-ssl')); 
	            var scheme = secure ? "https" : "http";

	            applications.push(
	            { 
	                appPath: appPath, 
	                studioPath: studioPath, 
	                endpoint: scheme + "://" + config.addNonStandardPort(request.host) + config.get("API_PATH_PREFIX") + "/" + appPath, 
	                appDefinition: yield appModuleStore.getAppDefinitionAwaitable(),
	                webAppPath: webAppPath
	            });
	        }

	        index.index(self, request, response, identity, applications);
	    }).catch(function(err)
        {
            logger.error("Error on app get for /:", err);
        });;
	});

	expressApp.all('/login', function(req, res, next)
	{
		login.login(self, req, res, next);
	});
	expressApp.get('/logout', function(req, res, next)
	{
		login.logout(self, req, res, next);
	});

	expressApp.all(this.basePath + '/:appName/dev', function(req, res, next)
	{
		co(dev.dev, self, req.params.appName, req, res).catch(function(err)
        {
            logger.error("Error in dev:", err);
        });
	});

	expressApp.get(this.basePath + '/:appName/sandbox', checkAuth, function(req,res)
	{
	    co(edit.edit, self, req.params.appName, req, res).catch(function(err)
        {
            logger.error("Error in edit.edit:", err);
        });
	});

	//
	// REST API for app modules (CRUD)
	//
	//    Create: POST
	//    Read:   GET
	//    Update: PUT
	//    Delete: DELETE
	//

	expressApp['post'](this.basePath + '/:appName/module', checkAuth, function(req,res)
	{
	    co(edit.createModule, self, req.params.appName, req, res).catch(function(err)
        {
            logger.error("Error in edit.load:", err);
        });
	});

	expressApp['get'](this.basePath + '/:appName/module', checkAuth, function(req,res)
	{
	    co(edit.loadModule, self, req.params.appName, req, res).catch(function(err)
        {
            logger.error("Error in edit.load:", err);
        });
	});

	expressApp['put'](this.basePath + '/:appName/module', checkAuth, function(req,res)
	{
	    co(edit.saveModule, self, req.params.appName, req, res).catch(function(err)
        {
            logger.error("Error in edit.save:", err);
        });
	});

	expressApp['delete'](this.basePath + '/:appName/module', checkAuth, function(req,res)
	{
	    co(edit.deleteModule, self, req.params.appName, req, res).catch(function(err)
        {
            logger.error("Error in edit.delete:", err);
        });
	});
}

SynchroStudio.prototype.onServerCreated = function(server)
{
	var self = this;

	server.on('upgrade', function(request, socket, body)
	{
	    // The WebSocket.isWebSocket() function was failing (on Azure only) because the Connection: Upgrade
	    // header sent by the client (confirmed by Fiddler) was getting modified by something in the Azure 
	    // environment such that it showed up at this point as Connection: Keep-alive.  So we will use this
	    // simplified logic to check for a websocket connect (and only a websocket should trigger "upgrade").
	    //
	    var upgrade = request.headers.upgrade || '';
	    if (request.method === 'GET' && upgrade.toLowerCase() === 'websocket')
	    {
	        var path = url.parse(request.url).pathname; 
	        if (path === self.getUrlPrefix())
	        {
	            // !!! Web session auth? (maybe inside websocket processor - to get/use session)
	            //
	            self.processWebSocket(request, socket, body);
	        }
	    }
	});	
}

SynchroStudio.prototype.getApiProcessorManager = function()
{
	return this.apiManager;
}

SynchroStudio.prototype.getApiProcessor = function(appName)
{
	return this.apiManager.getApiProcessor(appName);
}

SynchroStudio.prototype.getAppModuleStoreForPathAwaitable = function * (appName)
{
	return yield this.apiManager.getAppModuleStoreForPathAwaitable(appName);
}

SynchroStudio.prototype.render = function(templateName, locals, res)
{
	var dirname = path.join(__dirname, '/views');

	locals.settings = { views: dirname };

	render(path.join(dirname, templateName + '.hbs'), locals, function(err, html) 
	{
		if (err)
		{

		}
		else
		{
			res.send(html);
		}
    });
}

SynchroStudio.prototype.processWebSocket = function(request, socket, body)
{
    debugApi.processWebSocket(request, socket, body);
}

module.exports = SynchroStudio;
