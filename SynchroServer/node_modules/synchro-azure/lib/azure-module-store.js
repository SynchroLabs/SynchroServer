// This is the Azure cloud-based module store.  It works with modules stored in the specified Azure storage blob container.
//
// API Docs: http://dl.windowsazure.com/nodestoragedocs/BlobService.html
//
var path = require('path');
var azure = require('azure-storage');
var wait = require('wait.for');

var logger = require('log4js').getLogger("azure-module-store");

module.exports = function(params)
{
    var storageAccount = params.storageAccount;
    var storageAccessKey = params.storageAccessKey;

    var blobService = azure.createBlobService(storageAccount, storageAccessKey);

    function getContainerListAsync(callback)
    {
        var containers = [];

        function aggregateContainers(err, result, cb)
        {
            if (err)
            {
                cb(err);
            }
            else
            {
                for (var i = 0; i < result.entries.length; i++)
                {
                    containers.push(result.entries[i].name);
                }

                if (result.continuationToken !== null) 
                {
                    blobService.listContainersSegmented(result.continuationToken, aggregateContainers);
                }
                else 
                {
                    cb(null, containers);
                }
            }
        }

        blobService.listContainersSegmented(null, function(err, result) 
        {
            aggregateContainers(err, result, function(err, containers)
            {
                if (err) 
                {
                    callback(err);
                }
                else 
                {
                    callback(null, containers);
                }
            });
        });
    }

    function createAppContainerAsync(containerName, callback)
    {
        blobService.createContainerIfNotExists(containerName, function(error, result, response)
        {
            if (error)
            {
                callback(error);
            }
            else
            {
                if (result)
                {
                    // Container created
                    //
                    // Create a package.json blob with empty-ish JSON contents...
                    //
                    var packageJson = { engines: { "synchro": "* "} };
                    blobService.createBlockBlobFromText(containerName, "package.json", JSON.stringify(packageJson), function(error, result)
                    {
                        callback(error, true);
                    });
                }
                else
                {
                    // Container already existed
                    //
                    getAppDefinitionAsync(containerName, function(error, appDefinition)
                    {
                        if (error)
                        {
                            callback(error);
                        }

                        if (appDefinition)
                        {
                            if (isSynchroApp(appDefinition))
                            {
                                // A Synchro app already exists in this directory...
                                //
                                callback(new Error("A Synchro application already exists in the container: '" + containerName + "'"));
                            }
                            else
                            {
                                // A package.json was found, but not one for a Synchro app...
                                //
                                callback(new Error("The container: '" + containerName + "' is already in use by a Node package, but not by a Synchro application")); 
                            }
                        }
                        else
                        {
                            // The directory name is in use, but not by an existing Synchro app...
                            //
                            callback(new Error("The container: '" + containerName + "' is already in use, but not by a Synchro application"));
                        }
                    });
                }
            }
        });
    }

    function deleteContainerAsync(containerName, callback)
    {
        blobService.deleteContainer(containerName, function(error, response)
        {
            if (error)
            {
                callback(error);
            }
            else
            {
                callback(null, true);
            }
        });
    }

    function doesContainerExistAsync(containerName, callback)
    {
        blobService.doesContainerExist(containerName, function(error, result, response)
        {
            if (error)
            {
                callback(error);
            }
            else if (result)
            {
                callback(null, true);
            }
            else
            {
                callback(null, false);
            }
        });

    }

    function doesBlobExistAsync(containerName, blobName, callback)
    {
        blobService.doesBlobExist(containerName, blobName, function(error, result, response)
        {
            if (error)
            {
                callback(error);
            }
            else if (result)
            {
                callback(null, true);
            }
            else
            {
                callback(null, false);
            }
        });
    }

    function listBlobsAsync(containerName, callback)
    {
        // Note: Will only work for first page of blobs (currently 5,000)
        //
        blobService.listBlobsSegmented(containerName, null, function(err, blobs)
        {
            callback(err, blobs);
        });
    }

    function getBlobTextAsync(containerName, blobName, callback)
    {
        blobService.getBlobToText(containerName, blobName, function(err, text)
        {
            callback(err, text);
        });
    }

    function setBlobTextAsync(containerName, blobName, text, callback)
    {
        blobService.createBlockBlobFromText(containerName, blobName, text, function(err, result)
        {
            callback(err, result);
        });
    }

    function removeBlobAsync(containerName, blobName, callback)
    {
        blobService.deleteBlob(containerName, blobName, function(err, result)
        {
            callback(err, result);
        });
    }

    function stripBom(content)
    {
        // !!! OK - this needs to be looked at.  What I know is that when I upload local JS modules created with
        //     Visual Studio, those files have a UTF-16 BOM marker at the beginning (which makes sense, as they
        //     should be UTF-16, or more specifically, UCS-2, which is the UTF-16 subset supported by Javascript
        //     and the V8 engine - Note also: I have seen "ucs2" as an alias for "utf16le" in node code/docs).
        //
        //     At any rate, the UTF-16 BOM marker does not survive the round trip from the blob store to the ACE
        //     editor in the client, and back.  So we're going to remove it for now.  But really we need a clear
        //     understanding of all of the encoding issues (not the least of which is how the JS string we get from 
        //     the ACE editor is encoded, and how the encoding specified in the Azure blob relates to the blob 
        //     text getting serialized to/from the JS string).
        //
        if (content.charCodeAt(0) === 0xFEFF) 
        {
            content = content.slice(1);
        }
        return content;
    }

    function getAppDefinitionAsync(container, callback)
    {
        doesBlobExistAsync(container, "package.json", function(error, result)
        {
            if (error)
            {
                callback(error);
            }

            if (result)
            {
                getBlobTextAsync(container, "package.json", function(error, result)
                {
                    if (error)
                    {
                        callback(error);
                    }

                    callback(null, JSON.parse(result));
                });
            }
            else
            {
                callback(null, null);
            }
        });
    }

    function getAppDefinition(container)
    {
        return wait.for(getAppDefinitionAsync, container);
    }

    function isSynchroApp(appDefinition)
    {
        return !!(appDefinition && appDefinition.engines["synchro"]);
    }

    var moduleStore = 
    {
        getAppContainers: function()
        {
            var containers = wait.for(getContainerListAsync);
            var synchroAppContainers = [];
            for (var i = 0; i < containers.length; i++)
            {
                var appDefinition = getAppDefinition(containers[i]);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        synchroAppContainers.push(containers[i]);
                    }
                }
            }

            return synchroAppContainers;
        },

        createAppContainer: function(container)
        {
            return wait.for(createAppContainerAsync, container);
        },

        deleteAppContainer: function(container)
        {
            if (wait.for(doesContainerExistAsync, container))
            {
                var appDefinition = getAppDefinition(container);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        return wait.for(deleteContainerAsync, container);
                    }
                    else
                    {
                        // A package.json was found, but not one for a Synchro app...
                        //
                        throw new Error("The container: '" + container + "' is in use by a Node package, not by a Synchro application, so it can't be deleted");
                    }
                }
                else
                {
                    // The directory exists, but does not contain a Synchro app, so we can't delete it...
                    //
                    throw new Error("The container: '" + container + "' is in use, but not by a Synchro application, so it can't be deleted");
                }
            }
            else
            {
                // The container doesn't exist...
                //
                throw new Error("The container: '" + container + "' does not exist");
            }
        },

        getAppModuleStore: function(container)
        {
            // Verify that the container exists and contains an app...
            //
            if (wait.for(doesContainerExistAsync, container))
            {
                var appDefinition = getAppDefinition(container);
                if (!appDefinition || !isSynchroApp(appDefinition))
                {
                    // The directory exists, but does not contain a Synchro app...
                    //
                    throw new Error("The container: '" + container + "' is in use, but not by a Synchro application");
                }
            }
            else
            {
                // The container doesn't exist...
                //
                throw new Error("The container: '" + container + "' does not exist");
            }

            var app =
            {
                getAppDefinition: function()
                {
                    return getAppDefinition(container);
                },

                listModules: function()
                {
                    var modules = [];

                    var blobs = wait.for(listBlobsAsync, container);
                    for (var i = 0; i < blobs.entries.length; i++) 
                    {
                        var filename = blobs.entries[i].name;
                        if (filename.indexOf('node_modules/') != 0) // Exclude node_modules
                        {
                            if (path.extname(filename) === ".js") 
                            {
                                modules.push(filename);
                            }                            
                        }
                    }

                    return modules;
                },

                getModuleSource: function(moduleFilename)
                {
                    var content = wait.for(getBlobTextAsync, container, moduleFilename);
                    return stripBom(content);
                },

                putModuleSource: function(moduleFilename, content)
                {
                    return wait.for(setBlobTextAsync, container, moduleFilename, content);
                },

                removeModuleSource: function(moduleFilename)
                {
                    return wait.for(removeBlobAsync, container, moduleFilename, content);
                }
            }

            return app;
        }

    }

    return moduleStore;
}
