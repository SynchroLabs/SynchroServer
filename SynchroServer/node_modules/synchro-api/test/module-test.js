require('./test');

var assert = require("assert");
require("./assert-helper");

var path = require('path');
var net = require('net');
var nconf = require('nconf');

var synchroApiModule = require("../index");

var log4js = require('log4js');
var logger = require('log4js').getLogger("module-test");

// This is testing the functionality of the top level module APIs (in index.js of this module).

// Test fixture
exports.createService = function(serviceName, serviceConfiguration)
{
    var service;

    switch (serviceName)
    {
        case "TestService":
        {
        	service = 
        	{
        		name: "TestService",
        		config: serviceConfiguration
        	};
        }
        break;
    }

    return service;
}

describe("Synchro API module", function () 
{
	describe("Service creation", function () 
	{
		it("Should create test service from spec", function() 
		{
			var serviceSpec =
			{
				packageRequirePath: path.resolve(__dirname, 'module-test'),
				serviceName: "TestService",
				serviceConfiguration: { foo: "bar"}
			}

			var service = synchroApiModule.createServiceFromSpec(serviceSpec);
			assert.objectsEqual(service, { name: "TestService", config: { foo: "bar"} });
		});
	});

	describe("Processor Manager", function() 
	{
        var conf = new nconf.Provider();
        conf.defaults({
            "APP_ROOT_PATH": path.resolve(__dirname, '../'),
            "SESSIONSTORE_PACKAGE": path.resolve(__dirname, '../index'),
            "SESSIONSTORE_SERVICE": "MemorySessionStore",
            "SESSIONSTORE": {},
            "MODULESTORE_PACKAGE": path.resolve(__dirname, '../index'),
            "MODULESTORE_SERVICE": "FileModuleStore",
            "MODULESTORE": { directory: __dirname },
            "APP_RESOURCE_PREFIX": "test",
            "APPS":  
            {
                "inproc": 
                {
                    "container": "testapp",
                    "custom": "foo"
                },
                "forked":
                {
                    "container": "testapp",
                    "custom": "bar"
                },
                "inproc2": 
                {
                    "container": "testapp"
                },
                "forked2":
                {
                    "container": "testapp"
                },
            }
        });

		var apiProcessorManager = synchroApiModule.createApiProcessorManager(6969, conf);
		var inprocProcessor;
		var forkedProcessor;

		it("Should create API processor manager", function() 
		{
			assert.notEqual(apiProcessorManager, null);
		});

		it("Should create specified in-proc API processor", function(done)
		{
			apiProcessorManager.createApiProcessorAsync("inproc", false, false, function(err, apiProcessor)
			{
				inprocProcessor = apiProcessor;
				assert.equal(err, null);
				assert.notEqual(inprocProcessor, null);
				assert.equal(inprocProcessor.isForked, false);
				done();
			});
		});

		it("Should create specified forked API processor", function(done) 
		{
			apiProcessorManager.createApiProcessorAsync("forked", true, true, function(err, apiProcessor)
			{
				forkedProcessor = apiProcessor;
				assert.equal(err, null);
				assert.notEqual(forkedProcessor, null);
				assert.equal(forkedProcessor.isForked, true);
				done();
			});
		});

		it("Should fail to create API processor if one already exists at the specified path", function(done) 
		{
			apiProcessorManager.createApiProcessorAsync("inproc", false, false, function(err, apiProcessor)
			{
				assert.notEqual(err, null);
				assert.equal(apiProcessor, null);
				done();
			});
		});

		it("Should find proper API processor based on path", function()
		{
			assert.equal(apiProcessorManager.getApiProcessor("inproc"), inprocProcessor);
			assert.equal(apiProcessorManager.getApiProcessor("forked"), forkedProcessor);
		});

		it("Should fail to find API processor when none coorespond to path", function()
		{
			assert.equal(apiProcessorManager.getApiProcessor("foo"), null);
		});

		it("Should return all API processors", function()
		{
			var apiProcessors = apiProcessorManager.getApiProcessors();
			assert.equal(Object.keys(apiProcessors).length, 2);
			assert.equal(apiProcessors["inproc"], inprocProcessor);
			assert.equal(apiProcessors["forked"], forkedProcessor);
		});

		it("Should return module store for API processor", function * ()
		{
            var moduleStoreSpec =
            {
                packageRequirePath: conf.get('MODULESTORE_PACKAGE'),
                serviceName: conf.get('MODULESTORE_SERVICE'),
                serviceConfiguration: conf.get('MODULESTORE')
            }

            var inprocModuleStore = yield apiProcessorManager.getAppModuleStoreAwaitable("inproc2", "testapp", moduleStoreSpec);
            var forkedModuleStore = yield apiProcessorManager.getAppModuleStoreAwaitable("forked2", "testapp", moduleStoreSpec);
            
            assert.notEqual(inprocModuleStore, null);
            assert.notEqual(forkedModuleStore, null);
			assert.equal(yield apiProcessorManager.getAppModuleStoreForPathAwaitable("inproc2"), inprocModuleStore); 
			assert.equal(yield apiProcessorManager.getAppModuleStoreForPathAwaitable("forked2"), forkedModuleStore); 
		});

		it("Should get proper app definition from API processor", function(done)
		{
			var request = { headers: [], body: { Mode: "AppDefinition" } };
			var response = 
			{
				send: function(data)
				{
					var expectedAppDefinition = 
					{
						App:
						{
							"name": "synchro-test",
							"version": "0.0.0",
							"description": "Synchro API Test",
							"main": "launch",
							"author": "Bob Dickinson <bob@synchro.io> (http://synchro.io/)",
							"private": true,
							"engines": { "synchro": "*" }
						}
					};

					assert.objectsEqual(data, expectedAppDefinition);
					done();
				}
			};

			apiProcessorManager.processHttpRequest("inproc", request, response);
		});

		it("Should get sync error / restart when cliend pass session that server doesn't know about", function(done)
		{
			// This test has to go here, because the api-test module doesn't call through the HTTP request wrapper
			// logic, which is where the session mismatch / resync logic lives.
			//
			var request = { headers: {"synchro-api-session-id" : "bad-session-id" }, body: { Mode: "Page" } };
			var response = 
			{
				send: function(data)
				{
					var expectedError = 
					{
						"name": "SyncError",
						"message": "The client provided a session ID, but the server could not find a corresponding session - restart required",
					};

					// In addition to the SyncError above, we need to ensure that we get a new session ID and that we don't get
					// an InstanceId - which will cause the client to resync (as if running from new).
					//
					assert.notEqual(data.NewSessionId, null);
					assert.equal(data.InstanceId, null);
					assert.objectsEqual(data.Error, expectedError);
					done();
				}
			};

			apiProcessorManager.processHttpRequest("inproc", request, response);
		});

		it("Should route HTTP request to in-proc API processor", function(done)
		{
			var request = { headers: [], body: { Mode: "Page", Path: "counter" } };
			var response = 
			{
				send: function(data)
				{
					assert.notEqual(data, null);
					assert.equal(data.View.title, "Counter Page");
					assert.equal(data.ViewModel.count, 0);
					done();
				}
			};

			apiProcessorManager.processHttpRequest("inproc", request, response);
		});
        
		it("Should route HTTP request to forked API processor", function(done)
		{
			var request = { headers: [], body: { Mode: "Page", Path: "counter" } };
			var response = 
			{
				send: function(data)
				{
					assert.notEqual(data, null);
					assert.equal(data.View.title, "Counter Page");
					assert.equal(data.ViewModel.count, 0);
					done();
				}
			};

			apiProcessorManager.processHttpRequest("forked", request, response);
        });

        it("Should get custom app config in in-proc API processor", function (done)
        {
            var request = { headers: [], body: { Mode: "Page", Path: "counter" } };
            var response = 
            {
                send: function (data)
                {
                    assert.notEqual(data, null);
                    assert.equal(data.View.title, "Counter Page");
                    assert.equal(data.ViewModel.custom, "foo");
                    done();
                }
            };
            
            apiProcessorManager.processHttpRequest("inproc", request, response);
        });

        it("Should get custom app config in forked API processor", function (done)
        {
            var request = { headers: [], body: { Mode: "Page", Path: "counter" } };
            var response = 
            {
                send: function (data)
                {
                    assert.notEqual(data, null);
                    assert.equal(data.View.title, "Counter Page");
                    assert.equal(data.ViewModel.custom, "bar");
                    done();
                }
            };
            
            apiProcessorManager.processHttpRequest("forked", request, response);
        });
	});

    // mocha node_modules/synchro-api/test -g Fibers
    //
    // Note: These tests don't work in the context of the overall test suite (they have a port conflict).  They only run standalone.  I think
    //       the issue these were designed for is understood.  They pass with 5.4.1 using either Fibers or co.
    //
    //       If necessary, we could move these to their own test module.  For now, we'll just skip them.
    //
	describe.skip("Fibers bug", function() 
	{
		var conf = new nconf.Provider();
        conf.defaults({
            "APP_ROOT_PATH": path.resolve(__dirname, '../'),
            "SESSIONSTORE_PACKAGE": path.resolve(__dirname, '../index'),
            "SESSIONSTORE_SERVICE": "MemorySessionStore",
            "SESSIONSTORE": {},
            "MODULESTORE_PACKAGE": path.resolve(__dirname, '../index'),
            "MODULESTORE_SERVICE": "FileModuleStore",
            "MODULESTORE": { directory: __dirname },
            "APP_RESOURCE_PREFIX": "test",
            "APPS":  
            {
                "forked":
                {
                    "container": "testapp",
                    "custom": "bar"
                }
            },
	        'LOG4JS_CONFIG': 
		    { 
		        appenders:
		        [ 
		            { type: "console", layout: { type: "basic" } } 
		        ],
		        levels: 
		        {
		            '[all]': 'INFO'
		        }
		    },
            "CLIENT_VERSION": "1.0.0",
        });

		log4js.configure(conf.get('LOG4JS_CONFIG'));

		var apiProcessorManager = synchroApiModule.createApiProcessorManager(6969, conf);
		var forkedProcessor;

		// If we set this to false to run without debugger, crash doesn't happen
		//
		var runAsDebug = true;

        it("forked processor should be created", function (done)
        {
			apiProcessorManager.createApiProcessorAsync("forked", true, runAsDebug, function(err, apiProcessor)
			{
				forkedProcessor = apiProcessor;
				assert.equal(err, null);
				assert.notEqual(forkedProcessor, null);
				assert.equal(forkedProcessor.isForked, true);
				done();
			});
        });

        it("request should return ClientVersionError", function (done)
        {
            var request = { headers: [], body: { Mode: "Page", Path: "counter" } };
            var response = 
            {
                send: function (data)
                {
                    assert.notEqual(data, null);
                    assert.equal(data.Error.name, "ClientVersionError");
                    done();
                }
            };
            
            apiProcessorManager.processHttpRequest("forked", request, response);
        });

        it("follow on request should not timeout because child process died", function (done)
        {
            var request = { headers: [], body: { Mode: "Page", Path: "counter" } };
            var response = 
            {
                send: function (data)
                {
                    assert.notEqual(data, null);
                    assert.equal(data.Error.name, "ClientVersionError");
                    done();
                }
            };
            
            apiProcessorManager.processHttpRequest("forked", request, response);
        });
	});

	describe("Built-in Services", function() 
	{
		it("Should create file module store", function * () 
		{
			var service = synchroApiModule.createService("FileModuleStore", { directory: __dirname } );
			var appModuleStore = yield service.getAppModuleStoreAwaitable("testapp");
			var appDefinition = yield appModuleStore.getAppDefinitionAwaitable();
			assert.equal(appDefinition.name, "synchro-test");
		});

		it("Should create memory session store", function * () 
		{
			var service = synchroApiModule.createService("MemorySessionStore", { } );
			var sessionId = yield service.createSessionAwaitable();
			assert.notEqual(sessionId, null);
		});

		it("Should create resource resolver", function() 
		{
			var service = synchroApiModule.createService("ResourceResolver", { prefix: "test" } );
			assert.equal(service.getResourceUrl("foo"), "test/foo");
		});

		it("Should create file session store");
		it("Should create Redis session store");
	});
});
