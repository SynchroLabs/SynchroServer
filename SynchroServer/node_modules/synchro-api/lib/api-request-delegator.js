// API request delegator - return processor object to route API requests
//
// We have two modes of operation.  We can fork a child process, optionally putting it into debug mode on a specified
// port, or we can run the same handlers in-proc (useful for debugging the child code in the local debugger).
//
// Returned processor has the interface:
//
//     debugPort
//     processHttpRequest(request, response);
//     
var co = require('co');
var util = require('./util');

var log4js = require('log4js');
var logger = require('log4js').getLogger("api-request-delegator");

function createForkedRequestProcessorAsync(appPath, config, debugPort, onCreated)
{
    // This ref to the processor proxy is so we can call the http post processing in-proc
    var apiRequestProcessorProxy = require("./api-request-processor-proxy"); 

    var args = [appPath, JSON.stringify(config.get())]; // args passed to child process (will start at argv[2] in child process)
    var options = {};
    if (debugPort)
    {
        options['execArgv'] = ['--debug=' + debugPort];
    }
    options['silent'] = true;
            
    logger.debug("Launching child process...");

    var childProcess;
    try
    {
        childProcess = require('child_process').fork(__dirname + '/api-request-processor-proxy.js', args, options);
        if (!childProcess)
        {
            logger.error("Child process fork failed!");
            return null;
        }
        logger.debug("Child process launched, pid:", childProcess.pid);
    }
    catch (err)
    {
        logger.error("Error forking child process", err);
        throw err;
    }
    
    childProcess.on('close', function (code, signal)
    {
        logger.debug("Child process closed:", code);
    });
    
    childProcess.on('error', function (error)
    {
        logger.debug("Child process error:", error);
    });
    
    childProcess.on('exit', function (code, signal)
    {
        childProcess.exited = true;
        logger.debug("Child process exit:", code);
    });

    childProcess.on('disconnect', function ()
    {
        logger.debug("Child process disconnect");
    });

    // Supposedly when silent == false the child "inherits" the main process stdout/stderr, but in practice
    // I see no console/log output over stdout when I run that way.  Running with silent == true and piping
    // the child streams seems to work fine.
    //
    childProcess.stdout.pipe(process.stdout);
    
    //childProcess.stderr.pipe(process.stderr);
    childProcess.stderr.on('data', function (data)
    {
        if (/^debugger listening on port [0-9]*/i.test(data.toString()))
        {
            // When a process is launched with debugging on, someone thinks it's funny to shit out this message
            // directly to stderr.  So a) it's not a fucking error, and b) they don't even use the console IO
            // functions.  We're just going to swallow this here to keep it off of our console / log stream.
        }
        else
        {
            process.stderr.write(data);
        }
    });    

    // This mechanism is supposed to put the child process into debug mode, but doesn't seem to work.
    // This would be particularly useful if there was a way to talk to the child process debugger without
    // using a port (such as by using streams of some kind).
    //
    //     process._debugProcess(child.pid); // Error: The system cannot find the file specified.
    //

    function getRequestDataObject(request)
    {
        // The http "request" object is a giant sloppy pig full or ciruclar references, class getters that rely on other
        // complex members, and lots of redundancy and other madness.  We're going to create a data-only object that can
        // be passed over the wire (including via parent->child message) containing the basic request content.
        //
        var requestData = 
        {
            httpVersion: request.httpVersion,
            httpVersionMajor: request.httpVersionMajor,
            httpVersionMinor: request.httpVersionMinor,
            method: request.method,
            url: request.url,
            // We check request.get below before calling it because there are unit tests that send mock request objects
            // which don't implement get.
            secure: request.secure || (request.get && request.get('x-arr-ssl')), // For Azure, need to check x-arr-ssl, since it terminates SSL for us
            headers: request.headers,
            body: request.body
        }

        return requestData;
    }

    var requestId = 0;
    var pendingRequests = {};

    var reloadId = 0;
    var pendingReloads = {};

    function reloadModuleAsync(moduleName, cb)
    {
        var id = reloadId++;
        pendingReloads[id] = { onComplete: cb };
        childProcess.send({cmd: "reloadModule", id: id, moduleName: moduleName});
    }

    var requestProcessor =
    {
        sessionStoreSpec:
        {
            packageRequirePath: config.get('SESSIONSTORE_PACKAGE'),
            serviceName: config.get('SESSIONSTORE_SERVICE'),
            serviceConfiguration: config.get('SESSIONSTORE')
        },
        moduleStoreSpec:
        {
            packageRequirePath: config.get('MODULESTORE_PACKAGE'),
            serviceName: config.get('MODULESTORE_SERVICE'),
            serviceConfiguration: config.get('MODULESTORE')
        },   
        appContainer:  config.get('APPS')[appPath].container,
        isForked: true,
        isDebug: debugPort > 0,
        debugPort: debugPort,

        processHttpRequest : function(request, response)
        {
            logger.debug("Process forked child http request");

            // Record the request/response in pendingRequests, then post a message to the child process with the request
            //
            var id = requestId++;
            pendingRequests[id] = { request: request, response: response };
            childProcess.send({cmd: "processHttpRequest", id: id, request: getRequestDataObject(request)});
        },

        reloadModuleAwaitable: function * (moduleName)
        {
            logger.debug("Notify child process to reload module: " + moduleName);
            return yield function(done){reloadModuleAsync(moduleName, done)}
        },

        isShutdown: function()
        {
            return childProcess.exited;
        }
    }
    
    // Listen for messages back from the child process indicating request processing complete
    //
    childProcess.on('message', function(message) 
    {
        switch (message.type)
        {
            case "status":
            {
                if (message.status == "Started")
                {
                    logger.debug("Got started message from child process: " + JSON.stringify(message));
                    // Child process has signalled that it's ready to go
                    onCreated(null, requestProcessor);
                }
            }
            break;

            case "httpRequest":
            {
                // Look up the pending request info bound to this id, call the child module to process it, and remove the pending request
                //
                logger.debug("Processing pending request id: " + message.id);
                var pendingRequest = pendingRequests[message.id];
                delete pendingRequests[message.id];
                apiRequestProcessorProxy.postProcessHttpRequest(pendingRequest.request, pendingRequest.response, message.err, message.data);
            }
            break;

            case "reloadModule":
            {
                logger.debug("Processing pending reload id: " + message.id);
                var pendingReload = pendingReloads[message.id];
                delete pendingReloads[message.id];
                logger.debug("Pending reload message: ", message);
                pendingReload.onComplete(null, message.result);
            }
        }
    });
}

function * createInProcRequestProcessorAsyncAwaitable(appPath, config, onCreated)
{
    try
    {
        var apiRequestProcessorModule = require("./api-request-processor");
        var apiRequestProcessor = yield apiRequestProcessorModule.createApiRequestProcessorAsyncAwaitable(appPath, config);

        var requestProcessor =
        {
            sessionStoreSpec:
            {
                packageRequirePath: config.get('SESSIONSTORE_PACKAGE'),
                serviceName: config.get('SESSIONSTORE_SERVICE'),
                serviceConfiguration: config.get('SESSIONSTORE')
            },
            moduleStoreSpec:
             {
                packageRequirePath: config.get('MODULESTORE_PACKAGE'),
                serviceName: config.get('MODULESTORE_SERVICE'),
                serviceConfiguration: config.get('MODULESTORE')
            },   
            appContainer: config.get('APPS')[appPath].container,
            isForked: false,
            isDebug: false,
            debugPort: 0,

            processHttpRequest : function(request, response)
            {
                logger.info("Process in-proc child http request");
                apiRequestProcessor.processHttpRequest(request, function(err, data)
                {
                    apiRequestProcessorModule.postProcessHttpRequest(request, response, err, data);
                });
            },

            reloadModuleAwaitable: function * (moduleName)
            {
                return yield apiRequestProcessor.reloadModuleAwaitable(moduleName);
            },

            isShutdown: function ()
            {
                return true; // NOOP
            }
        }
        onCreated(null, requestProcessor);
    }
    catch (err)
    {
        onCreated(err);
    }
}

module.exports = function(appPath, config, fork, debugPort, onCreated)
{
    if (fork)
    {
        createForkedRequestProcessorAsync(appPath, config, debugPort, onCreated);
    }
    else
    {
        co(createInProcRequestProcessorAsyncAwaitable, appPath, config, onCreated).catch(function(err)
        {
            logger.error("Error creating in proc request processor:", err);
        });
    }
}