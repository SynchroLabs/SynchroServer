// API request delegator - return processor object to route API requests
//
// We have two modes of operation.  We can fork a child process, optionally putting it into debug mode on a specified
// port, or we can run the same handlers in-proc (useful for debugging the child code in the local debugger).
//
// Returned processor has the interface:
//
//     debugPort
//     processHttpRequest(request, response);
//     
var co = require('co');
var util = require('./util');

var log4js = require('log4js');
var logger = require('log4js').getLogger("api-request-delegator");

function createForkedRequestProcessorAsync(appPath, config, debugPort, onCreated)
{
    // This ref to the processor proxy is so we can call the http post processing in-proc
    var apiRequestProcessorProxy = require("./api-request-processor-proxy"); 

    var args = [appPath, JSON.stringify(config.get())]; // args passed to child process (will start at argv[2] in child process)
    var options = {};
    if (debugPort)
    {
        options['execArgv'] = ['--debug=' + debugPort];
    }
    options['silent'] = true;
            
    logger.debug("Launching child process...");

    var childProcess;
    try
    {
        childProcess = require('child_process').fork(__dirname + '/api-request-processor-proxy.js', args, options);
        if (!childProcess)
        {
            logger.error("Child process fork failed!");
            return null;
        }
        logger.debug("Child process launched, pid:", childProcess.pid);
    }
    catch (err)
    {
        logger.error("Error forking child process", err);
        throw err;
    }
    
    childProcess.on('close', function (code, signal)
    {
        logger.debug("Child process closed:", code);
    });
    
    childProcess.on('error', function (error)
    {
        logger.debug("Child process error:", error);
    });
    
    childProcess.on('exit', function (code, signal)
    {
        childProcess.exited = true;
        logger.debug("Child process exit:", code);
    });

    childProcess.on('disconnect', function ()
    {
        logger.debug("Child process disconnect");
    });

    // Supposedly when silent == false the child "inherits" the main process stdout/stderr, but in practice
    // I see no console/log output over stdout when I run that way.  Running with silent == true and piping
    // the child streams seems to work fine.
    //
    childProcess.stdout.pipe(process.stdout);
    
    //childProcess.stderr.pipe(process.stderr);
    childProcess.stderr.on('data', function (data)
    {
        if (/^debugger listening on port [0-9]*/i.test(data.toString()))
        {
            // When a process is launched with debugging on, someone thinks it's funny to shit out this message
            // directly to stderr.  So a) it's not a fucking error, and b) they don't even use the console IO
            // functions.  We're just going to swallow this here to keep it off of our console / log stream.
        }
        else
        {
            process.stderr.write(data);
        }
    });    

    // This mechanism is supposed to put the child process into debug mode, but doesn't seem to work.
    // This would be particularly useful if there was a way to talk to the child process debugger without
    // using a port (such as by using streams of some kind).
    //
    //     process._debugProcess(child.pid); // Error: The system cannot find the file specified.
    //

    function getRequestDataObject(request)
    {
        // The http "request" object is a giant sloppy pig full or ciruclar references, class getters that rely on other
        // complex members, and lots of redundancy and other madness.  We're going to create a data-only object that can
        // be passed over the wire (including via parent->child message) containing the basic request content.
        //
        var requestData = 
        {
            httpVersion: request.httpVersion,
            httpVersionMajor: request.httpVersionMajor,
            httpVersionMinor: request.httpVersionMinor,
            method: request.method,
            url: request.url,
            // We check request.get below before calling it because there are unit tests that send mock request objects
            // which don't implement get.
            secure: request.secure || (request.get && request.get('x-arr-ssl')), // For Azure, need to check x-arr-ssl, since it terminates SSL for us
            headers: request.headers,
            body: request.body
        }

        return requestData;
    }

    function createAsyncOperationManager(defaultTimeout)
    {
        var operationId = 0;
        var operationList = {};

        function operationTimeout(id)
        {
            var operation = operationList[id];
            delete operationList[id];

            var err = new Error("The operation timed out");
            if (operation.callback)
            {
                operation.callback(err);
            }
            else
            {
                logger.error(err);
            }
        }

        var asyncOpManager =
        {
            startOperation : function(callback, data, timeout) // Returns id to be used when calling operationComplete
            {
                var id = operationId++;
                logger.debug("Operation started, id:", id);

                var operation = { callback: callback, data: data };

                timeout = timeout || defaultTimeout;
                if (timeout)
                {
                    operation.timer = setTimeout(function(){operationTimeout(id)}, timeout);
                }
                operationList[id] = operation;

                logger.debug("Operations pending after started:", Object.keys(operationList));

                return id;
            },

            operationComplete: function(id) // Returns object with callback and data
            {
                logger.debug("Operation complete, id:", id);

                var operation = operationList[id];
                if (operation)
                {
                    if (operation.timer)
                    {
                        clearTimeout(operation.timer);
                        delete operation.timer;
                    }
                    delete operationList[id];
                }

                logger.debug("Operations pending after complete:", Object.keys(operationList));

                // Note: If operation has timed out, or operationComplete has already been called for this id, 
                //       the value returned here will be undefined.
                //
                return operation;
            }
        }

        return asyncOpManager;
    }

    var asyncOpsManager = createAsyncOperationManager(30000);

    var requestProcessor =
    {
        appContainer:  config.get('APPS')[appPath].container,
        isForked: true,
        isDebug: debugPort > 0,
        debugPort: debugPort,

        processHttpRequest : function(request, response)
        {
            logger.info("Process forked child http request");

            function onProcessRequestTimeout(err)
            {
                logger.error("Process request timed out");

                // This is not a "the server was busy" kind of timeout.  This is a 30 second timeout on what should be a < 50ms
                // operation at most.  It is highly likely that the request processor has died or hung if we get here, which is
                // why a "408 Request Timeout" status is probably not appropriate.
                //
                response.status(500).send({ 'Error': { 'name': 'ProcessorTimeout', 'message': 'Timed out waiting for processor to respond' } });
            }

            var processRequestData = { request: request, response: response };
            var id = asyncOpsManager.startOperation(onProcessRequestTimeout, processRequestData);
            childProcess.send({cmd: "processHttpRequest", id: id, request: getRequestDataObject(request)});
        },

        reloadModuleAwaitable: function * (moduleName)
        {
            logger.debug("Notify child process to reload module: " + moduleName);
            return yield function(done)
            {
                var id = asyncOpsManager.startOperation(done);
                childProcess.send({cmd: "reloadModule", id: id, moduleName: moduleName});
            }
        },

        healthCheck: function * (timeout)
        {
            logger.debug("Request health check from child process");
            return yield function(done)
            {
                var id = asyncOpsManager.startOperation(done, null, timeout);
                childProcess.send({cmd: "healthCheck", id: id});
            }
        },

        shutdown: function()
        {
            if (!childProcess.exited)
            {
                childProcess.kill();
            }
        },

        isShutdown: function()
        {
            return childProcess.exited;
        }
    }
    
    // Listen for messages back from the child process indicating request processing complete
    //
    childProcess.on('message', function(message) 
    {
        switch (message.type)
        {
            case "status":
            {
                if (message.status == "Started")
                {
                    logger.debug("Got started message from child process: " + JSON.stringify(message));
                    // Child process has signalled that it's ready to go
                    onCreated(null, requestProcessor);
                }
            }
            break;

            case "httpRequest":
            {
                // Look up the pending request info bound to this id, call the child module to process it, and remove the pending request
                //
                logger.debug("Processing pending request id: " + message.id);

                var pendingRequest = asyncOpsManager.operationComplete(message.id);
                apiRequestProcessorProxy.postProcessHttpRequest(pendingRequest.data.request, pendingRequest.data.response, message.err, message.data);
            }
            break;

            case "reloadModule":
            {
                logger.debug("Processing pending reload id: " + message.id);
                logger.debug("Pending reload message: ", message);
                var pendingReload = asyncOpsManager.operationComplete(message.id);
                pendingReload.callback(null, message.result);
            }
            break;

            case "health":
            {
                logger.debug("Processing health check id: " + message.id);
                var healthCheck = asyncOpsManager.operationComplete(message.id);
                healthCheck.callback(null, message.result);
            }
        }
    });
}

function * createInProcRequestProcessorAsyncAwaitable(appPath, config)
{
    var apiRequestProcessorModule = require("./api-request-processor");
    var apiRequestProcessor = yield apiRequestProcessorModule.createApiRequestProcessorAsyncAwaitable(appPath, config);

    var requestProcessor =
    {  
        appContainer: config.get('APPS')[appPath].container,
        isForked: false,
        isDebug: false,
        debugPort: 0,

        processHttpRequest : function(request, response)
        {
            logger.info("Process in-proc child http request");
            apiRequestProcessor.processHttpRequest(request, function(err, data)
            {
                apiRequestProcessorModule.postProcessHttpRequest(request, response, err, data);
            });
        },

        reloadModuleAwaitable: function * (moduleName)
        {
            return yield apiRequestProcessor.reloadModuleAwaitable(moduleName);
        },

        healthCheck: function * (timout)
        {
            return yield apiRequestProcessor.healthCheck();
        },

        shutdown: function()
        {
            // !!! Is there something we should do here to clean up?  Loaded modules?
        },

        isShutdown: function ()
        {
            return true; // NOOP
        }
    }
    return requestProcessor;
}

module.exports = function * (appPath, config, fork, debugPort, onCreated)
{
    if (fork)
    {
        return yield function(done)
        {
            createForkedRequestProcessorAsync(appPath, config, debugPort, done);
        }
    }
    else
    {
        return yield createInProcRequestProcessorAsyncAwaitable(appPath, config);
    }
}