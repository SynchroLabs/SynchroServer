// This is the Stashbox module store. 
//
var path = require('path');
var lodash = require('lodash');
var request = require('request');
var co = require('co');
var util = require('./util');

var logger = require('log4js').getLogger("stashbox-module-store");

module.exports = function(params)
{
    var location = params.location;
    var configRoot = params.configRoot || "/";

    logger.info("Using StashBox module store, location:", location); // debug

    function joinPath(basePath, relPath)
    {
        basePath = basePath.replace(/[\/]$/, '');
        relPath = relPath.replace(/^[\/]/, '');
        return basePath + '/' + relPath;
    }

    // param - for HEAD/GET it is "allowNotFound", for PUT it is body
    //
    function * makeRequestAwaitable(method, relPath, param)
    {
        var allowNotFound = (typeof param === 'boolean') ? param : false;
        var body = (method === "PUT") ? param : null;

        var response = yield function(done) 
        {
            var uri = joinPath(location, relPath);
            logger.info("location: %s, relPath: %s, uri: %s", location, relPath, uri);

            var options = { method: method, uri: uri, body: body };
            logger.info("Making request:", options);
            request(options, function (err, response, body)
            {
                if (!err && (response.statusCode !== 200) && !(allowNotFound && (response.statusCode === 404)))
                {
                    // Logical/protocol/service error
                    //
                    err = new Error(response.statusMessage);
                    err.statusCode = response.statusCode;
                }

                done(err, response);
            });
        }

        return response;
    }

    function addFilesToList(list, parentPath, files)
    {
        for (var i = 0; i < files.length; i++)
        {
            if (files[i].type === "file")
            {
                list.push({ name: parentPath + files[i].name});
            }
            else
            {
                addFilesToList(list, parentPath + files[i].name + "/", files[i].objects);
            }
        }
    }

    //
    // Containers
    //

    function * getContainersAwaitable()
    {
        logger.info("getContainersAwaitable()");

        var response = yield makeRequestAwaitable("GET", "");
        var jsonResponse = JSON.parse(response.body);

        var containers = [];
        for (var i = 0; i < jsonResponse.length; i++)
        {
            if (jsonResponse[i].type === "directory")
            {
                containers.push({ name: jsonResponse[i].name });
            }
        }

        logger.info("getContainersAwaitable:", containers);

        return containers;
    }

    function * doesContainerExistAwaitable(containerName)
    {
        logger.info("doesContainerExistAwaitable('%s')", containerName);

        var response = yield makeRequestAwaitable("HEAD", containerName, true);
        return response.statusCode === 200;
    }

    function * destroyContainerAwaitable(containerName)
    {
        logger.info("destroyContainerAwaitable('%s')", containerName);

        yield makeRequestAwaitable("DELETE", containerName);
    }

    //
    // Blobs
    //

    function * getBlobsAwaitable(containerName)
    {
        logger.info("getBlobsAwaitable('%s')", containerName);

        var response =  yield makeRequestAwaitable("GET", containerName);
        var jsonResponse = JSON.parse(response.body);
        logger.info("getBlobsAwaitable:", jsonResponse);

        var files = [];
        addFilesToList(files, "", jsonResponse);

        logger.info("getBlobsAwaitable - Files:", files);

        return files;
    }

    function * doesBlobExistAwaitable(containerName, blobName)
    {
        logger.info("doesBlobExistAwaitable('%s', '%s')", containerName, blobName);

        var response = yield makeRequestAwaitable("HEAD", path.join(containerName, blobName), true);
        return response.statusCode === 200;
    }

    function * getBlobTextAwaitable(containerName, blobName)
    {
        logger.info("getBlobTextAwaitable('%s', '%s')", containerName, blobName);
        var response =  yield makeRequestAwaitable("GET", path.join(containerName, blobName));
        return response.body;
    }

    function * setBlobTextAwaitable(containerName, blobName, text)
    {
        logger.info("setBlobTextAwaitable('%s', '%s')", containerName, blobName);
        yield makeRequestAwaitable("PUT", path.join(containerName, blobName), text);
    }

    function * removeBlobAwaitable(containerName, blobName)
    {
        logger.info("removeBlobTextAwaitable('%s', '%s')", containerName, blobName);
        yield makeRequestAwaitable("DELETE", path.join(containerName, blobName));
    }

//
// -------------------------------------------------------------------------------------------------
//

    function * getAppDefinitionAwaitable(containerName)
    {
        if (containerName)
        {
            if (yield doesBlobExistAwaitable(containerName, "package.json"))
            {
                logger.debug("Downloading package.json");
                var content = yield getBlobTextAwaitable(containerName, "package.json");
                return JSON.parse(content);
            }
            else
            {
                // Defined behavior is return null if no appDefinition...
                return null;
            }
        }
        else
        {
            logger.error("getAppDefinition failed - no container provided");
            return null;
        }
    }

    function isSynchroApp(appDefinition)
    {
        return !!(appDefinition && appDefinition.engines["synchro"]);
    }

    var moduleStore = 
    {
        getStoreFileAwaitable: function * (filename)
        {
            return yield getBlobTextAwaitable(configRoot, filename);
        },

        putStoreFileAwaitable: function * (filename, content)
        {
            yield setBlobTextAwaitable(configRoot, filename, content);
        },

        getAppContainersAwaitable: function * ()
        {
            // Get all containers/directories that contain a package.json file which itself indicates it is for a Synchro app...
            //
            var containers = yield getContainersAwaitable();

            var synchroAppContainers = [];
            for (var i = 0; i < containers.length; i++)
            {
                var appDefinition = yield getAppDefinitionAwaitable(containers[i].name);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        synchroAppContainers.push(containers[i].name);
                    }
                }
            }

            return synchroAppContainers;
        },

        createAppContainerAwaitable: function * (containerName)
        {
            if (yield doesContainerExistAwaitable(containerName))
            {
                // Container already existed
                //
                var appDefinition = yield getAppDefinitionAwaitable(containerName);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        // A Synchro app already exists in this directory...
                        //
                        throw new Error("A Synchro application already exists in the container: '" + containerName + "'");
                    }
                    else
                    {
                        // A package.json was found, but not one for a Synchro app...
                        //
                        throw new Error("The container: '" + containerName + "' is already in use by a Node package, but not by a Synchro application"); 
                    }
                }
                else
                {
                    // The directory name is in use, but not by an existing Synchro app...
                    //
                    throw new Error("The container: '" + containerName + "' is already in use, but not by a Synchro application");
                }
            }
            else
            {
                // Create container
                //
                logger.debug("Creating container:", containerName);

                // Create a package.json blob with empty-ish JSON contents...
                //
                // Note: Setting the package.json blob contents will create file and the parent directory (container)
                //
                var packageJson = { engines: { "synchro": "*"} };
                yield setBlobTextAwaitable(containerName, "package.json", JSON.stringify(packageJson));
            }
        },

        deleteAppContainerAwaitable: function * (containerName)
        {
            if (yield doesContainerExistAwaitable(containerName))
            {
                var appDefinition = yield getAppDefinitionAwaitable(containerName);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        // A Synchro app exists in this container, so we can delete it...
                        //
                        yield destroyContainerAwaitable(containerName);
                    }
                    else
                    {
                        // A package.json was found, but not one for a Synchro app...
                        //
                        throw new Error("The container: '" + containerName + "' is in use by a Node package, not by a Synchro application, so it can't be deleted");
                    }
                }
                else
                {
                    // The directory exists, but does not contain a Synchro app, so we can't delete it...
                    //
                    throw new Error("The container: '" + containerName + "' is in use, but not by a Synchro application, so it can't be deleted");
                }
            }
            else
            {
                // The container doesn't exist...
                //
                throw new Error("The container: '" + containerName + "' does not exist");
            }
        },

        getAppModuleStoreAwaitable: function * (containerName)
        {
            var containerName = containerName;

            if (yield doesContainerExistAwaitable(containerName))
            {
                var appDefinition = yield getAppDefinitionAwaitable(containerName);
                if (!appDefinition || !isSynchroApp(appDefinition))
                {
                    // The directory exists, but does not contain a Synchro app...
                    //
                    throw new Error("The container: '" + containerName + "' is in use, but not by a Synchro application");
                }
            }
            else
            {
                // The container doesn't exist...
                //
                throw new Error("The container: '" + containerName + "' does not exist");
            }

            var app =
            {
                getAppDefinitionAwaitable: function * ()
                {
                    return yield getAppDefinitionAwaitable(containerName);
                },

                listModulesAwaitable: function * ()
                {
                    var modules = yield getBlobsAwaitable(containerName);

                    var files = lodash.map(modules, "name");
                    lodash.remove(files, function(file)
                    {
                        return (!file || (file.indexOf('node_modules/') == 0) || (path.extname(file) !== ".js")); 
                    });

                    logger.info("List of module files:", files);

                    return files;
                },

                getModuleSourceAwaitable: function * (moduleFilename)
                {
                    return yield getBlobTextAwaitable(containerName, moduleFilename);
                },

                putModuleSourceAwaitable: function * (moduleFilename, content)
                {
                    return yield setBlobTextAwaitable(containerName, moduleFilename, content);
                },

                removeModuleSourceAwaitable: function * (moduleFilename)
                {
                    return yield removeBlobAwaitable(containerName, moduleFilename);
                }
            }

            return app;
        }
    }

    return moduleStore;
}
