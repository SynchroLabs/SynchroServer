// Manta module store
//
// https://apidocs.joyent.com/manta/
//
// https://apidocs.joyent.com/manta/nodesdk.html
// 
// https://github.com/joyent/node-manta
//
var logger = require('log4js').getLogger("manta-module-store");

var assert = require('assert');
var fs = require('fs');
var path = require('path');
var MemoryStream = require('memorystream');

var manta = require('manta');

// Sample config
//
//  "MODULESTORE_PACKAGE": "synchro-api",
//  "MODULESTORE_SERVICE": "MantaModuleStore",
//  "MODULESTORE": {
//    "directory": "~~/stor/",
//    "keyStore": "/Users/bob/.ssh/joyent_id_rsa",
//    "keyId": "8c:09:65:e3:74:54:52:3f:c1:82:3b:5d:cd:09:bc:f4",
//    "url": "https://us-east.manta.joyent.com",
//    "user": "bob@synchro.io"
//  }
//
// Alternatively, you can use "key" instead of "keyStore", and populate it with the key itself (in the same
// form as the contents of an .ssh file)
//
// Or if using env vars (in the normal Manta way, AFAICT):
//
//  Key must be in ~/.ssh and named id_rsa
//  MANTA_KEY_ID="8c:09:65:e3:74:54:52:3f:c1:82:3b:5d:cd:09:bc:f4"
//  MANTA_URL="https://us-east.manta.joyent.com"
//  MANTA_USER="bob@synchro.io"
//
// As above, you can use MANTA_KEY (populated with actual key) instead of, in this case, relying on the default ssh key.
//

module.exports = function(params)
{
    var modulesDir = params.directory;

    logger.debug("Using Manta module store, directory:", modulesDir);

    // "key" is key if provided, else from keyStore if provided, else from default ssh key.
    //    - Not clear if default ssh key is really ever useful here.
    //    - Should explicit keyStore be prioritized over MANTA_KEY env var?
    //
    var key = params.key || process.env.MANTA_KEY || fs.readFileSync(params.keyStore || (process.env.HOME + '/.ssh/id_rsa'), 'utf8'); 

    // logger.debug("Got key:\n", key);

    var client = manta.createClient({
        sign: manta.privateKeySigner({
            key: key,
            keyId: params.keyId || process.env.MANTA_KEY_ID,
            user: params.user || process.env.MANTA_USER
        }),
        user: params.user || process.env.MANTA_USER,
        url: params.url || process.env.MANTA_URL
    });
    assert.ok(client);

    logger.debug('client setup: %s', client.toString());

    function * doesBlobExistAwaitable(path)
    {
        try
        {
            var file = yield function(done) { client.get(path, done) }
            if (file)
            {
                return true;
            }
        }
        catch (err)
        {
            // If error anything other than 404 (not found), rethrow
            if (err.statusCode != 404)
            {
                throw err;
            }
        }

        return false;
    }

    function * getBlobTextAwaitable(path)
    {
        try
        {
            var result = yield function(done) { client.get(path, done) }
            if (result && result.length)
            {
                var stream = result[0];
                stream.setEncoding('utf8');

                var content = yield function(done) 
                {
                    const chunks = [];
                    stream.on('data', (chunk) => {
                        chunks.push(chunk);
                    });
                    stream.on('end', () => {
                        done(null, chunks.join(''));
                    });
                }

                return content;
            }
            else
            {
                logger.error("No file returned");
            }
        }
        catch (err)
        {
            logger.error(err);
            throw err;
        }
    }

    function * setBlobTextAwaitable(path, text)
    {
        var stream = new MemoryStream();
        var writeStream = client.createWriteStream(path);
        stream.pipe(writeStream);

        return yield new Promise(function(resolve, reject)
        {
            writeStream.once('error', function (err) 
            {
                logger.error("Error uploading to path: %s, %s", path, err);
                reject(err);
            });

            writeStream.once('close', function (res) 
            { 
                logger.debug("Done uploading to path: %s", path);
                resolve(null, true);
            });

            stream.end(text);
        });
    }

    function * doesContainerExistAwaitable(path)
    {
        try 
        {
            var opts = { type: 'directory' };
            var res = yield function(done) { client.ls(path, opts, done) };
            return yield function(done)
            {
                res.once('error', function (err) {
                    logger.error(err);
                    done(err);
                });

                res.once('end', function () {
                    done(null, true);
                });
            }
        } 
        catch (err) 
        {
            // If error anything other than 404 (not found), rethrow
            if (err.statusCode != 404)
            {
                throw err;
            }
        }

        return false;
    }

    function * getAppDefinitionAwaitable(container)
    {
        if (container && (container.length > 0))
        {
            var appDefinitionPath = path.posix.join(modulesDir, container, "package.json");
            
            if (yield doesBlobExistAwaitable(appDefinitionPath))
            {
                logger.debug("Downloading package.json");
                var content = yield getBlobTextAwaitable(appDefinitionPath);
                return JSON.parse(content);
            }
            else
            {
                // Defined behavior is return null if no appDefinition...
                return null;
            }
        }
        else
        {
            logger.error("getAppDefinition failed - no container provided");
            return null;
        }
    }

    function isSynchroApp(appDefinition)
    {
        return !!(appDefinition && appDefinition.engines["synchro"]);
    }

    var moduleStore = 
    {
        getAppContainersAwaitable: function * ()
        {
            // Get all subdirs that contain a package.json file which itself indicates it is for a Synchro app...
            //
            var containers = [];
            var opts = { type: 'directory' };
            var res = yield function(done) { client.ls(modulesDir, opts, done) };
            yield function(done)
            {
                res.on('directory', function (dir) {
                    containers.push(dir);
                });

                res.once('error', function (err) {
                    logger.error(err);
                    done(err);
                });

                res.once('end', function () {
                    done();
                });
            }

            var synchroAppContainers = [];
            for (var i = 0; i < containers.length; i++)
            {
                var appDefinition = yield getAppDefinitionAwaitable(containers[i].name);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        synchroAppContainers.push(containers[i].name);
                    }
                }
            }

            return synchroAppContainers;
        },

        createAppContainerAwaitable: function * (container)
        {
            var appContainerPath = path.posix.join(modulesDir, container); 
            logger.debug("Creating app container:", appContainerPath);

            if (yield doesContainerExistAwaitable(appContainerPath))
            {
                // Container already existed
                //
                var appDefinition = yield getAppDefinitionAwaitable(container);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        // A Synchro app already exists in this directory...
                        //
                        throw new Error("A Synchro application already exists in the container: '" + container + "'");
                    }
                    else
                    {
                        // A package.json was found, but not one for a Synchro app...
                        //
                        throw new Error("The container: '" + container + "' is already in use by a Node package, but not by a Synchro application"); 
                    }
                }
                else
                {
                    // The directory name is in use, but not by an existing Synchro app...
                    //
                    throw new Error("The container: '" + container + "' is already in use, but not by a Synchro application");
                }
            }
            else
            {
                // Create container
                //
                logger.debug("Creating container:", container);

                yield function(done) { client.mkdir(appContainerPath, done) };

                // Create a package.json blob with empty-ish JSON contents...
                //
                var packageJson = { engines: { "synchro": "*"} };
                yield setBlobTextAwaitable(path.posix.join(appContainerPath, "package.json"), JSON.stringify(packageJson));
            }

            logger.debug("Returning from createAppContainerAwaitable");
        },

        deleteAppContainerAwaitable: function * (container)
        {
            var appContainerPath = path.posix.join(modulesDir, container); 
            logger.debug("Deleting app container:", appContainerPath);

            yield function(done) { client.rmr(appContainerPath, done) };
        },

        getAppModuleStoreAwaitable: function * (container)
        {
            var appContainerPath = path.posix.join(modulesDir, container); 

            logger.debug("getting app module store for:", container);

            if (yield doesContainerExistAwaitable(appContainerPath))
            {
                var appDefinition = yield getAppDefinitionAwaitable(container);
                if (!appDefinition || !isSynchroApp(appDefinition))
                {
                    // The directory exists, but does not contain a Synchro app...
                    //
                    throw new Error("The container: '" + container + "' is in use, but not by a Synchro application");
                }
            }
            else
            {
                // The container doesn't exist...
                //
                throw new Error("The container: '" + container + "' does not exist");
            }

            var app =
            {
                getAppDefinitionAwaitable: function * ()
                {
                    return yield getAppDefinitionAwaitable(container);
                },

                listModulesAwaitable: function * ()
                {
                    var modules = [];

                    var opts = { type: 'object', name: /^.*[.]js$/, depth: 3 };
                    var res = yield function(done) { client.ftw(appContainerPath, opts, done) };
                    yield function(done)
                    {
                        res.on('object', function (obj) 
                        {
                            var name = obj.name;
                            if (obj.depth > 0)
                            {
                                var pathParts = obj.parent.split(path.posix.sep).slice(obj.depth * -1);
                                var pathPrefix = pathParts.join(path.posix.sep);
                                name = path.posix.join(pathPrefix, name);
                            }

                            if (name.indexOf('node_modules/') != 0)
                            {
                                modules.push(name);
                            }
                        });

                        res.once('error', function (err) {
                            logger.error(err);
                            done(err);
                        });

                        res.once('end', function () {
                            done();
                        });
                    }

                    // logger.info("Got modules:", modules);

                    return modules;
                },

                getModuleSourceAwaitable: function * (moduleFilename)
                {
                    var modulePath = path.posix.join(appContainerPath, moduleFilename); 
                    return yield getBlobTextAwaitable(modulePath);
                },

                putModuleSourceAwaitable: function * (moduleFilename, content)
                {
                    var modulePath = path.posix.join(appContainerPath, moduleFilename); 
                    return yield setBlobTextAwaitable(modulePath, content);
                },

                removeModuleSourceAwaitable: function * (moduleFilename)
                {
                    var modulePath = path.posix.join(appContainerPath, moduleFilename); 
                    yield function(done) { client.unlink(modulePath, done) };
                    return true;
                }
            }

            return app;
        }
    }

    return moduleStore;
}
