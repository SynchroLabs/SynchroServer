// Module: Reader-Writer 
//
// Usage:
//
// The ReaderWriter object produced by this module will match up pending reads and writes on a channel when 
// the reads and writes occur asynchronously to each other, regardless of whether the read or write is posted
// first.  When a cooresponsing read and write for the same channel have both been posted, the write operation 
// will have its callback called and can then write to the reader.  It is assumed that only a single read and 
// write may be posted for a given channel until the read/write has been satisfied.
//
// When the reader is ready to read, it calls:
//
//    readerWriter.readAsync(channelId, function(err, data)
//    {
//        // "data" received ("read") from writer
//    });
//
// When the writer is ready to write, it calls:
//
//    readerWriter.writeAsync(channelId, function(err, writeData)
//    {
//        // The writeData function will write data to a waiting reader
//        writeData("the data");
//    });
//
var lodash = require("lodash");

var logger = require('log4js').getLogger("reader-writer");

var ReaderWriter = function(purgeInterval)
{
    this.purgeInterval = purgeInterval || 60 * 1000; // By default we'll purge once a minute
    this.readsLastPurged = Date.now();
    this.writesLastPurged = Date.now();
    this.pendingReads = {};
    this.pendingWrites = {};
}

ReaderWriter.prototype.drain = function()
{
	this.pendingReads = {};
	this.pendingWrites = {};
}

ReaderWriter.prototype.cancelAll = function(prefix)
{
    this.pendingReads = lodash.pickBy(this.pendingReads, function(val, key) {
        return !lodash.startsWith(key, prefix) 
    });
    this.pendingWrites = lodash.pickBy(this.pendingWrites, function(val, key) { 
        return !lodash.startsWith(key, prefix);
    });
}

// Purge "old" reads if it's been at least 60 seconds since we last purged (or if "force").
//
ReaderWriter.prototype.purgeReads = function(olderThan, force)
{
    if (force || ((Date.now() - this.readsLastPurged) > this.purgeInterval))
    {
        this.pendingReads = lodash.pickBy(this.pendingReads, function(val, key) {
            return (val.time > olderThan);  
        });
    }
}

// Purge "old" writes if it's been at least 60 seconds since we last purged (or if "force").
//
ReaderWriter.prototype.purgeWrites = function(olderThan, force)
{
    if (force || ((Date.now() - this.writesLastPurged) > this.purgeInterval))
    {
        this.pendingWrites = lodash.pickBy(this.pendingWrites, function(val, key) {
            return (val.time > olderThan);  
        });
    }
}

ReaderWriter.prototype.purgeAll = function(readTimeout, writeTimeout, force)
{
    var now = Date.now();
    this.purgeReads(now - readTimeout, force);
    this.purgeWrites(now - writeTimeout, force);
}

ReaderWriter.prototype.isReadPending = function(channelId)
{
	return !!(channelId && this.pendingReads[channelId]);
}

ReaderWriter.prototype.isWritePending = function(channelId)
{
	return !!(channelId && this.pendingWrites[channelId]);
}

ReaderWriter.prototype.getPendingReadAge = function(channelId, time)
{
    time = time || Date.now(); // Allow passing in for test
    var age = -1;
    if (channelId && this.pendingReads[channelId] && this.pendingReads[channelId].time)
    {
        age = time - this.pendingReads[channelId].time;
    }
    return age;
}

ReaderWriter.prototype.getPendingWriteAge = function(channelId, time)
{
    time = time || Date.now(); // Allow passing in for test
    var age = -1;
    if (channelId && this.pendingWrites[channelId] && this.pendingWrites[channelId].time)
    {
        age = time - this.pendingWrites[channelId].time;
    }
    return age;
}

ReaderWriter.prototype.cancelRead = function(channelId)
{
	if (channelId && this.pendingReads[channelId])
	{
		delete this.pendingReads[channelId];
	}
}

ReaderWriter.prototype.cancelWrite = function(channelId)
{
	if (channelId && this.pendingWrites[channelId])
	{
		delete this.pendingWrites[channelId];
	}
}

// Queue a read operation.  No subsequent reads should be attempted on this channel until this read completes.
//
ReaderWriter.prototype.readAsyncAwaitable = function * (channelId, onReadAwaitable, time)
{
    logger.debug("readAsync, channel:", channelId);
    if (this.pendingReads[channelId])
    {
    	yield onReadAwaitable("Pending read already exists for channel ID: " + channelId);
   	}
    else if (this.pendingWrites[channelId])
    {
    	var pendingWriteAwaitable = this.pendingWrites[channelId].write;
		delete this.pendingWrites[channelId];

        logger.debug("Pending write for channel %s, calling write", channelId);
    	yield pendingWriteAwaitable(null, function * (data)
    	{
            logger.debug("Pending write for channel %s completed, calling read", channelId);
    		yield onReadAwaitable(null, data);
    	});
    }
    else
    {
        time = time || Date.now(); // Allow passing in for test
        logger.debug("No pending write for channel %s, posting read", channelId);
    	this.pendingReads[channelId] = { read: onReadAwaitable, time: time };
    }
}

// Queue a write operation.  No subsequent writes should be attempted on this channel until this write completes.
//
ReaderWriter.prototype.writeAsyncAwaitable = function * (channelId, onWriteAwaitable, time)
{
    logger.debug("writeAsync, channel:", channelId);
    if (this.pendingWrites[channelId])
    {
    	yield onWriteAwaitable("Pending write already exists for channel ID: " + channelId);
   	}
   	else if (this.pendingReads[channelId])
    {
		var pendingReadAwaitable = this.pendingReads[channelId].read;
		delete this.pendingReads[channelId];

        logger.debug("Pending read for channel %s, calling write", channelId);
    	yield onWriteAwaitable(null, function * (data)
    	{
            logger.debug("Pending read for channel %s completed, calling read", channelId);
    		yield pendingReadAwaitable(null, data);
    	});
    }
    else
    {
        time = time || Date.now(); // Allow passing in for test
        logger.debug("No pending read for channel %s, posting write", channelId);
    	this.pendingWrites[channelId] = { write: onWriteAwaitable, time: time };
    }
}

module.exports = ReaderWriter;
