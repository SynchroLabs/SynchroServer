// Modules: Reader-Writer 
//
// Usage:
//
// The ReaderWriter object produced by this module will match up pending reads and writes on a channel when 
// the reads and writes occur asynchronously to each other, regardless of whether the read or write is posted
// first.  When a cooresponsing read and write for the same channel have both been posted, the write operation 
// will have its callback called and can then write to the reader.  It is assumed that only a single read and 
// write may be posted for a given channel until the read/write has been satisfied.
//
// TODO: It may be desirable to timestamp the pending reads and writes such that abandoned reads and writes can
//       be cleared when a timeout has expired (to prevent them from backing up), assuming this situation can
//       arise (that remains to be seen).
//
// When the reader is ready to read, it calls:
//
//    readerWriter.readAsync(channelId, function(err, data)
//    {
//        // "data" received ("read") from writer
//    });
//
// When the writer is ready to write, it calls:
//
//    readerWriter.writeAsync(channelId, function(err, writeData)
//    {
//        // The writeData function will write data to a waiting reader
//        writeData("the data");
//    });
//
var logger = require('log4js').getLogger("reader-writer");

var ReaderWriter = function()
{
    this.pendingReads = {};
    this.pendingWrites = {};
}

ReaderWriter.prototype.drain = function()
{
	this.pendingReads = {};
	this.pendingWrites = {};
}

ReaderWriter.prototype.isReadPending = function(channelId)
{
	return !!(channelId && this.pendingReads[channelId]);
}

ReaderWriter.prototype.isWritePending = function(channelId)
{
	return !!(channelId && this.pendingWrites[channelId]);
}

ReaderWriter.prototype.cancelRead = function(channelId)
{
	if (channelId && this.pendingReads[channelId])
	{
		delete this.pendingReads[channelId];
	}
}

ReaderWriter.prototype.cancelWrite = function(channelId)
{
	if (channelId && this.pendingWrites[channelId])
	{
		delete this.pendingWrites[channelId];
	}
}

// Queue a read operation.  No subsequent reads should be attempted on this channel until this read completes.
//
ReaderWriter.prototype.readAsyncAwaitable = function * (channelId, onReadAwaitable)
{
    logger.info("readAsync, channel:", channelId);
    if (this.pendingReads[channelId])
    {
    	yield onReadAwaitable("Pending read already exists for channel ID: " + channelId);
   	}
    else if (this.pendingWrites[channelId])
    {
    	var pendingWriteAwaitable = this.pendingWrites[channelId];
		delete this.pendingWrites[channelId];

        logger.info("Pending write for channel %s, calling write", channelId);
    	yield pendingWriteAwaitable(null, function * (data)
    	{
            logger.info("Pending write for channel %s completed, calling read", channelId);
    		yield onReadAwaitable(null, data);
    	});
    }
    else
    {
        logger.info("No pending write for channel %s, posting read", channelId);
    	this.pendingReads[channelId] = onReadAwaitable;
    }
}

// Queue a write operation.  No subsequent writes should be attempted on this channel until this write completes.
//
ReaderWriter.prototype.writeAsyncAwaitable = function * (channelId, onWriteAwaitable)
{
    logger.info("writeAsync, channel:", channelId);
    if (this.pendingWrites[channelId])
    {
    	yield onWriteAwaitable("Pending write already exists for channel ID: " + channelId);
   	}
   	else if (this.pendingReads[channelId])
    {
		var pendingReadAwaitable = this.pendingReads[channelId];
		delete this.pendingReads[channelId];

        logger.info("Pending read for channel %s, calling write", channelId);
    	yield onWriteAwaitable(null, function * (data)
    	{
            logger.info("Pending read for channel %s completed, calling read", channelId);
    		yield pendingReadAwaitable(null, data);
    	});
    }
    else
    {
        logger.info("No pending read for channel %s, posting write", channelId);
    	this.pendingWrites[channelId] = onWriteAwaitable;
    }
}

module.exports = ReaderWriter;
