// Redis session store using ioredis
//
// Note: This is the session store for Synchro clients calling the Synchro API, and is not related to any web session store
//       for the admin/development web site.
//

// https://github.com/luin/ioredis
var redis = require('ioredis');

var request = require('request');
var uuid = require('node-uuid');
var lodash = require('lodash');
var co = require('co');

var logger = require('log4js').getLogger("synchro-ioredis-session");

exports.createServiceAwaitable = function * (params)
{
    var client;

    var consulRetries = params.consulRetries || 3;
    var consulDelayMs = params.consulDelayMs || 1000;

    function * getSentinelsAwaitable(consul)
    {
        var serviceCatalogUrl = "http://" + consul + ":8500/v1/catalog/service/redis-sentinel";

        return yield function(done)
        {
            request.get(serviceCatalogUrl, function(err, res, body)
            {
                if (err)
                {
                    done(err);
                }
                else if (res.statusCode != 200)
                {
                    done(new Error("Error response code: " + res.statusCode + ", body: " + body));
                }
                else
                {
                    try 
                    {
                        var services = JSON.parse(body);
                        logger.debug("Consul returned services:", services);
                        var sentinels = lodash.map(services, function(service){ return { host: service.ServiceAddress, port: service.ServicePort } });
                        logger.debug("Parsed Sentinels:", sentinels);
                        done(null, sentinels);
                    }
                    catch (err) 
                    {
                        done(err);
                    }
                }
            });
        };
    }

    function * createClientAwaitable()
    {
        var clientOpts = {};

        var onClientError = function (err) 
        {
            logger.error("error event - " + err);
        };

        var onClientEnd = function () 
        {
            logger.debug("the connection has ended");
        };

        if (client)
        {
            logger.debug("Removing listeners");
            client.removeListener("error", onClientError);
            client.removeListener("end", onClientEnd);
            client.quit();
            client = null;
        }

        if (params.sentinels)
        {
            if (params.sentinels === true)
            {
                // Look up Sentinels from CONSUL (needs to be provided in svc config, since we have no context to get get any config/state)
                //
                var consul = params.consul || "consul"; 

                for (var i = 0; i < consulRetries; i++)
                {
                    logger.debug("Getting Sentinels from Consul '%s', attempt: %d", consul, i);
                    var sentinels = yield getSentinelsAwaitable(consul);
                    if (sentinels && sentinels.length)
                    {
                        clientOpts.sentinels = sentinels; 
                        break;
                    }
                    else if (i < (consulRetries - 1))
                    {
                        logger.debug("Failed to get sentinels from Consul, waiting %d ms before retry", consulDelayMs);
                        yield function(done){setTimeout(done, consulDelayMs)};
                    }
                }

                if (!clientOpts.sentinels)
                {
                    throw new Error("Failed to get Sentinels from Consul after " + consulRetries + "attempts, failed to create client");
                }
            }
            else if (params.sentinels.length)
            {
                clientOpts.sentinels = params.sentinels;
            }
            else
            {
                // This would only happen in the case of an empty array in the sentinals value
                throw new Error("Sentinals specfied, but none provided in config, failed to create client");
            }

            clientOpts.name = params.name || 'mymaster';
        }
        else
        {
            if (params.port)
            {
                clientOpts.port = params.port;
            }
            if (params.host)
            {
                clientOpts.host = params.host;
            }
            if (params.password)
            {
                clientOpts.password = params.password;
            }
        }

        logger.debug("Creating Redis session store with opts:", clientOpts);
        client = redis.createClient(clientOpts);

        client.on("error", onClientError);
        client.on("end", onClientEnd);
    }

    // Setup initial Redis connection (via ioredis)
    //
    yield createClientAwaitable(params);

    // The idea is that when using a Sentinal configuration, the set of Sentinals may change, and so you may
    // need to reconnect with the new set (in the case where the set of Sentinels comes from Consul).  We provide
    // this SIGHUP handler to reconfigure the session, which in the case of a Sentinel/Consul config, will requery
    // Consul for the set of Sentinels to use.
    //
    // It should be noted that when you have several Sentinals configured, it is not necessary to keep the Sentinal
    // config exacly up to date.  But in the case of a containerized AutoPilot implementation, you will typically
    // start with a single Sentinel, and then subsequent to startup, several more may be added as the application
    // scales.  Moving from this single Sentinel to a more robust set of Sentinels is the reason we have this
    // connection reconfiguration logic and handler.
    //
    process.on('SIGHUP', function ()
    {
        logger.info('SIGHUP in io-redis session store');
        co(createClientAwaitable).catch(function (err)
        {
            logger.error("Error in SIGHUP:", err);
        });
    }); 

    // Profiling functions...
    //
    function timerStart()
    {
        return process.hrtime();
    }

    function timerDiff(timeStart)
    {
        var diff = process.hrtime(timeStart);
        var millis = (diff[0] * 1000) + (diff[1] / 1000000);

        return millis;
    }

    function createSessionRedis(callback)
    {
        var session = { id: uuid.v4() };

        var startTime = timerStart();

        client.set(session.id, JSON.stringify(session), function (error, result)
        {
            if (!error)
            {
                logger.debug("Redis session create succeeded (" + timerDiff(startTime) + " ms)");
                callback(null, session);
            }
            else
            {
                logger.error("Redis session create failed:: " + error);
                callback(error);
            }
        });
    }

    function getSessionRedis(sessionId, callback)
    {
        var startTime = timerStart();

        client.get(sessionId, function (error, result)
        {
            if (!error)
            {
                logger.debug("Redis session get succeeded (" + timerDiff(startTime) + " ms)");
                callback(null, JSON.parse(result));
            }
            else
            {
                logger.error("Redis session get failed:: " + error);
                callback(error);
            }
        });
    }

    function putSessionRedis(session, callback)
    {
        var startTime = timerStart();

        client.set(session.id, JSON.stringify(session), function (error, result)
        {
            if (!error)
            {
                logger.debug("Redis session put succeeded (" + timerDiff(startTime) + " ms)");
                callback(null);
            }
            else
            {
                logger.error("Redis session put failed:: " + error);
                callback(error);
            }
        });
    }

    var sessionStore = 
    {
        createSessionAwaitable: function * ()
        {
            return yield function(done){createSessionRedis(done)}
        },

        getSessionAwaitable: function * (sessionId)
        {
            return yield function(done){getSessionRedis(sessionId, done)}
        },

        putSessionAwaitable: function * (session)
        {
            yield function(done){putSessionRedis(session, done)}
        },

        deleteSessionAwaitable: function * (sessionId)
        {
            yield function(done){client.del(sessionId, done)}
        }
    }

    return sessionStore;
}
