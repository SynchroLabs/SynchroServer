// Following is code to load Synchro modules that do not (necessarily) exist in physical disk files.
//
// Reference: https://github.com/joyent/node/blob/master/lib/module.js
//
// Here is some higher order cache invalidation thinking...
//
//     http://stackoverflow.com/questions/9210542/node-js-require-cache-possible-to-invalidate
//
var path = require('path');
var lodash = require('lodash');

var co = require('co');
var coHelper = require('./co-helper');

var Module = require('module');

var logger = require('log4js').getLogger("module-manager");

// -----------------------------------------------------------

// Note: The module loader below loads modules from the provided moduleStore.  It keeps a route map, and uses
//       that to give to processors.  In this way, if a module representing a route is reloaded, new processors
//       will get the reloaded module, while existing processors can finish their transactions using the previous
//       version, to which they still have a reference.  So the server can hum along happily with a restart.
//
//       One limitation of this is that if one of these route modules references another route module (perhaps
//       because they share some common code), when the referenced module is reloaded it will not trigger the 
//       dependent module to be reloaded (the dependent module will have a reference to the old referenced 
//       module until the dependent module itself is reloaded).  This is not ideal.  One solution would be to
//       understand the dependency relationship so we know which dependent modules, if any, also need to be reloaded
//       when we reload a module.
//
//       Another issue is that we currently do not support any kind of route module path or subdirectory notation
//       in the module stores, so everything has to be a the top level.  It would be nice if we could both group
//       our modules into folders, and if we could have a node_modules folder that allowed local packages.  Either
//       of these things, when implemented, probably imply a reworking of the route/mapper (so that we treat actual
//       routes to pages differently potentially than we treat the loading/management of supporting modules).
//       

module.exports = function * (moduleStore, appRootPath, appContainer, resourceResolver) // !!! Gonna need the server version too (from it's package.json)
{
    var containerDir = path.resolve(appRootPath, appContainer) + path.sep;

    var appModuleStore = yield moduleStore.getAppModuleStoreAwaitable(appContainer);
    
    // This is the route dictionary (routePath: module)
    var routes = {};
    
    // Ordered list of hook modules
    var hookModuleNames = [];
    var hookModules = [];
    
    // This is the list of files that exist in the module store and may be loaded from it
    var moduleFiles = [];
    
    var supportModule;
    
    // Is the module referenced by the filename in our container...
    //
    function isContainerModule(filename)
    {
        // Look for file paths under container dir...
        //
        if (filename.lastIndexOf(containerDir, 0) == 0)
        {
            // Except for anything in the node_modules under the container dir...
            //
            if (filename.lastIndexOf(path.resolve(containerDir, "node_modules"), 0) != 0)
            {
                var modulePath = getModuleStorePath(filename);
                if (moduleFiles.indexOf(modulePath) >= 0)
                {
                    return true;
                }
            }
        }
    }
    
    var platformIndependentPathSep = '/';
    
    function convertToPlatformIndependentPath(name)
    {
        if (path.sep == '\\')
        {
            return name.replace(/[\\]/g, platformIndependentPathSep);
        }
        return name;
    }
    
    function removeFileExtension(filepath)
    {
        return filepath.split(".").slice(0, -1).join(".") || filepath + "";
    }

    // Get path relative to container with normalized separators...
    //
    function getModuleStorePath(filename)
    {
        if (filename.lastIndexOf(containerDir, 0) == 0)
        {
            var modulePath = filename.substring(containerDir.length);
            return convertToPlatformIndependentPath(modulePath);
        }
    }
    
    // Is the module a hook module...
    //
    function isHookModulePath(fileName)
    {
        return (hookModuleNames.indexOf(removeFileExtension(fileName)) != -1);
    }

    // Is the module a top-level module (possible a route)...
    //
    function isRouteModulePath(moduleName)
    {
        // Top level modules only...
        //
        return (moduleName.indexOf('/') == -1);
    }
    
    // Is the loaded module actually a route module...
    //
    function isRouteModule(module)
    {
        return (module.View || module.InitializeView);
    }

    // The module source cache is where we pre-load module source, since we cannot load the source asynchronously
    // inside of our hooked module loader in the generator implementation.  We can load the source and stash it here,
    // then when the hooked module loader tries to load the module, it can get the source from here synchronously.
    //
    var ModuleSourceCache = function()
    {
        this.sourceCache = {};
    }

    ModuleSourceCache.prototype.enCacheModule = function(module, source)
    {
        this.sourceCache[module] = source;
    }

    ModuleSourceCache.prototype.deCacheModule = function(module)
    {
        var source = this.sourceCache[module];
        delete this.sourceCache[module];
        return source;
    }

    ModuleSourceCache.prototype.dump = function()
    {
        logger.info("Cache:", this.sourceCache);
    }

    ModuleSourceCache.prototype.clear = function()
    {
        this.sourceCache = {};
    }

    var moduleSourceCache = new ModuleSourceCache();

    // Node.js is *very* excited about associating every loaded module with a physical file on disk.
    // In order to work around this, we monkey-patch _resolveFilename to return the "virtual" filename
    // for modules that we will later be able to load (in the extension loader below).
    //
    // This is required because the file may not actually exist at the file system location indicated, for
    // example when a remote module store (Azure, AWS, etc) is being used.
    //
    Module._resolveFilename = (function (original)
    {
        return function (request, parent)
        {
            if (parent.filename) // Check to see if this is relative path that resolves to a module file
            {
                var filename = path.resolve(path.dirname(parent.filename), request);
                if (path.extname(filename) == "")
                {
                    filename = filename + ".js";
                }           

                if (isContainerModule(filename))
                {
                    return filename;
                }
            }
            return original.apply(this, arguments)
        }
    })(Module._resolveFilename);

    // This is a monkey-patching of the extension loader that allows us to load our own js modules.
    //
    Module._extensions['.js'] = (function (original)
    {
        return function (module, filename)
        {
            // logger.info("Module loader - extension loader for file: " + filename);

            if (isContainerModule(filename))
            {
                logger.debug("Loading container file: " + filename);

                var moduleName = getModuleStorePath(filename);
                var moduleSource = moduleSourceCache.deCacheModule(moduleName);

                if (moduleSource)
                {
                    // When a module is loaded by Node, it is wrapped in this function:
                    //
                    //    (function (exports, require, module, __filename, __dirname) { -- your module code goes here --    
                    //    });
                    //
                    // This happens as part of NativeModule.wrap() - see: https://github.com/joyent/node/blob/master/src/node.js
                    //
                    // Below we take advantage of this to jam in the Synchro module reference.  It is tempting to add a newline, 
                    // but that would interfere with the line numbering of the file, which is important for debugging/breakpoints.
                    //
                    // We used to only add the Synchro support module to route modules (and not to other modules in the container, 
                    // such as shared / utility modules).  This meant those non-route modules did not have access to the Synchro
                    // built-in helper functions.  Commented out the line below so that all container modules have access to the
                    // Synchro support module (and built-in helper functions).
                    //
                    //if (isRouteModulePath(modulePath))
                    {
                        module.supportModule = supportModule;
                        moduleSource = " var Synchro = module.supportModule; " + moduleSource;
                    }
                    try
                    {
                        module._compile(moduleSource, filename); // This can fail (code is user-provided) !!! Need better error indicating module being loaded
                    }
                    catch (err)
                    {
                        // We don't have file or line number informaiton until Node.js v6.0 (it seems)
                        // https://github.com/nodejs/node/pull/4874
                        //
                        // We'll at least give you the module name for now...
                        //
                        logger.error("Error loading module:", moduleName);
                        throw(err);
                    }
                }
                else
                {
                    logger.error("Module source was not preloaded, module load failed:", moduleName);
                }
            }
            else
            {
                return original.apply(this, arguments)
            }
        }
    })(Module._extensions['.js']);

    function * loadAppRoutesAndHooksAwaitable()
    {
        var appDefinition = yield appModuleStore.getAppDefinitionAwaitable();
        if (lodash.isArray(appDefinition.hooks))
        {
            hookModuleNames = appDefinition.hooks;
        }
        else if (lodash.isString(appDefinition.hooks))
        {
            hookModuleNames = [appDefinition.hooks];
        }
        hookModules = new Array(hookModuleNames.length);

        var moduleNames = yield appModuleStore.listModulesAwaitable();

        moduleFiles = moduleNames;

        // Since we don't know which modules might require other modules before loading, and since we can't load any
        // source asynchrounously in response to a module load via require, we have to pre-load and cache the source 
        // for all modules in the app, so the source will be present when it is required.
        //
        for (var i = 0; i < moduleNames.length; i++) 
        {
            var moduleName = moduleNames[i];
            logger.debug("Loading and caching module source:", moduleName);
            var moduleSource = yield appModuleStore.getModuleSourceAwaitable(moduleName);
            moduleSourceCache.enCacheModule(moduleName, moduleSource);
        }

        // Now we load the routes and hooks...
        //
        for (var i = 0; i < moduleNames.length; i++) 
        {
            var moduleName = moduleNames[i];
            if (isHookModulePath(moduleName) || isRouteModulePath(moduleName))
            {
                var filename = path.resolve(containerDir, moduleName);
                var synchroModule = require(filename);
                
                if (isHookModulePath(moduleName))
                {
                    var hookPath = removeFileExtension(moduleName);
                    logger.debug("Loaded hook module:", hookPath);
                    hookModules[hookModuleNames.indexOf(hookPath)] = synchroModule;
                }
                else if (isRouteModule(synchroModule))
                {
                    var routePath = path.basename(moduleName, path.extname(moduleName));
                    logger.debug("Loaded route module:", routePath);
                    routes[routePath] = synchroModule;
                }
            }
        }
        
        // The module loading should have drained the cache.  If there is a module that was not in the root directory and
        // not referenced ("required") by any other module, it could still be hanging around, so we flush the source cache.
        //
        moduleSourceCache.clear();

        return appDefinition;
    }
    
    function * callHookFunctionByIndexAwaitable(index, fnName, args)
    {
        var hookModule = hookModules[index];
        if (hookModule)
        {
            var hookFn = hookModule[fnName];
            if (hookFn)
            {
                if (coHelper.isGeneratorFunction(hookFn))
                {
                    return yield hookFn.apply(hookModule, args);
                }
                else if (hookFn)
                {
                    return hookFn.apply(hookModule, args);
                }
            }
        }
    }

    // !!! We're going to need some mechanism to deal with modules being added/deleted from Studio, which will call in to here
    //     to refresh the state of the running API processor (presumably).
    //
    var moduleManager = 
    {
        isFunctionHooked: function (fnName)
        {
            for (var n = 0, len = hookModules.length; n < len; n++)
            {
                var hookModule = hookModules[n];
                if (hookModule)
                {
                    if (hookModule["Before" + fnName] || hookModule["After" + fnName])
                    {
                        return true;
                    }
                }
            }
            return false;
        },

        callHookFunctionAwaitable: function * (fnName)
        {
            if (fnName.indexOf('After') != 0)
            {
                for (var n = 0, len = hookModules.length; n < len; n++) // Default order is forward
                {
                    yield callHookFunctionByIndexAwaitable(n, fnName, lodash.tail(arguments)); // Remove fnName from arguments
                }
            }
            else
            {
                for (var n = hookModules.length - 1; n >= 0; n--) // If "After" function, reverse hook order
                {
                    yield callHookFunctionByIndexAwaitable(n, fnName, lodash.tail(arguments)); // Remove fnName from arguments
                }
            }
        },
        
        loadRoutesAwaitable: function * (apiProcessor)
        {
            supportModule = require('./app-services')(apiProcessor, resourceResolver);
            return yield loadAppRoutesAndHooksAwaitable();
        },

        reloadModuleAwaitable: function * (moduleName, source)
        {
            logger.debug("Reload module: ", moduleName);

            if (source)
            {
                yield appModuleStore.putModuleSourceAwaitable(moduleName, source);
            }

            // NOTE: There's no easy way to figure out which other modules might be impacted by the change to the
            //       module being reloaded, so we're just going to clean up the whole Synchro app and reload it.

            // Delete all currently loaded modules that were loaded from this container...
            //
            for (var cachedModule in require.cache) 
            {
                if (require.cache.hasOwnProperty(cachedModule)) 
                {
                    if (cachedModule.indexOf(containerDir, 0) == 0)
                    {
                        logger.debug("Uncaching module: " + cachedModule);
                        delete require.cache[cachedModule];
                    }
                }
            }

            // Reload all the routes (and hooks)
            //
            try
            {
                yield * loadAppRoutesAndHooksAwaitable();
            }
            catch (err)
            {
                logger.error("Caught err on loading routes: ", err);
                return { error: err.message };
            }

            return true;
        },

        getModule: function(routePath)
        {
            return routes[routePath];
        }
    }

    return moduleManager;
}
