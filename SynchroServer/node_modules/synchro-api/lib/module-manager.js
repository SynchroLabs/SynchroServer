// Following is code to load Synchro modules that do not (necessarily) exist in physical disk files.
//
// Reference: https://github.com/joyent/node/blob/master/lib/module.js
//
// Here is some higher order cache invalidation thinking...
//
//     http://stackoverflow.com/questions/9210542/node-js-require-cache-possible-to-invalidate
//
var path = require('path');
var fs = require('fs');
var lodash = require('lodash');

var co = require('co');
var coHelper = require('./co-helper');

var Module = require('module');

var logger = require('log4js').getLogger("module-manager");

var util = require('./util');

// -----------------------------------------------------------

// Note: The module loader below loads modules from the provided moduleStore.  It keeps a route map, and uses
//       that to give to processors.  In this way, if a module representing a route is reloaded, new processors
//       will get the reloaded module, while existing processors can finish their transactions using the previous
//       version, to which they still have a reference.  So the server can hum along happily with a restart.
//
//       One limitation of this is that if one of these route modules references another route module (perhaps
//       because they share some common code), when the referenced module is reloaded it will not trigger the 
//       dependent module to be reloaded (the dependent module will have a reference to the old referenced 
//       module until the dependent module itself is reloaded).  This is not ideal.  One solution would be to
//       understand the dependency relationship so we know which dependent modules, if any, also need to be reloaded
//       when we reload a module.
//
//       Another issue is that we currently do not support any kind of route module path or subdirectory notation
//       in the module stores, so everything has to be a the top level.  It would be nice if we could both group
//       our modules into folders, and if we could have a node_modules folder that allowed local packages.  Either
//       of these things, when implemented, probably imply a reworking of the route/mapper (so that we treat actual
//       routes to pages differently potentially than we treat the loading/management of supporting modules).
//       

module.exports = function * (moduleStore, config, appContainer, resourceResolver) // !!! Gonna need the server version too (from it's package.json)
{
    var appRootPath = config.get("APP_ROOT_PATH");
    var containerDir = path.resolve(appRootPath, appContainer) + path.sep;

    var appModuleStore = yield moduleStore.getAppModuleStoreAwaitable(appContainer);
    
    // The hash of the dependencies from the package.json (appDefinition) the last time it was loaded
    //
    var dependenciesHash = null;

    // This is the route dictionary (routePath: module)
    var routes = {};
    
    // Ordered list of hook modules
    var hookModuleNames = [];
    var hookModules = [];
    
    // This is the list of files that exist in the module store and may be loaded from it
    var moduleFiles = [];
    
    var supportModule;
    
    // Is the module referenced by the filename in our container...
    //
    function isContainerModule(filename)
    {
        // Look for file paths under container dir...
        //
        if (filename.lastIndexOf(containerDir, 0) == 0)
        {
            // Except for anything in the node_modules under the container dir...
            //
            if (filename.lastIndexOf(path.resolve(containerDir, "node_modules"), 0) != 0)
            {
                var modulePath = getModuleStorePath(filename);
                if (moduleFiles.indexOf(modulePath) >= 0)
                {
                    return true;
                }
            }
        }
    }
    
    var platformIndependentPathSep = '/';
    
    function convertToPlatformIndependentPath(name)
    {
        if (path.sep == '\\')
        {
            return name.replace(/[\\]/g, platformIndependentPathSep);
        }
        return name;
    }
    
    function removeFileExtension(filepath)
    {
        return filepath.split(".").slice(0, -1).join(".") || filepath + "";
    }

    // Get path relative to container with normalized separators...
    //
    function getModuleStorePath(filename)
    {
        if (filename.lastIndexOf(containerDir, 0) == 0)
        {
            var modulePath = filename.substring(containerDir.length);
            return convertToPlatformIndependentPath(modulePath);
        }
    }
    
    // Is the module a hook module...
    //
    function isHookModulePath(fileName)
    {
        return (hookModuleNames.indexOf(removeFileExtension(fileName)) != -1);
    }

    // Is the module a top-level module (possible a route)...
    //
    function isRouteModulePath(moduleName)
    {
        // Top level modules only...
        //
        return (moduleName.indexOf('/') == -1);
    }
    
    // Is the loaded module actually a route module...
    //
    function isRouteModule(module)
    {
        return (module.View || module.InitializeView);
    }

    // The module source cache is where we pre-load module source, since we cannot load the source asynchronously
    // inside of our hooked module loader in the generator implementation.  We can load the source and stash it here,
    // then when the hooked module loader tries to load the module, it can get the source from here synchronously.
    //
    var ModuleSourceCache = function()
    {
        this.sourceCache = {};
    }

    ModuleSourceCache.prototype.enCacheModule = function(module, source)
    {
        this.sourceCache[module] = source;
    }

    ModuleSourceCache.prototype.deCacheModule = function(module)
    {
        var source = this.sourceCache[module];
        delete this.sourceCache[module];
        return source;
    }

    ModuleSourceCache.prototype.dump = function()
    {
        logger.info("Cache:", this.sourceCache);
    }

    ModuleSourceCache.prototype.clear = function()
    {
        this.sourceCache = {};
    }

    var moduleSourceCache = new ModuleSourceCache();

    // Node.js is *very* excited about associating every loaded module with a physical file on disk.
    // In order to work around this, we monkey-patch _resolveFilename to return the "virtual" filename
    // for modules that we will later be able to load (in the extension loader below).
    //
    // This is required because the file may not actually exist at the file system location indicated, for
    // example when a remote module store (Azure, AWS, etc) is being used.
    //
    Module._resolveFilename = (function (original)
    {
        return function (request, parent)
        {
            if (parent.filename) // Check to see if this is relative path that resolves to a module file
            {
                var filename = path.resolve(path.dirname(parent.filename), request);
                if (path.extname(filename) == "")
                {
                    filename = filename + ".js";
                }           

                if (isContainerModule(filename))
                {
                    return filename;
                }
            }
            return original.apply(this, arguments)
        }
    })(Module._resolveFilename);

    // This is a monkey-patching of the extension loader that allows us to load our own js modules.
    //
    Module._extensions['.js'] = (function (original)
    {
        return function (module, filename)
        {
            // logger.info("Module loader - extension loader for file: " + filename);

            if (isContainerModule(filename))
            {
                logger.debug("Loading container file: " + filename);

                var moduleName = getModuleStorePath(filename);
                var moduleSource = moduleSourceCache.deCacheModule(moduleName);

                if (moduleSource)
                {
                    // When a module is loaded by Node, it is wrapped in this function:
                    //
                    //    (function (exports, require, module, __filename, __dirname) { -- your module code goes here --    
                    //    });
                    //
                    // This happens as part of NativeModule.wrap() - see: https://github.com/joyent/node/blob/master/src/node.js
                    //
                    // Below we take advantage of this to jam in the Synchro module reference.  It is tempting to add a newline, 
                    // but that would interfere with the line numbering of the file, which is important for debugging/breakpoints.
                    //
                    // We used to only add the Synchro support module to route modules (and not to other modules in the container, 
                    // such as shared / utility modules).  This meant those non-route modules did not have access to the Synchro
                    // built-in helper functions.  Commented out the line below so that all container modules have access to the
                    // Synchro support module (and built-in helper functions).
                    //
                    //if (isRouteModulePath(modulePath))
                    {
                        module.supportModule = supportModule;
                        moduleSource = " var Synchro = module.supportModule; " + moduleSource;
                    }
                    try
                    {
                        module._compile(moduleSource, filename); // This can fail (code is user-provided) !!! Need better error indicating module being loaded
                    }
                    catch (err)
                    {
                        // We don't have file or line number informaiton until Node.js v6.0 (it seems)
                        // https://github.com/nodejs/node/pull/4874
                        //
                        // We'll at least give you the module name for now...
                        //
                        logger.error("Error loading module:", moduleName);
                        throw(err);
                    }
                }
                else
                {
                    logger.error("Module source was not preloaded, module load failed:", moduleName);
                }
            }
            else
            {
                return original.apply(this, arguments)
            }
        }
    })(Module._extensions['.js']);

    function npmInstall(cwd, callback)
    {
        logger.info("Running npm install on:", cwd);

        var exec = require('child_process').exec;
        var options = 
        {
            stdio: 'inherit',
            cwd: cwd
        }

        var child = exec('npm --only=production --loglevel=error install', options, function(err, stdout, stderr) 
        {
            if (err) 
            {
                logger.error("npm install failed with error code", err.code);
                logger.error("Error details: ", stderr);
                callback(err);
            }
            else
            {
                callback();
            }
        });

        // !!! Should we log this instead?  As below, or just in the callback?
        //
        child.stdout.on('data', function(data) {
            process.stdout.write(data.toString());
        });
        child.stderr.on('data', function(data) {
            process.stderr.write(data.toString());
        });
    }

    function * loadAppRoutesAndHooksAwaitable()
    {
        var appDefinition = yield appModuleStore.getAppDefinitionAwaitable();

        // See if the app dependencies require dependency update (npm install)...
        //
        if (!config.get('NO_SYNCDEPS')) // Typically set in cases where we can't modify file system in production environment
        {
            if (appDefinition.dependencies)
            {
                var currHash = util.jsonHash(appDefinition.dependencies);
                if (dependenciesHash !== currHash)
                {
                    if (!moduleStore.localFileStore) 
                    {
                        logger.info("Creating local directory and copying package.json:", containerDir);

                        // Ensure that containerDir exists
                        yield function(done){fs.mkdir(containerDir, function(err)
                        {
                            if (err && (err.code !== 'EEXIST'))
                            {
                                done(err);
                            }
                            else
                            {
                                done();
                            }
                        })};

                        // Copy appDefinition to <containerDir>/package.json
                        var packagePath = path.resolve(containerDir, "package.json");
                        fs.writeFileSync(packagePath, JSON.stringify(appDefinition), 'utf8');
                    }

                    // Run npmInstall on containerDir
                    yield function(done){npmInstall(containerDir, done)};
                    dependenciesHash = currHash;
                }
                else
                {
                    logger.debug("Processer dependencies did not change for:", appContainer);
                }
            }
            else
            {
                dependenciesHash = null;
            }
        }

        if (lodash.isArray(appDefinition.hooks))
        {
            hookModuleNames = appDefinition.hooks;
        }
        else if (lodash.isString(appDefinition.hooks))
        {
            hookModuleNames = [appDefinition.hooks];
        }
        hookModules = new Array(hookModuleNames.length);

        var moduleNames = yield appModuleStore.listModulesAwaitable();

        moduleFiles = moduleNames;

        // Since we don't know which modules might require other modules before loading, and since we can't load any
        // source asynchrounously in response to a module load via require, we have to pre-load and cache the source 
        // for all modules in the app, so the source will be present when it is required.
        //
        for (var i = 0; i < moduleNames.length; i++) 
        {
            var moduleName = moduleNames[i];
            logger.debug("Loading and caching module source:", moduleName);
            var moduleSource = yield appModuleStore.getModuleSourceAwaitable(moduleName);
            moduleSourceCache.enCacheModule(moduleName, moduleSource);
        }

        // Now we load the routes and hooks...
        //
        for (var i = 0; i < moduleNames.length; i++) 
        {
            var moduleName = moduleNames[i];
            if (isHookModulePath(moduleName) || isRouteModulePath(moduleName))
            {
                var filename = path.resolve(containerDir, moduleName);
                var synchroModule = require(filename);
                
                if (isHookModulePath(moduleName))
                {
                    var hookPath = removeFileExtension(moduleName);
                    logger.debug("Loaded hook module:", hookPath);
                    hookModules[hookModuleNames.indexOf(hookPath)] = synchroModule;
                }
                else if (isRouteModule(synchroModule))
                {
                    var routePath = path.basename(moduleName, path.extname(moduleName));
                    logger.debug("Loaded route module:", routePath);
                    routes[routePath] = synchroModule;
                }
            }
        }
        
        // The module loading should have drained the cache.  If there is a module that was not in the root directory and
        // not referenced ("required") by any other module, it could still be hanging around, so we flush the source cache.
        //
        moduleSourceCache.clear();

        return appDefinition;
    }
    
    function * callHookFunctionByIndexAwaitable(index, fnName, args)
    {
        var hookModule = hookModules[index];
        if (hookModule)
        {
            var hookFn = hookModule[fnName];
            if (hookFn)
            {
                if (coHelper.isGeneratorFunction(hookFn))
                {
                    return yield hookFn.apply(hookModule, args);
                }
                else if (hookFn)
                {
                    return hookFn.apply(hookModule, args);
                }
            }
        }
    }

    function * reloadAll()
    {
        // Delete all currently loaded modules that were loaded from this container...
        //
        for (var cachedModule in require.cache) 
        {
            if (require.cache.hasOwnProperty(cachedModule)) 
            {
                if (cachedModule.indexOf(containerDir, 0) == 0)
                {
                    logger.debug("Uncaching module: " + cachedModule);
                    delete require.cache[cachedModule];
                }
            }
        }

        // Reload all the routes (and hooks)
        //
        yield * loadAppRoutesAndHooksAwaitable();
    }

    // If appModuleStore supports watch/unwatch, let's watch...
    //
    if (appModuleStore.watch)
    {
        logger.info("Watching module store container: '%s' for changes", appContainer);
        appModuleStore.watch(function(f)
        {
            logger.info("Module store updated, reloading...");
            co(reloadAll).then(
                function()
                { 
                    logger.info("Modules reloaded"); 
                }, 
                function(err)
                {
                    logger.error("Error reloading modules:", err);
                }
            );
        });

        // If appModuleStore supports unwatching, do that on termination...
        //
        if (appModuleStore.unwatch)
        {
            function stopWatching()
            {
                // NOTE: The unwatch on the file store module takes about 15-20ms on my dev machine, and is roughly
                //       the same regardless of number of modules (tried with a single file "Hello" and with SynchroSamples
                //       and they were the same).  This call is synchronous (in the file store anyway), but we're not
                //       going to wait around for it to finish (the main SIGINT/SIGTERM are exiting the process).
                //       Not sure if this is going to cause us any heartburn on shutdown in production environments.
                //       Worst case we can turn this off with a MODULESTORE.nowatch config setting.
                //
                // !!! In future, other module stores might use other mechanisms for wacth/unwatch, such as Redis pub/sub,
                //     which might appreciate unwatch being called and waiting for it to finish.
                //
                appModuleStore.unwatch();
                logger.info("Stopped watching module store container: '%s' for changes", appContainer);
            }

            process.on('SIGINT', function ()
            {
                stopWatching();
            });

            process.on('SIGTERM', function ()
            {
                stopWatching();
            });
        }
    }

    // !!! We're going to need some mechanism to deal with modules being added/deleted from Studio, which will call in to here
    //     to refresh the state of the running API processor (presumably).
    //
    var moduleManager = 
    {
        isFunctionHooked: function (fnName)
        {
            for (var n = 0, len = hookModules.length; n < len; n++)
            {
                var hookModule = hookModules[n];
                if (hookModule)
                {
                    if (hookModule["Before" + fnName] || hookModule["After" + fnName])
                    {
                        return true;
                    }
                }
            }
            return false;
        },

        callHookFunctionAwaitable: function * (fnName)
        {
            if (fnName.indexOf('After') != 0)
            {
                for (var n = 0, len = hookModules.length; n < len; n++) // Default order is forward
                {
                    yield callHookFunctionByIndexAwaitable(n, fnName, lodash.tail(arguments)); // Remove fnName from arguments
                }
            }
            else
            {
                for (var n = hookModules.length - 1; n >= 0; n--) // If "After" function, reverse hook order
                {
                    yield callHookFunctionByIndexAwaitable(n, fnName, lodash.tail(arguments)); // Remove fnName from arguments
                }
            }
        },
        
        loadRoutesAwaitable: function * (apiProcessor)
        {
            supportModule = require('./app-services')(apiProcessor, resourceResolver);
            return yield loadAppRoutesAndHooksAwaitable();
        },

        reloadModuleAwaitable: function * (moduleName, source)
        {
            logger.debug("Reload module: ", moduleName);

            if (source)
            {
                yield appModuleStore.putModuleSourceAwaitable(moduleName, source);
            }

            // NOTE: There's no easy way to figure out which other modules might be impacted by the change to the
            //       module being reloaded, so we're just going to clean up the whole Synchro app and reload it.

            // Reload all the routes (and hooks)
            //
            try
            {
                yield * reloadAll();
            }
            catch (err)
            {
                logger.error("Caught err on loading routes: ", err);
                return { error: err.message };
            }

            return true;
        },

        getModule: function(routePath)
        {
            return routes[routePath];
        }
    }

    return moduleManager;
}
