// This is the PkgCloud-based module store. 
//
var path = require('path');
var lodash = require('lodash');
var co = require('co');
var util = require('./util');

var pkgcloud = require('pkgcloud');

var logger = require('log4js').getLogger("pkgcloud-module-store");

// Note: Since some pkgcloud storage back-ends (maybe all?) don't support the concept of top-level / root files, we
//       will need to specify a container to be used to hold these top-level config files.  This container should
//       already exist and should be specified in the "configRoot" key in the module store params config.
// 
exports.createServiceAwaitable = function * (params)
{
    logger.debug("Using PkgCloud module store, provider:", params.provider);

    var client = pkgcloud.storage.createClient(params);
    var configRoot = params.configRoot;

    function * doesContainerExistAwaitable(containerName)
    {
        try
        {
            yield function(done) { client.getContainer(containerName, done) }   
            return true;
        }
        catch (err)
        {
            // If error anything other than 404 (not found), rethrow
            if (err.statusCode != 404)
            {
                throw err;
            }
        }

        return false;
    }

    function * doesBlobExistAwaitable(containerName, blobName)
    {
        try
        {
            var file = yield function(done) { client.getFile(containerName, blobName, done) }            
            if (file)
            {
                return true;
            }
        }
        catch (err)
        {
            // If error anything other than 404 (not found), rethrow
            if (err.statusCode != 404)
            {
                throw err;
            }
        }

        return false;
    }

    function * getBlobTextAwaitable(containerName, blobName)
    {
        var options = {
            container: containerName,
            remote: blobName
        };

        // !!! Ideally we would just handle errors on the stream and not use the callback form of client.download().  Unfortunately,
        //     pkgcloud only returns transport-specific logical errors via the callback.  For example, at the Request level, Azure
        //     actually returns an XML payload explaining that the contents doesn't exist, and the pkgcloud driver converts that to
        //     an error and provides it to the callback (but it does not send that to the "error" event on the stream).
        //
        return yield function(done)
        { 
            var content = null;
            var stream = client.download(options, function(err, res)
            {
                if (err)
                {
                    if (err.statusCode == 404)
                    {
                        // Return null if file doesn't exist
                        return done(null, null);
                    }
                    else
                    {
                        done(err);
                    }
                }
                else
                {
                    // content = util.removeBOM(content);
                    done(null, content);
                }
            });

            const chunks = [];
            stream.on('data', (chunk) => {
                chunks.push(chunk);
            });
            stream.on('end', () => {
                // content = chunks.join('');
                content = Buffer.concat(chunks);
            });
        }
    }

    function * setBlobTextAwaitable(containerName, blobName, text)
    {
        var options = {
            container: containerName,
            remote: blobName
        };

        yield new Promise(function(resolve, reject)
        {
            var stream = client.upload(options);

            stream.on('error', function (err) 
            {
                logger.error("Error uploading container: %s, blob: %s: %s", containerName, blobName, err);
                reject(err);
            });

            stream.on('success', function (file) 
            { 
                logger.debug("Done uploading container: %s, blob: %s: %s", containerName, blobName, file);
                resolve();
            });

            stream.write(text, function(err, res) 
            {
                if (err)
                {
                    logger.error("Error writing to upload stream - container: %s, blob: %s: %s", containerName, blobName, err);
                    reject(err);
                }
                else
                {
                    logger.debug("Finished writing blob to stream - container: %s, blob: %s", containerName, blobName);
                    stream.end();
                }
            });
        });
    }

    function * removeBlobAwaitable(containerName, blobName)
    {
        yield function(done) { client.removeFile(containerName, blobName, done) }
    }

    function * getAppDefinitionAwaitable(containerName)
    {
        if (containerName)
        {
            if (yield doesBlobExistAwaitable(containerName, "package.json"))           
            {
                logger.debug("Downloading package.json");
                var content = yield getBlobTextAwaitable(containerName, "package.json");
                return JSON.parse(content);
            }
            else
            {
                // Defined behavior is return null if no appDefinition...
                return null;
            }
        }
        else
        {
            logger.error("getAppDefinition failed - no container provided");
            return null;
        }
    }

    function isSynchroApp(appDefinition)
    {
        return !!(appDefinition && appDefinition.engines["synchro"]);
    }

    var moduleStore = 
    {
        getStoreFileAwaitable: function * (filename)
        {
            return yield getBlobTextAwaitable(configRoot, filename);
        },

        putStoreFileAwaitable: function * (filename, content)
        {
            yield setBlobTextAwaitable(configRoot, filename, content);
        },

        getAppContainersAwaitable: function * ()
        {
            // Get all containers/directories that contain a package.json file which itself indicates it is for a Synchro app...
            //
            var containers = yield function(done) { client.getContainers(done) }

            var synchroAppContainers = [];
            for (var i = 0; i < containers.length; i++)
            {
                var appDefinition = yield getAppDefinitionAwaitable(containers[i].name);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        synchroAppContainers.push(containers[i].name);
                    }
                }
            }

            return synchroAppContainers;
        },

        createAppContainerAwaitable: function * (containerName)
        {
            if (yield doesContainerExistAwaitable(containerName))
            {
                // Container already existed
                //
                var appDefinition = yield getAppDefinitionAwaitable(containerName);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        // A Synchro app already exists in this directory...
                        //
                        throw new Error("A Synchro application already exists in the container: '" + containerName + "'");
                    }
                    else
                    {
                        // A package.json was found, but not one for a Synchro app...
                        //
                        throw new Error("The container: '" + containerName + "' is already in use by a Node package, but not by a Synchro application"); 
                    }
                }
                else
                {
                    // The directory name is in use, but not by an existing Synchro app...
                    //
                    throw new Error("The container: '" + containerName + "' is already in use, but not by a Synchro application");
                }
            }
            else
            {
                // Create container
                //
                logger.debug("Creating container:", containerName);
                var container = yield function(done) { client.createContainer(containerName, done) }

                // Create a package.json blob with empty-ish JSON contents...
                //
                var packageJson = { engines: { "synchro": "*"} };
                yield setBlobTextAwaitable(containerName, "package.json", JSON.stringify(packageJson));
            }
        },

        deleteAppContainerAwaitable: function * (containerName)
        {
            if (yield doesContainerExistAwaitable(containerName))
            {
                var appDefinition = yield getAppDefinitionAwaitable(containerName);
                if (appDefinition)
                {
                    if (isSynchroApp(appDefinition))
                    {
                        // A Synchro app exists in this container, so we can delete it...
                        //
                        yield function(done) { client.destroyContainer(containerName, done) }
                    }
                    else
                    {
                        // A package.json was found, but not one for a Synchro app...
                        //
                        throw new Error("The container: '" + containerName + "' is in use by a Node package, not by a Synchro application, so it can't be deleted");
                    }
                }
                else
                {
                    // The directory exists, but does not contain a Synchro app, so we can't delete it...
                    //
                    throw new Error("The container: '" + containerName + "' is in use, but not by a Synchro application, so it can't be deleted");
                }
            }
            else
            {
                // The container doesn't exist...
                //
                throw new Error("The container: '" + containerName + "' does not exist");
            }
        },

        getAppModuleStoreAwaitable: function * (containerName)
        {
            var containerName = containerName;

            if (yield doesContainerExistAwaitable(containerName))
            {
                var appDefinition = yield getAppDefinitionAwaitable(containerName);
                if (!appDefinition || !isSynchroApp(appDefinition))
                {
                    // The directory exists, but does not contain a Synchro app...
                    //
                    throw new Error("The container: '" + containerName + "' is in use, but not by a Synchro application");
                }
            }
            else
            {
                // The container doesn't exist...
                //
                throw new Error("The container: '" + containerName + "' does not exist");
            }

            var app =
            {
                getAppDefinitionAwaitable: function * ()
                {
                    return yield getAppDefinitionAwaitable(containerName);
                },

                listModulesAwaitable: function * ()
                {
                    var modules = yield function(done) { client.getFiles(containerName, done) }

                    // client.getFiles is documented to take a callback of type callback(err, files), which is compatible with
                    // our yield (via CO).  With some providers, they like to be a smartass and pass back additional elements
                    // to the callback, which causes our co/yield to put them into an array and return then (instead of returning
                    // the array of files).  We detect that below and promote the actual files array into modules as appropriate.
                    //
                    if (modules && Array.isArray(modules) && (modules.length > 0) && Array.isArray(modules[0]))
                    {
                        modules = modules[0];
                    }

                    var files = lodash.map(modules, "name");
                    lodash.remove(files, function(file)
                    {
                        return (!file || (file.indexOf('node_modules/') == 0) || (path.extname(file) !== ".js")); 
                    });

                    return files;
                },

                getModuleSourceAwaitable: function * (moduleFilename)
                {
                	return yield getBlobTextAwaitable(containerName, moduleFilename);
                },

                putModuleSourceAwaitable: function * (moduleFilename, content)
                {
                	return yield setBlobTextAwaitable(containerName, moduleFilename, content);
                },

                removeModuleSourceAwaitable: function * (moduleFilename)
                {
                	return yield removeBlobAwaitable(containerName, moduleFilename);
                }
            }

            return app;
        }
    }

    return moduleStore;
}
