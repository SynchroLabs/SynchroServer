// API request processor - process API requests
//
// Note: This module and the objects it returns may be called in-proc or cross-process, as documented below.
//
var synchroApi = require('../index'); // This is our own 'synchro-api' module
var co = require('co');

var ReaderWriter = require("../lib/reader-writer");

var logger = require('log4js').getLogger("api-request-processor");
var protocolLogger = require('log4js').getLogger("protocol");

var SynchroApiSessionIdHeader = "synchro-api-session-id";

exports.createApiRequestProcessorAsyncAwaitable = function * (appPath, config, callback)
{
    logger.debug("Initializing API request processor");
    
    // First check to see if we have an app-specific resource prefix...
    //
    var resourcePrefix = config.get('APPS:' + appPath + ':APP_RESOURCE_PREFIX');
    if (!resourcePrefix)
    {
        // If no app-specific prefix, look for system-wide resource prefix...
        //
        resourcePrefix = config.get('APP_RESOURCE_PREFIX');
    }
    if (!resourcePrefix)
    {
        // If no resource prefix specified, construct one assuming built-in static resource router...
        //
        resourcePrefix = config.get('API_URL_BASE') + '/' + appPath + '/resources/';
    }

    logger.debug("Resource Prefix for app: %s is %s", appPath, resourcePrefix);

    var resourceResolverSpec =
    { 
        packageRequirePath: 'synchro-api', 
        serviceName: 'ResourceResolver',
        serviceConfiguration: 
        {
            prefix: resourcePrefix
        }
    }

    var sessionStore = synchroApi.createSessionStore(config);
    var moduleStore = synchroApi.createModuleStore(config);
    var resourceResolver = synchroApi.createServiceFromSpec(resourceResolverSpec);
    
    var appContainer = config.get('APPS')[appPath].container;

    var moduleManager = yield require('./module-manager')(moduleStore, config.get("APP_ROOT_PATH"), appContainer, resourceResolver);
    var readerWriter = new ReaderWriter();

    var ApiProcessor = require('./api');
    var api = new ApiProcessor(config, appPath, moduleManager, sessionStore, readerWriter);
    logger.debug("Loading API request processor");
    yield api.loadAwaitable();
    logger.info("API request processor for app container: %s at path: %s - ready", appContainer, appPath);

    function * apiProcessAwaitable (session, request, response)
    {
        return yield api.processAwaitable(session, request, response); 
    }

    // This http request processor is always running in a fiber.  If this module is processing requests as a forked
    // process, the request will have been JSON serialized, and the err and data returned must be JSON serializable.
    //
    function * internalProcessHttpRequestAwaitable (request, callback)
    {
        var requestObject = request.body;
        logger.debug("API Processing http request - mode: " + requestObject.Mode);

        // See if this is an AppDefinition request and process appropriately (it doesn't want/need session state)
        //
        if (requestObject.Mode === "AppDefinition")
        {
            var appDefinition = 
            {
                App: api.getAppDefinition()
            }
            protocolLogger.debug("AppDefinition request: " + JSON.stringify(requestObject, null, 4));
            protocolLogger.debug("AppDefinition response: " + JSON.stringify(appDefinition, null, 4));
            callback(null, appDefinition);
            return;
        }

        var responseObject = {};

        var session = null;
        var sessionId = request.headers[SynchroApiSessionIdHeader];
        if (sessionId)
        {
            logger.debug("API request session ID: " + sessionId);
            session = yield sessionStore.getSessionAwaitable(sessionId);
        }

        if (!session)
        {
            logger.debug("Creating new session");
            session = yield sessionStore.createSessionAwaitable();
            responseObject.NewSessionId = session.id;

            if (sessionId && !requestObject.DeviceMetrics)
            {
                // The client sent a session ID, but we couldn't find a cooresponding server session.  Note that
                // if the client also send DeviceMetrics then they are running a fresh execution and a resync is
                // not required.
                //
                // With the dev session store this happens when the server is restarted during a client session.
                // When using a real (persistent) session store, this should not happen under normal circumstances
                // (though it could if asession got purged / dumped due to timeout or some LRU logic, depending on
                // the session store being used).
                //
                // The problem is that since the session is lost, not only are the client and server out of sync, but
                // we no longer have any device or view metrics (including, but not limited to, client name and version).
                //
                // So our solution is to signal the client that they need to restart the app (which we do by returning
                // a SyncError with no InstanceId).
                //
                responseObject.Error = 
                {
                    name: "SyncError",
                    message: "The client provided a session ID, but the server could not find a corresponding session - restart required"
                };
                logger.error("Server session not found, signalling client reset");
                callback(null, responseObject);
                return;
            }
        }
        
        var channelId = session.id + ":" + requestObject.TransactionId;

        if (requestObject.Mode === "Page")
        {
            // This is the "app start" request (the only time you request a "Page" is on the initial/main page - all other 
            // page responses are triggered by server-side navigation).

            // Since this is a new instantiation of this app, we are going to increment the instanceId here to protect this
            // request from any state associated with any previous instantation.  The instanceId will get incremented again
            // when building the new page response, so this instanceId won't actually be used.
            // 
            // One of the things that this protects us from is async responses directed at the session's previous instanceId 
            // If those async loops are calling Synchro.isActiveInstance(), this change of the instanceId will cause that to
            // eval to false and the async interimUpdate loop to stop.
            //
            if (session.ModuleInstance && session.ModuleInstance.instanceId)
            {
                logger.info("Incrementing module instance");
                session.ModuleInstance.instanceId++;
            }

            // There may be pending reads or writes from a previous abandoned execution of this app
            // 
            readerWriter.cancelAll(session.id);
        }

        logger.debug("Posting read for session:sequence - " + channelId);

        // When a client abandons the server it is possible that they could leave pending reads or writes.  Any pending writes
        // that are actively serviced (by looping interimUpdate user code), will time out and terminate after 30 seconds based
        // on per-channel timeout handling where the writes are posted.
        //
        // But pending reads (abandoned by the client) or final pending writes, will potentially back up.  Here we clean out
        // any pending reads more than 5 minutes old and any pending writes more than 60 seconds old.  The purgeAll will only
        // do the purge if it's been at least a minutes since the last time it has been called. 
        //
        readerWriter.purgeAll(5 * 60 * 1000, 60 * 1000);

        // Note: The yield below will not necessarily yield until the read callback is satisfied.  If a corresponding
        //       write is pending, then this will yield until the write is completed (which includes writing to the
        //       reader).  However, if no corresponding write is pending, then this call will return after the read is
        //       posted (the actual read callback will be called asynchronously to this code path when the write is
        //       ready).
        //
        yield readerWriter.readAsyncAwaitable(channelId, function * (err, responseObject) // Genertor (passed callback)
        {
            if (err)
            {
                logger.error("readAsync err: " + err);
            }

            callback(err, responseObject);
        });

        if (requestObject.Mode !== "Continue")
        {
            yield apiProcessAwaitable(session, requestObject, responseObject);
        }
    }

    // Public API functions may be called either in-proc or cross-process.
    //
    var publicApi =
    {
        processHttpRequest: function(request, callback)
        {
            logger.debug("Launching API http request processor on a fiber...");
            co(internalProcessHttpRequestAwaitable, request, callback).catch(function(err)
            {
                logger.error("Error in internal http process request:", err);
            });;
        },

        reloadModuleAwaitable: function * (moduleName)
        {
            logger.debug("API reloading module: " + moduleName);
            return yield api.reloadModuleAwaitable(moduleName);
        },

        healthCheck: function * ()
        {
            // !!! This is basically just to make sure the main app can talk to the processor.  Should we do more than this?
            //
            logger.info("Checking health for:", appPath);
            return true;
        }
    }

    return publicApi;
}

// Always called in-proc
//
// If this module is processing requests on behalf of a forked process, then this post-processor will be called
// from the parent process, meaning that any "err" or "data" will have been JSON serialized (in order to get back
// to the parent process on completion).  
//
// This post-processor will also not be called in a fiber when it is post-processing a request handled by a forked
// process, so it must execute synchronously.
//
// On the plus side, the request and response objects are always the actual objects (not stripped down and/or JSON
// serialized versions).
// 
exports.postProcessHttpRequest = function(request, response, err, data)
{
    // Do the least amount of work possible to convert the provided err/data into a response...
    //
    if (response.socket)
    {
        response.socket.setNoDelay(true);        
    }
    response.send(data);
}
