// API request processor - process API requests
//
// Note: This module and the objects it returns may be called in-proc or cross-process, as documented below.
//
var synchroApi = require('../index'); // This is our own 'synchro-api' module
var wait = require('wait.for');

var ReaderWriter = require("../lib/reader-writer");

var logger = require('log4js').getLogger("api-request-processor");
var protocolLogger = require('log4js').getLogger("protocol");

var SynchroApiSessionIdHeader = "synchro-api-session-id";

exports.createApiRequestProcessorAsync = function(appPath, config, callback)
{
    logger.debug("Initializing API request processor");
    
    var sessionStoreSpec = 
    {
        packageRequirePath: config.get('SESSIONSTORE_PACKAGE'),
        serviceName: config.get('SESSIONSTORE_SERVICE'),
        serviceConfiguration: config.get('SESSIONSTORE')
    }

    var moduleStoreSpec =
    {
        packageRequirePath: config.get('MODULESTORE_PACKAGE'),
        serviceName: config.get('MODULESTORE_SERVICE'),
        serviceConfiguration: config.get('MODULESTORE')
    }
    
    var resourceResolverSpec =
    { 
        packageRequirePath: 'synchro-api', 
        serviceName: 'ResourceResolver',
        serviceConfiguration: 
        {
            prefix: config.get('APP_RESOURCE_PREFIX')
        }
    }

    var sessionStore = synchroApi.createServiceFromSpec(sessionStoreSpec);
    var moduleStore = synchroApi.createServiceFromSpec(moduleStoreSpec);
    var resourceResolver = synchroApi.createServiceFromSpec(resourceResolverSpec);
    
    var appContainer = config.get('APPS')[appPath].container;

    var moduleManager = require('./module-manager')(moduleStore, config.get("APP_ROOT_PATH"), appContainer, resourceResolver);
    var readerWriter = new ReaderWriter();

    var ApiProcessor = require('./api');
    var api = new ApiProcessor(config, appPath, moduleManager, sessionStore, readerWriter);
    logger.debug("Loading API request processor");
    api.load();
    logger.info("API request processor for app container: %s at path: %s - ready", appContainer, appPath);

    function apiProcess(session, request, response)
    {
        return api.process(session, request, response);
    }

    // This http request processor is always running in a fiber.  If this module is processing requests as a forked
    // process, the request will have been JSON serialized, and the err and data returned must be JSON serializable.
    //
    function internalProcessHttpRequest(request, callback)
    {
        var requestObject = request.body;
        logger.debug("API Processing http request - mode: " + requestObject.Mode);

        // See if this is an AppDefinition request and process appropriately (it doesn't want/need session state)
        //
        if (requestObject.Mode === "AppDefinition")
        {
            var appDefinition = 
            {
                App: api.getAppDefinition()
            }
            protocolLogger.debug("AppDefinition request: " + JSON.stringify(requestObject, null, 4));
            protocolLogger.debug("AppDefinition response: " + JSON.stringify(appDefinition, null, 4));
            callback(null, appDefinition);
            return;
        }

        var responseObject = {};

        var session = null;
        var sessionId = request.headers[SynchroApiSessionIdHeader];
        if (sessionId)
        {
            logger.debug("API request session ID: " + sessionId);
            session = sessionStore.getSession(sessionId);
        }

        if (!session)
        {
            logger.debug("Creating new session");
            session = sessionStore.createSession();
            responseObject.NewSessionId = session.id;

            if (sessionId && !requestObject.DeviceMetrics)
            {
                // The client sent a session ID, but we couldn't find a cooresponding server session.  Note that
                // if the client also send DeviceMetrics then they are running a fresh execution and a resync is
                // not required.
                //
                // With the dev session store this happens when the server is restarted during a client session.
                // When using a real (persistent) session store, this should not happen under normal circumstances
                // (though it could if asession got purged / dumped due to timeout or some LRU logic, depending on
                // the session store being used).
                //
                // The problem is that since the session is lost, not only are the client and server out of sync, but
                // we no longer have any device or view metrics (including, but not limited to, client name and version).
                //
                // So our solution is to signal the client that they need to restart the app (which we do by returning
                // a SyncError with no InstanceId).
                //
                responseObject.Error = 
                {
                    name: "SyncError",
                    message: "The client provided a session ID, but the server could not find a corresponding session - restart required"
                };
                logger.error("Server session not found, signalling client reset");
                callback(null, responseObject);
                return;
            }
        }
        
        var channelId = session.id + ":" + requestObject.TransactionId;
        logger.debug("Posting read for session:sequence - " + channelId);
        readerWriter.readAsync(channelId, function(err, responseObject)
        {
            if (err)
            {
                logger.error("readAsync err: " + err);
            }

            callback(err, responseObject);
        });

        if (requestObject.Mode !== "Continue")
        {
            apiProcess(session, requestObject, responseObject);
        }
    }

    // Public API functions may be called either in-proc or cross-process.
    //
    var publicApi =
    {
        processHttpRequest: function(request, callback)
        {
            logger.debug("Launching API http request processor on a fiber...");
            wait.launchFiber(internalProcessHttpRequest, request, callback); //handle in a fiber
        },

        // Module reloader (always already running in a fiber)
        //
        reloadModule: function(moduleName)
        {
            logger.debug("API reloading module: " + moduleName);
            return api.reloadModule(moduleName);
        }
    }

    return publicApi;
}

// Always called in-proc
//
// If this module is processing requests on behalf of a forked process, then this post-processor will be called
// from the parent process, meaning that any "err" or "data" will have been JSON serialized (in order to get back
// to the parent process on completion).  
//
// This post-processor will also not be called in a fiber when it is post-processing a request handled by a forked
// process, so it must execute synchronously.
//
// On the plus side, the request and response objects are always the actual objects (not stripped down and/or JSON
// serialized versions).
// 
exports.postProcessHttpRequest = function(request, response, err, data)
{
    // Do the least amount of work possible to convert the provided err/data into a response...
    //
    if (response.socket)
    {
        response.socket.setNoDelay(true);        
    }
    response.send(data);
}
