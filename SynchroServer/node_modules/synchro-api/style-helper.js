// Style helper
//
var lodash = require("lodash");

// Add the default style cooresponding the "control" attribute value, if any, to the "style" attribute value
// (defaultStyle is a dictionary of controlName : defaultStyle values)
//
function addDefaultStyle(defaultStyles, obj)
{
    lodash.forIn(obj, function (val, key) 
    {
        if (key == "control")
        {
            var defaultStyle = defaultStyles[val];
            if (defaultStyle)
            {
                if (obj["style"])
                {
                    if (!lodash.includes(obj["style"].split(/[ ,]+/), defaultStyle))
                    {
                        // Append default style to list of styles (it's not already in the list)
                        obj["style"] += "," + defaultStyle;
                    }
                }
                else
                {
                    // Set style to default style
                    obj["style"] = defaultStyle;
                }
            }
        }

        if (lodash.isArray(val)) 
        {
            val.forEach(function(el) 
            {
                if (lodash.isObject(el)) 
                {
                    addDefaultStyle(defaultStyles, el);
                }
            });
        }
        else if (lodash.isObject(obj[key])) 
        {
            addDefaultStyle(defaultStyles, obj[key]);
        }
    }); 
}

// Push the item or items (if array) that are not already in array
//
Array.prototype.pushUnique = function(item)
{
    var theArray = this;

    if (lodash.isArray(item))
    {
        item.forEach(function(arrItem) 
        {
            if (!lodash.includes(theArray, arrItem)) 
            {
                theArray.push(arrItem);
            }
        });
    }
    else if (!lodash.includes(theArray, item)) 
    {
        theArray.push(item);
    }
}

// Get style values referenced in obj and append to referencedStyles (unique)
//
function getReferencedStyles(referencedStyles, obj)
{
    lodash.forIn(obj, function (val, key) 
    {
        if (key == "style")
        {
            referencedStyles.pushUnique(val.split(/[ ,]+/));
        }

        if (lodash.isArray(val)) 
        {
            val.forEach(function(el) 
            {
                if (lodash.isObject(el)) 
                {
                    getReferencedStyles(referencedStyles, el);
                }
            });
        }
        else if (lodash.isObject(obj[key])) 
        {
            getReferencedStyles(referencedStyles, obj[key]);
        }
    }); 
}

// JSON representations of filtering by OS (iOS, Android, Windows, WinPhone)
//
/*
os_value: { iOS: 14, Android: 12, default: 10 }

os_merge: 
{ 
    iOS: 
    { 
        foreground: "Blue" 
    },
    Windows:
    { 
        foreground: "Blue" 
        background: "Black" 
    },
    default:
    {
        foreground: "Green" 
    }
}
*/
function processObjectFilters(deviceMetrics, obj) 
{
    lodash.forIn(obj, function (val, key) 
    {
        if (lodash.isArray(val)) 
        {
            val.forEach(function(el) 
            {
                if (lodash.isObject(el)) 
                {
                    processObjectFilters(deviceMetrics, el);
                }
            });
        }
        else if (lodash.isObject(obj[key])) 
        {
            if (obj[key]["os_value"])
            {
                if (obj[key]["os_value"][deviceMetrics.osName])
                {
                    obj[key] = obj[key]["os_value"][deviceMetrics.osName];
                }
                else if (obj[key]["os_value"]["default"])
                {
                    obj[key] = obj[key]["os_value"]["default"];
                }
                return;
            }
            if (obj[key]["os_merge"])
            {
                if (obj[key]["os_merge"][deviceMetrics.osName])
                {
                    lodash.merge(obj[key], obj[key]["os_merge"][deviceMetrics.osName]);
                    delete obj[key]["os_merge"];
                }
                else if (obj[key]["os_merge"]["default"])
                {
                    lodash.merge(obj[key], obj[key]["os_merge"]["default"]);
                    delete obj[key]["os_merge"];
                }
            }

            processObjectFilters(deviceMetrics, obj[key]);
        }
    });
}

// Given a view, visit each control element, and if there is a default style mapping cooresponding to the control name,
// add the default style to the control (if any styles are defined on the control, add to end of list, else create new
// style attribute and set it to the default style).  The passed-in view is modified in place.
//
exports.addDefaultStylesToView = function(view, defaultStyleMapping)
{
    addDefaultStyle(defaultStyleMapping, view);
}

// Merges the provided app-level styles into the viewModel (in place).  You may specify which of the provided styles are to
// be merged via with "viewOrList" parameter:
//
//     If "viewOrList" is undefined (not provided in call) or null, all app styles will be merged.
//     If "viewOrList" is an object (typically a View), then all styles referenced by the object will be merged.
//     If "viewOrList" is an array, then the app styles matching elements of the array will be merged.  If the 
//     array is empty, then of course no app styles will be merged.
//
// Individual settings for styles defined in the viewModel will override any cooresponding app style settings.
//
exports.mergeStyles = function(viewModel, appStyles, viewOrList)
{
    var result = {};

    if (!viewOrList) // Undefined/null styles param, include all styles...
    {
        // When we copy from the passed in styles we must copy by value, not by reference (since they will end up in
        // the viewModel and could be modified there).
        //
        result = lodash.cloneDeep(appStyles);
    }
    else // Specific styles from view or list...
    {
        var includeStyles = viewOrList;
        if (!lodash.isArray(viewOrList) && lodash.isObject(viewOrList))
        {
            // viewOrList is a view, determine which styles it references... 
            //
            includeStyles = [];
            getReferencedStyles(includeStyles, viewOrList);
        }

        lodash.forIn(appStyles, function(val, key)
        {
            if (lodash.includes(includeStyles, key))
            {
                // When we copy from the passed in styles we must copy by value, not by reference (since they will end up in
                // the viewModel and could be modified there).
                //
                result[key] = lodash.cloneDeep(appStyles[key]);
            }
        });     
    }

    // Merge our viewModel into the result (viewModel values will override app-level styles)
    //
    lodash.merge(result, viewModel);
 
    // Assign the result back to the viewModel (to update it in place)
    lodash.assign(viewModel, result);
}

// Apply filters to the supplied viewModel (in place)
//
exports.filterStyles = function(viewModel, deviceMetrics)
{
    processObjectFilters(deviceMetrics, viewModel);
}

// Do all app style processing in on place - typically called from InitializeView
//
exports.processViewAndViewModelStyles = function(viewModel, view, metrics, defaultStyleMapping, appStyles)
{
    if (view && defaultStyleMapping)
    {
        addDefaultStyle(defaultStyleMapping, view);
    }

    if (viewModel && appStyles)
    {
        exports.mergeStyles(viewModel, appStyles, view);
    }

    if (viewModel && metrics)
    {
        processObjectFilters(metrics.DeviceMetrics, viewModel);
    }
}
