// Synchro API module
//
var logger = require('log4js').getLogger("synchro-api");

// For the Synchro "services" (session store, module store, and resource resolver), since the API processor
// may be a forked process we cannot pass these services as modules or live objects (since those can't be
// sent as process creation parameters or via IPC).  The forked process needs to load these services itself.  
// To accomodate this, we indicate these services by specification, which looks like this:
//
//    var serviceSpec = 
//    {
//        packageRequirePath = path.resolve('./synchro-module-providing-service'),
//        serviceName = NameOfTheService,
//        serviceConfiguration = { ... appropriate configuration object ... }
//    }
//
// The method below is used internally by Synchro modules (the API processor and any other modules that need
// these) to create services from a specification...
//
exports.createServiceFromSpecAwaitable = function * (serviceSpec)
{
    var serviceModule = require(serviceSpec.packageRequirePath);
    if (serviceModule)
    {
        return yield serviceModule.createServiceAwaitable(serviceSpec.serviceName, serviceSpec.serviceConfiguration);
    }
}

exports.createSessionStoreAwaitable = function * (config)
{
    var sessionStoreSpec = 
    {
        packageRequirePath: config.get('SESSIONSTORE_PACKAGE'),
        serviceName: config.get('SESSIONSTORE_SERVICE'),
        serviceConfiguration: config.get('SESSIONSTORE')
    }

    return yield exports.createServiceFromSpecAwaitable(sessionStoreSpec);
}

exports.createModuleStoreAwaitable = function * (config)
{
    var moduleStoreSpec =
    {
        packageRequirePath: config.get('MODULESTORE_PACKAGE'),
        serviceName: config.get('MODULESTORE_SERVICE'),
        serviceConfiguration: config.get('MODULESTORE')
    }

    return yield exports.createServiceFromSpecAwaitable(moduleStoreSpec);
}

exports.createApiProcessorManager = function(baseDebugPort, config)
{
    logger.debug("Creating API manager with base debug port: " + baseDebugPort);
    var currentDebugPort = baseDebugPort;

    var apiProcessors = {}; // indexed by path
    var moduleStores = {};  // indexed by path

    var apiManager =
    {
        createApiProcessorAwaitable: function * (appPath, runForked, enableDebug)
        {
            if (apiProcessors[appPath])
            {
                logger.info("An API processor already exists for path: " + appPath);
                return;
            }

            var debugPort = 0; // No debugging
            if (enableDebug)
            {
                debugPort = currentDebugPort++;
                logger.info("Creating API processor for app at path: " + appPath + ", debug port is: " + debugPort);
            }
            else
            {
                logger.info("Creating API processor for app at path: " + appPath);
            }

            var apiProcessor = yield require("./lib/api-request-delegator")(appPath, config, runForked, debugPort);
            apiProcessors[appPath] = apiProcessor;
            return apiProcessor;
        },

        getApiProcessor: function(appPath)
        {
            logger.debug("Getting API processor for appPath: " + appPath);
            return apiProcessors[appPath];
        },
        
        createModuleStoreAwaitable: function * ()
        {
            return yield exports.createModuleStoreAwaitable(config);
        },

        getAppModuleStoreAwaitable: function * (appPath, appContainer) // Generator
        {
            // Create a module store from a full configuration and cache it in case we need it later (or in case someone
            // calling getAppModuleStoreForPath (below) needs it...
            //
            if (!moduleStores[appPath])
            {
                var moduleStore = yield this.createModuleStoreAwaitable();
                moduleStores[appPath] = yield moduleStore.getAppModuleStoreAwaitable(appContainer);
            }

            return moduleStores[appPath];
        },

        getAppModuleStoreForPathAwaitable: function * (appPath) // Generator
        {
            // The apiProcessor has it's own module store instance, but since the apiProcessor may be running in a different
            // process, we don't have access to it.  There are cases where the main Node / web process (particularly when 
            // serving the the web site for the Synchro "studio" application) needs a module store using the same configuration
            // information.  We lazily create and then cache any referenced module stores for our own use.
            //
            if (!moduleStores[appPath])
            {
                var apiProcessor = apiProcessors[appPath];
                if (apiProcessor)
                {
                    yield this.getAppModuleStoreAwaitable(appPath, apiProcessor.appContainer);
                }
                else
                {
                    // There was no chached module store for this path, and there was no API processor for this
                    // path which we could have used to create a module store.
                    //
                    logger.error("No API processor for path: " + appPath + " is available to create module store");
                    return null;
                }
            }
            
            return moduleStores[appPath];
        },

        getApiProcessors: function()
        {
            return apiProcessors;
        },

        processHttpRequest: function(appPath, request, response)
        {
            logger.debug("Processing http request for appPath: " + appPath);
            var apiProcessor = apiProcessors[appPath];
            if (apiProcessor)
            {
                apiProcessor.processHttpRequest(request, response);
            }
            else
            {
                logger.error("No API processor for path:", appPath);
                response.status(404).send("No API processors for path: " + appPath);
            }
        },
    }

    return apiManager;
}

// By loading these here instead of inside createService below, any errors are caught on startup and have 
// usable stack traces.
//
var stashboxModuleStore = require('./lib/stashbox-module-store');
var fileModuleStore = require('./lib/file-module-store');
var mantaModuleStore = require('./lib/manta-module-store');
var memorySessionStore = require('./lib/session-store');
var fileSessionStore = require('./lib/file-session-store');
var pkgCloudModuleStore = require('./lib/pkgcloud-module-store');
var redisSessionStore = require('./lib/redis-session-store');
var ioRedisSessionStore = require('./lib/ioredis-session-store');
var resourceResolver = require('./lib/resource-resolver');

exports.createServiceAwaitable = function * (serviceName, serviceConfiguration)
{
    var service;

    switch (serviceName)
    {
        case "StashboxModuleStore":
        {
            service = yield stashboxModuleStore.createServiceAwaitable(serviceConfiguration);
        }
        break;

        case "FileModuleStore":
        {
            service = yield fileModuleStore.createServiceAwaitable(serviceConfiguration);
        }
        break;

        case "MantaModuleStore":
        {
            service = yield mantaModuleStore.createServiceAwaitable(serviceConfiguration);
        }
        break;

        case "MemorySessionStore":
        {
            service = yield memorySessionStore.createServiceAwaitable(serviceConfiguration);
        }
        break;

        case "FileSessionStore":
        {
            service = yield fileSessionStore.createServiceAwaitable(serviceConfiguration);
        }
        break;

        case "PkgCloudModuleStore":
        {
            service = yield pkgCloudModuleStore.createServiceAwaitable(serviceConfiguration);
        }
        break;

        case "RedisSessionStore":
        {
            service = yield redisSessionStore.createServiceAwaitable(serviceConfiguration);
        }
        break;

        case "IoRedisSessionStore":
        {
            service = yield ioRedisSessionStore.createServiceAwaitable(serviceConfiguration);
        }
        break;

        case "ResourceResolver":
        {
            service = yield resourceResolver.createServiceAwaitable(serviceConfiguration);
        }
        break;
    }

    return service;
}
