// Synchro API module
//
var logger = require('log4js').getLogger("synchro-api");

// For the Synchro "services" (session store, module store, and resource resolver), since the API processor
// may be a forked process we cannot pass these services as modules or live objects (since those can't be
// sent as process creation parameters or via IPC).  The forked process needs to load these services itself.  
// To accomodate this, we indicate these services by specification, which looks like this:
//
//    var serviceSpec = 
//    {
//        packageRequirePath = path.resolve('./synchro-module-providing-service'),
//        serviceName = NameOfTheService,
//        serviceConfiguration = { ... appropriate configuration object ... }
//    }
//
// The method below is used internally by Synchro modules (the API processor and any other modules that need
// these) to create services from a specification...
//
exports.createServiceFromSpec = function(serviceSpec)
{
    var serviceModule = require(serviceSpec.packageRequirePath);
    if (serviceModule)
    {
        return serviceModule.createService(serviceSpec.serviceName, serviceSpec.serviceConfiguration);
    }
}

exports.createApiProcessorManager = function(baseDebugPort, loggingConfig)
{
    logger.debug("Creating API manager with base debug port: " + baseDebugPort);
    var currentDebugPort = baseDebugPort;

    var apiProcessors = {}; // indexed by path
    var moduleStores = {};  // indexed by path

    var apiManager =
    {
		createApiProcessorAsync: function(appPath, appContainer, services, runForked, enableDebug, onCompleted)
    	{
            if (apiProcessors[appPath])
            {
                onCompleted("An API processor already exists for path: " + appPath);
                return;
            }

            var debugPort = 0; // No debugging
            if (enableDebug)
            {
            	debugPort = currentDebugPort++;
                logger.info("Creating API processor for app: " + appPath + ", debug port is: " + debugPort);
            }
            else
            {
                logger.info("Creating API processor for app: " + appPath);
            }

            var apiProcessor = require("./lib/api-request-delegator")(appContainer, services.sessionStoreSpec, services.moduleStoreSpec, services.resourceResolverSpec, services.appRootPath, runForked, debugPort, loggingConfig, function(err, apiProcessor)
            {
                if (!err)
                {
                    apiProcessors[appPath] = apiProcessor;
                }
                onCompleted(err, apiProcessor);
            });
    	},

        getApiProcessor: function(appPath)
        {
            logger.debug("Getting API processor for appPath: " + appPath);
            return apiProcessors[appPath];
        },
        
        getAppModuleStore: function(appPath, appContainer, moduleStoreSpec)
        {
            // Create a module store from a full configuration and cache it in case we need it later (or in case someone
            // calling getAppModuleStoreForPath (below) needs it...
            //
            if (!moduleStores[appPath])
            {
                var moduleStore = exports.createServiceFromSpec(moduleStoreSpec);
                moduleStores[appPath] = moduleStore.getAppModuleStore(appContainer);
            }

            return moduleStores[appPath];
        },

        getAppModuleStoreForPath: function(appPath)
        {
            // The apiProcessor has it's own module store instance, but since the apiProcessor may be running in a different
            // process, we don't have access to it.  There are cases where the main Node / web process (particularly when 
            // serving the the web site for the Synchro "studio" application) needs a module store using the same configuration
            // information.  We lazily create and then cache any referenced module stores for our own use.
            //
            if (!moduleStores[appPath])
            {
                var apiProcessor = apiProcessors[appPath];
                if (apiProcessor)
                {
                    this.getAppModuleStore(appPath, apiProcessor.appContainer, apiProcessor.moduleStoreSpec);
                }
                else
                {
                    // There was no chached module store for this path, and there was no API processor for this
                    // path which we could have used to create a module store.
                    //
                    logger.error("No API processor for path: " + appPath + " is available to create module store");
                    return null;
                }
            }
            
            return moduleStores[appPath];
        },

        getApiProcessors: function()
        {
            return apiProcessors;
        },

        processHttpRequest: function(appPath, request, response)
        {
            logger.debug("Processing http request for appPath: " + appPath);
            var apiProcessor = apiProcessors[appPath];
            if (apiProcessor)
            {
                apiProcessor.processHttpRequest(request, response);
            }
            else
            {
                // !!! BAD - No apiProcessor found at appPath
            }
        },
    }

    return apiManager;
}

exports.createService = function(serviceName, serviceConfiguration)
{
    var service;

    switch (serviceName)
    {
        case "FileModuleStore":
        {
            service = require('./lib/file-module-store')(serviceConfiguration);
        }
        break;

        case "MemorySessionStore":
        {
            service = require('./lib/session-store')(serviceConfiguration);
        }
        break;

        case "FileSessionStore":
        {
            service = require('./lib/file-session-store')(serviceConfiguration);
        }
        break;

        case "RedisSessionStore":
        {
            service = require('./lib/redis-session-store')(serviceConfiguration);
        }
        break;

        case "ResourceResolver":
        {
            service = require('./lib/resource-resolver')(serviceConfiguration);
        }
        break;
    }

    return service;
}
